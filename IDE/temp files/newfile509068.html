<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HTVM</title>
        <style>
            body {
                background-color: #202020;
                font-family:
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    Oxygen-Sans,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Helvetica,
                    Arial,
                    sans-serif;
            }
        </style>

</head>
    <body>
<script>


function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}

function print(value) {
    console.log(value)
}

// Convert value to string
function STR(value) {
    if (value === null || value === undefined) {
        return ""; // Return a string for null or undefined
    } else if (typeof value === 'number') {
        return value.toString();
    } else if (typeof value === 'boolean') {
        return value ? "1" : "0";
    } else if (typeof value === 'string') {
        return value; // Return the string as is
    } else {
        // Handle any unexpected types gracefully
        return String(value); // Convert any other type to a string
    }
}

// Convert value to float
function FLOAT(value) {
    const floatValue = parseFloat(value);
    if (isNaN(floatValue)) {
        throw new TypeError("Cannot convert to float");
    }
    return floatValue;
}

// Function to find the position of needle in haystack (string overload)
function InStr(haystack, needle) {
    const pos = haystack.indexOf(needle);
    return (pos !== -1) ? pos + 1 : 0;
}

// Function to simulate input() in JavaScript
function input(promptText) {
    // Display the prompt and get user input
    return prompt(promptText);
}

function Exp(value) {
    return Math.exp(value);
}

function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}

function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}


//Shunting Yard Algorithm
var str1 = "";
var str2 = "";
var str3 = "";
var str4 = "";
var str5 = "";
var str6 = "";
var str7 = "";
var str8 = "";
var str9 = "";
var str10 = "";
var int1 = 0;
var int2 = 0;
var int3 = 0;
var int4 = 0;
var int5 = 0;
var int6 = 0;
var int7 = 0;
async function  swapLast2StrArrayElement(theStrArray) {
    // Check if the array has at least two elements
    if (theStrArray.length < 2) {
        return theStrArray;
    }
    // Get the indices of the last two elements
    var lastIndex = theStrArray.length - 1;
    var secondLastIndex = lastIndex - 1;
    // Swap the last two elements
    var temp = theStrArray[lastIndex];
    theStrArray[lastIndex] = theStrArray[secondLastIndex];
    theStrArray[secondLastIndex] = temp;
    // Return the modified array
    return theStrArray;
}
async function  popFirstStrArrayElement(theStrArray) {
    let out123 = [];
    for (let A_Index1 = 0; A_Index1 < theStrArray.length + 0; A_Index1++) {
        if (A_Index1 > 0) {
            out123.push(theStrArray[A_Index1]);
        }
    }
    return out123;
}
async function expresionEval(expresion) {
    var expresionOut = "";
    let holdingStack = [];
    let outputTemp = [];
    let solvingStack = [];
    var input = "0";
    var arithmeticOperations = "-+*/";
    var arithmeticOperationStrength = 0;
    var tempPopHoldingStack = "";
    var indexOfexpresionLoop = 0;
    var expresion = StrReplace(expresion, " ", "");
    expresion = StrReplace(expresion, "-", " - ");
    expresion = StrReplace(expresion, "+", " + ");
    expresion = StrReplace(expresion, "*", " * ");
    expresion = StrReplace(expresion, "/", " / ");
    items2 = LoopParseFunc(expresion, " ")
    for (let A_Index2 = 0; A_Index2 < items2.length + 0; A_Index2++) {
        const A_LoopField2 = items2[A_Index2 - 0];
        indexOfexpresionLoop = A_Index2 + 1;
        input = A_LoopField2;
        if (InStr(arithmeticOperations, input) == 0) {
            // numbers
            //print(input)
            outputTemp.push(input);
        } else {
            // arithmeticOperation
            //print(input)
            if (holdingStack.length == 0) {
                holdingStack.push(input);
            } else {
                if (InStr(arithmeticOperations, input) == InStr(arithmeticOperations, holdingStack[holdingStack.length - 1])) {
                    outputTemp.push(input);
                }
                else if (InStr(arithmeticOperations, holdingStack[holdingStack.length - 1]) < InStr(arithmeticOperations, input)) {
                    holdingStack.push(input);
                } else {
                    // what do we do
                    // add the last
                    for (let A_Index3 = 0; ; A_Index3++) {
                        if (holdingStack.length > 0 && InStr(arithmeticOperations, holdingStack[holdingStack.length - 1]) > InStr(arithmeticOperations, input)) {
                            tempPopHoldingStack = holdingStack[holdingStack.length - 1];
                            holdingStack.pop();
                            outputTemp.push(tempPopHoldingStack);
                        } else {
                            break;
                        }
                    }
                    holdingStack.push(input);
                }
                // 2 else and 1 loop end
            }
        }
    }
    if (holdingStack.length != 0 || STR(holdingStack.length) != "") {
        for (let A_Index4 = 0; A_Index4 < holdingStack.length + 0; A_Index4++) {
            outputTemp.push(holdingStack[A_Index4]);
        }
    }
    print(outputTemp);
    for (let A_Index5 = 0; ; A_Index5++) {
        if (outputTemp.length == 0 || STR(outputTemp.length) == "") {
            break;
        }
        tempPopHoldingStack = outputTemp[0];
        outputTemp = await popFirstStrArrayElement(outputTemp);
        solvingStack.push(tempPopHoldingStack);
        if (InStr(arithmeticOperations, solvingStack[solvingStack.length - 1]) != 0) {
            solvingStack = await swapLast2StrArrayElement(solvingStack);
            int1 = FLOAT(solvingStack[solvingStack.length - 3]);
            str2 = solvingStack[solvingStack.length - 2];
            int3 = FLOAT(solvingStack[solvingStack.length - 1]);
            solvingStack.pop();
            solvingStack.pop();
            solvingStack.pop();
            if (str2 == "-") {
                int4 = int1 - int3;
                solvingStack.push(STR(int4));
            }
            if (str2 == "+") {
                int4 = int1 + int3;
                solvingStack.push(STR(int4));
            }
            if (str2 == "*") {
                int4 = int1 * int3;
                solvingStack.push(STR(int4));
            }
            if (str2 == "/") {
                int4 = int1 / int3;
                solvingStack.push(STR(int4));
            }
        }
    }
    expresionOut = solvingStack[solvingStack.length - 1];
    if (Trim(expresionOut) == "") {
        expresionOut = "null";
    }
    return expresionOut;
}
async function main() {
    print("Shunting Yard Algorithm");
    var expresion = "1+2*4-3";
    print(await expresionEval(expresion));
    var testExpresions = "3+5|12-4|7*3|18/6|4+92|10-23|15+3-2|87-9|6+8/4|32+5|18-4/2|6/3+8|14-62|5+9/3|75-3|8+43|9/3+42|12+6*2-3|16-4/2+3|1+2*4-3";
    var answersOfTheTestExpresions = "8|8|21|3|96|-13|16|78|8|37|16|10|-48|8|72|51|45|21|17|6";
    var testIndexTestExpresions = 0;
    var TEMPanswersOfTheTestExpresions = "";
    var DidWePassTheTestExpresions = 1;
    var DidWePassTheTestExpresionsCOUNT = 0;
    var DidWePassTheTestExpresionsCOUNTMAX = 0;
    items6 = LoopParseFunc(testExpresions, "|")
    for (let A_Index6 = 0; A_Index6 < items6.length + 0; A_Index6++) {
        const A_LoopField6 = items6[A_Index6 - 0];
        DidWePassTheTestExpresionsCOUNT++;
        DidWePassTheTestExpresionsCOUNTMAX++;
        testIndexTestExpresions = A_Index6;
        items7 = LoopParseFunc(answersOfTheTestExpresions, "|")
        for (let A_Index7 = 0; A_Index7 < items7.length + 0; A_Index7++) {
            const A_LoopField7 = items7[A_Index7 - 0];
            if (A_Index7 == testIndexTestExpresions) {
                TEMPanswersOfTheTestExpresions = A_LoopField7;
            }
        }
        print(STR(A_Index6 + 1) + " ===============================");
        print(A_LoopField6);
        print(await expresionEval(A_LoopField6));
        if (FLOAT(await expresionEval(A_LoopField6)) == FLOAT(TEMPanswersOfTheTestExpresions)) {
            print("true");
        } else {
            print("false");
            DidWePassTheTestExpresionsCOUNT--;
            DidWePassTheTestExpresions = 0;
        }
    }
    print("==================================");
    print("==================================");
    if (DidWePassTheTestExpresions == 0) {
        print("TestExpresions NOT PASSED!!! " + STR(DidWePassTheTestExpresionsCOUNT) + "/" + STR(DidWePassTheTestExpresionsCOUNTMAX));
    } else {
        print("TestExpresions PASSED!!!" + STR(DidWePassTheTestExpresionsCOUNT) + "/" + STR(DidWePassTheTestExpresionsCOUNTMAX));
    }
}
main();
</script>
</body>
</html>