<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HTVM</title>
        <style>
            body {
                background-color: #202020;
                font-family:
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    Oxygen-Sans,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Helvetica,
                    Arial,
                    sans-serif;
            }
        </style>

</head>
    <body>
<script>


function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}

function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}

function StringTrimRight(input, numChars) {
    return (numChars <= input.length) ? input.substring(0, input.length - numChars) : input;
}

async function getDataFromEndpoint(data, endpoint, method = "POST") {
  let url = endpoint;
  let requestOptions = {
    method, // Use the provided method
    headers: {
      "Content-Type": "application/json",
    },
  };
  // If the method is GET, append data as query parameters
  if (method === "GET") {
    const queryParams = new URLSearchParams(data).toString();
    url += `?${queryParams}`;
  } else {
    // For POST/PUT, include the body
    requestOptions.body = JSON.stringify(data);
  }
  // Fetch data
  const response = await fetch(url, requestOptions);
  // Handle response
  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}. Status: ${response.status}`);
  }
  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("application/json")) {
    return response.json();
  } else {
    return response.text();
  }
}


async function main() {
    async function getFilesPathsAndStuff(command) {
        let files = "";
        let filesOut = "";
        files = Trim(getDataFromEndpoint(Trim(command), "/getFilesPathsAndStuff"));
        items1 = LoopParseFunc(files, "\n", "\r")
        for (let A_Index1 = 0; A_Index1 < items1.length + 0; A_Index1++) {
            const A_LoopField1 = items1[A_Index1 - 0];
            if (Trim(A_LoopField1) != "") {
                filesOut += Trim(A_LoopField1) + "\n";
            }
        }
        filesOut = StringTrimRight(filesOut, 1);
        return filesOut;
    }
}
main();
</script>
</body>
</html>