func str ExtractDigits(str inputString)
{
str digits := ""

Loop, Parse, inputString
{
    if (RegExMatch(A_LoopField, "\d"))
    {
        digits .= A_LoopField
    }
}
return digits
}

func str fixGoAindexUnseen(str codeToFixTheGoUNSEEN)
{

str AindexKeyWOrd := "A_Index"
; Regex to find all A_Index<num> occurrences
arr str fixAindexInGoUnused
int howMany_fixAindexInGoUnused := 10
int howMany_fixAindexInGoUnusedNUM := 0
int found_fixAindexInGoUnused := 0
str foundWHAT_fixAindexInGoUnused := ""

Loop, Parse, codeToFixTheGoUNSEEN, `n, `r
{
if (RegExMatch(A_LoopField, AindexKeyWOrd . "\d+"))
{
if (SubStr(Trim(A_LoopField), 1, 4) != "for ")
{
fixAindexInGoUnused.add(AindexKeyWOrd . ExtractDigits(StrSplit(A_LoopField, AindexKeyWOrd, 2)))
}
}
}


Loop, % howMany_fixAindexInGoUnused
{
howMany_fixAindexInGoUnusedNUM := A_Index
found_fixAindexInGoUnused := 0
foundWHAT_fixAindexInGoUnused := AindexKeyWOrd . STR(howMany_fixAindexInGoUnusedNUM)
Loop, % fixAindexInGoUnused.size()
{
if (fixAindexInGoUnused[A_Index] = AindexKeyWOrd . STR(howMany_fixAindexInGoUnusedNUM))
{
found_fixAindexInGoUnused := 1
break
}
} 

if (foundWHAT_fixAindexInGoUnused != "")
{
if (found_fixAindexInGoUnused = 0)
{
codeToFixTheGoUNSEEN := StrReplace(codeToFixTheGoUNSEEN, foundWHAT_fixAindexInGoUnused, "_")
}
}

}

return codeToFixTheGoUNSEEN

}

main

str code := "package main" . Chr(10) . "import (" . Chr(10) . "" . Chr(34) . "fmt" . Chr(34) . "" . Chr(10) . "" . Chr(34) . "regexp" . Chr(34) . "" . Chr(10) . ")" . Chr(10) . "" . Chr(10) . "func LoopParseFunc(varString string, delimiter1 string, delimiter2 string) []string {" . Chr(10) . "    var items []string" . Chr(10) . "    if delimiter1 == " . Chr(34) . "" . Chr(34) . " && delimiter2 == " . Chr(34) . "" . Chr(34) . " {" . Chr(10) . "        // If no delimiters are provided, convert string to slice of strings" . Chr(10) . "        items = make([]string, len(varString))" . Chr(10) . "        for i, c := range varString {" . Chr(10) . "            items[i] = string(c)" . Chr(10) . "        }" . Chr(10) . "    } else {" . Chr(10) . "        // Construct the regular expression pattern for splitting the string" . Chr(10) . "        pattern := fmt.Sprintf(" . Chr(34) . "[%s%s]+" . Chr(34) . ", delimiter1, delimiter2)" . Chr(10) . "        // Split the string using the constructed pattern" . Chr(10) . "        items = regexp.MustCompile(pattern).Split(varString, -1)" . Chr(10) . "    }" . Chr(10) . "    return items" . Chr(10) . "}" . Chr(10) . "" . Chr(10) . "func print(value interface{}) {" . Chr(10) . "	switch v := value.(type) {" . Chr(10) . "	case string:" . Chr(10) . "		fmt.Println(v)" . Chr(10) . "	case int, int32, int64:" . Chr(10) . "		fmt.Println(fmt.Sprintf(" . Chr(34) . "%d" . Chr(34) . ", v))" . Chr(10) . "	case float32, float64:" . Chr(10) . "		fmt.Println(fmt.Sprintf(" . Chr(34) . "%f" . Chr(34) . ", v))" . Chr(10) . "	case bool:" . Chr(10) . "		fmt.Println(fmt.Sprintf(" . Chr(34) . "%v" . Chr(34) . ", v))" . Chr(10) . "	default:" . Chr(10) . "		fmt.Println(" . Chr(34) . "Unsupported type" . Chr(34) . ")" . Chr(10) . "	}" . Chr(10) . "}" . Chr(10) . "" . Chr(10) . "func HTVM_Append[T any](arr *[]T, value T) {" . Chr(10) . "    *arr = append(*arr, value)" . Chr(10) . "}" . Chr(10) . "" . Chr(10) . "func HTVM_Size[T any](arr []T) int {" . Chr(10) . "    return len(arr)" . Chr(10) . "}" . Chr(10) . "" . Chr(10) . "" . Chr(10) . "func func1(var1 string) string {" . Chr(10) . "    return var1 + var1" . Chr(10) . "}" . Chr(10) . "func func2(var1 string) {" . Chr(10) . "    print(var1 + var1)" . Chr(10) . "}" . Chr(10) . "func func3(var1 string, __HTVM_V2_TO_GO_optionalParams__ ...interface{}) {" . Chr(10) . "    var2 := " . Chr(34) . "hello" . Chr(34) . "" . Chr(10) . "    if len(__HTVM_V2_TO_GO_optionalParams__) " . Chr(62) . " 0 {" . Chr(10) . "        var2 = __HTVM_V2_TO_GO_optionalParams__[0].(string)" . Chr(10) . "    }" . Chr(10) . "    print(var1 + " . Chr(34) . " " . Chr(34) . " + var2)" . Chr(10) . "}" . Chr(10) . "func main() {" . Chr(10) . "    print(func1(" . Chr(34) . "hi1" . Chr(34) . "))" . Chr(10) . "    func2(" . Chr(34) . "hi2" . Chr(34) . ")" . Chr(10) . "    func3(" . Chr(34) . "hi3" . Chr(34) . ")" . Chr(10) . "    func3(" . Chr(34) . "hi3" . Chr(34) . ", " . Chr(34) . "hello3" . Chr(34) . ")" . Chr(10) . "    var var1 int" . Chr(10) . "    var myArr0 []bool" . Chr(10) . "    HTVM_Append(&myArr0, true)" . Chr(10) . "    HTVM_Append(&myArr0, false)" . Chr(10) . "    HTVM_Append(&myArr0, true)" . Chr(10) . "    myArr := []int{5, 6, 7}" . Chr(10) . "    for A_Index1 := 0; A_Index1 " . Chr(60) . " 5 + 0; A_Index1++ {" . Chr(10) . "        var1 = 6" . Chr(10) . "        HTVM_Append(&myArr, A_Index1)" . Chr(10) . "    }" . Chr(10) . "    for A_Index2 := 0; A_Index2 " . Chr(60) . " HTVM_Size(myArr) + 0; A_Index2++ {" . Chr(10) . "        print(myArr[A_Index2])" . Chr(10) . "    }" . Chr(10) . "    for A_Index3 := 0; A_Index3 " . Chr(60) . " HTVM_Size(myArr0) + 0; A_Index3++ {" . Chr(10) . "        print(myArr0[A_Index3])" . Chr(10) . "    }" . Chr(10) . "    if (var1 == 6) {" . Chr(10) . "        print(var1)" . Chr(10) . "    } else if (var1 == 7) {" . Chr(10) . "        print(var1)" . Chr(10) . "    }" . Chr(10) . "    var var123 string = " . Chr(34) . "sdf" . Chr(92) . "naszdxgvh" . Chr(92) . "newsrdt" . Chr(92) . "nsdr" . Chr(92) . "rdfgcvbnb" . Chr(92) . "n" . Chr(92) . "rsdxfgcvn" . Chr(34) . "" . Chr(10) . "    items4 := LoopParseFunc(var123, " . Chr(34) . "" . Chr(92) . "n" . Chr(34) . ", " . Chr(34) . "" . Chr(92) . "r" . Chr(34) . ")" . Chr(10) . "    for A_Index4 , A_LoopField4 := range items4 {" . Chr(10) . "        if (A_Index4 == 0) {" . Chr(10) . "            print(A_Index4)" . Chr(10) . "        }" . Chr(10) . "        print(A_LoopField4)" . Chr(10) . "    }" . Chr(10) . "    print(" . Chr(34) . "==================" . Chr(34) . ")" . Chr(10) . "    var var1234 string = " . Chr(34) . "waesrdtg,qwerd,qwe rd,w esrd,wedr d,esrdgfesdrgsdrgf,sdrfg" . Chr(34) . "" . Chr(10) . "    items5 := LoopParseFunc(var1234, " . Chr(34) . "," . Chr(34) . ", " . Chr(34) . "" . Chr(34) . ")" . Chr(10) . "    for A_Index5 , A_LoopField5 := range items5 {" . Chr(10) . "        if (A_Index5 == 0) {" . Chr(10) . "            print(A_Index5)" . Chr(10) . "        }" . Chr(10) . "        print(A_LoopField5)" . Chr(10) . "    }" . Chr(10) . "    print(" . Chr(34) . "==================" . Chr(34) . ")" . Chr(10) . "    var var12345 string = " . Chr(34) . "hello" . Chr(34) . "" . Chr(10) . "    items6 := LoopParseFunc(var12345, " . Chr(34) . "" . Chr(34) . ", " . Chr(34) . "" . Chr(34) . ")" . Chr(10) . "    for A_Index6 , A_LoopField6 := range items6 {" . Chr(10) . "        print(A_LoopField6)" . Chr(10) . "    }" . Chr(10) . "}"
print(fixGoAindexUnseen(code))
