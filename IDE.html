<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTVM IDE</title>
    <style>
      body {
        background-color: #202020;
        font-family:
          "Open Sans",
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          Roboto,
          Oxygen-Sans,
          Ubuntu,
          Cantarell,
          "Helvetica Neue",
          Helvetica,
          Arial,
          sans-serif;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- Include Ace Editor CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.2/ace.js" integrity="sha512-JLIRlxWh96sND3uUgI2RVHZJpgkWHg3+xoUY8XkgTPKpqRaqdk7zD/ck/XHXFSMW84o6GrP67dlqN3b98NB/yA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-language_tools.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <body>
    <script>
      // JavaScript equivalent code with variables

      function changeFaviconAtTheBeginning(faviconUrl) {
        // Create a new favicon link element
        const newFavicon = document.createElement("link");
        newFavicon.rel = "icon";
        newFavicon.href = faviconUrl;

        // Get the current favicon element (if exists)
        const existingFavicon = document.querySelector('link[rel="icon"]');

        // Replace the current favicon with the new one
        if (existingFavicon) {
          // If a favicon exists, replace it
          document.head.removeChild(existingFavicon); // Remove the existing favicon
        }

        // Append the new favicon to the head
        document.head.appendChild(newFavicon);
      }

      // Call the function with the desired favicon URL
      changeFaviconAtTheBeginning("https://i.ibb.co/Jpty1B8/305182938-1a0efe63-726e-49ca-a13c-d0ed627f2ea7.png");

      function showCustomMessageBox(options, title, text, value, timeout) {
        return new Promise((resolve) => {
          // Define default options for the message box
          let defaultOptions = {
            title: title || "", // Default title is empty
            text: text || "Press OK to continue.", // Default text if not provided
            showCancelButton: false, // Default is to not show Cancel button
            showDenyButton: false, // Default is to not show Deny button
            confirmButtonText: "OK", // Default text for OK button
            focusConfirm: true, // Default focus on OK button
          };

          let numOriginal = value;

          let num = numOriginal;

          let done1 = 0;

          let done2 = 0;

          let done3 = 0;

          let AIndex = 0;

          for (AIndex = 1; AIndex <= 1; AIndex++) {
            // this is about if you add always on top in a msgbox it will be removed in js cuz its kinda useless...
            // becouse if you like adding always on top in ahk in js we dont realy do it so yeah
            if (num >= 262144) {
              num = num - 262144;
              numOriginal = numOriginal - 262144;
            }

            if (num >= 256 && num < 500) {
              num = num - 256;

              done3 = 256;
            }

            if (num >= 512) {
              num = num - 512;

              done3 = 512;
            }

            if (num == 0) {
              done1 = 0;

              break;
            }

            if (num <= 6) {
              done1 = num;

              break;
            }

            if (num >= 64 && num < 64 * 2) {
              done2 = 64;

              if (num == 64) {
                done1 = 0;

                break;
              } else {
                done1 = num - 64;

                break;
              }
            }

            if (num >= 48 && num < 63) {
              done2 = 48;

              if (num == 48) {
                done1 = 0;

                break;
              } else {
                done1 = num - 48;

                break;
              }
            }

            if (num >= 32 && num < 47) {
              done2 = 32;

              if (num == 32) {
                done1 = 0;

                break;
              } else {
                done1 = num - 32;

                break;
              }
            }

            if (num >= 16 && num < 30) {
              done2 = 16;

              if (num == 16) {
                done1 = 0;

                break;
              } else {
                done1 = num - 16;

                break;
              }
            }
          }

          let doneAdded = done1 + done2 + done3;

          if (doneAdded !== numOriginal) {
            // displayMessage("The calc was wrong!");
          } else {
            // displayMessage("num was: " + numOriginal + "\ndone1: " + done1 + "\ndone2: " + done2 + "\ndone3: " + done3);
          }

          // Parse the value to determine the options for the message box
          if (done1 === 1) defaultOptions.showCancelButton = true; // OK/Cancel in ahk but here it will show Ok/Cancel wiat its same haha

          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 2) {
          //     defaultOptions.showCancelButton = true; // Abort/Retry/Ignore
          //     defaultOptions.showDenyButton = true;
          //   }
          if (done1 === 3) {
            defaultOptions.showCancelButton = true; // Yes/No/Cancel in ahk but here it will show Ok/No/Cancel
            defaultOptions.showDenyButton = true;
          }
          if (done1 === 4) {
            // defaultOptions.showCancelButton = true;
            defaultOptions.showDenyButton = true; // Yes/No in ahk but here it will show Ok/No
          }
          if (done1 === 5) {
            defaultOptions.showCancelButton = true; // Retry/Cancel in ahk but here it will show Ok/Cancel tip you can write in the Msgbox press ok to retry
          }
          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 6) {
          //     defaultOptions.showCancelButton = true; // Cancel/Try Again/Continue
          //     defaultOptions.showDenyButton = true;
          //   }

          if (done2 === 16) defaultOptions.icon = "error"; // Icon Hand (stop/error)
          if (done2 === 32) defaultOptions.icon = "question"; // Icon Question
          if (done2 === 48) defaultOptions.icon = "warning"; // Icon Exclamation
          if (done2 === 64) defaultOptions.icon = "info"; // Icon Asterisk (info)

          if (done3 === 256) defaultOptions.focusDeny = true; // Makes the 3rd button the default
          if (done3 === 512) defaultOptions.focusCancel = true; // Makes the 2nd button the default

          // Set timeout if provided
          if (timeout) {
            defaultOptions.timer = timeout * 1000; // Convert timeout to milliseconds
          }

          // Merge default options with provided options
          Object.assign(defaultOptions, options);

          // Display the message box with the constructed options
          Swal.fire(defaultOptions).then((result) => {
            if (result.isConfirmed) {
              resolve("OK");
            } else if (result.isDenied) {
              resolve("No");
            } else {
              resolve("Cancel");
            }
          });
        });
      }

      var lastKeyPressed = "";

      function trackLastKeyPressed() {
        document.addEventListener("keydown", function (event) {
          lastKeyPressed = event.key;
          // console.log(lastKeyPressed);
        });
      }

      function getLastKeyPressed() {
        return lastKeyPressed;
      }

      // Call the trackLastKeyPressed function to start tracking key presses
      trackLastKeyPressed();

      let lastInputTime = Date.now(); // Initialize with current timestamp
      let startTimestamp = Date.now(); // Initialize with current timestamp

      // Event listener to track user activity
      function resetIdleTimer() {
        lastInputTime = Date.now(); // Update last input time
      }

      document.addEventListener("mousemove", resetIdleTimer);
      document.addEventListener("keypress", resetIdleTimer);

      // Function to calculate time since last input event
      function A_TimeIdle() {
        return Date.now() - lastInputTime; // Calculate time difference
      }

      // Function to calculate tick count in milliseconds
      function A_TickCount() {
        return Date.now() - startTimestamp;
      }

      function GuiControl(action, id, param1, param2, param3, param4) {
        const element = document.getElementById(id);
        if (element) {
          // Handle DOM elements
          if (action === "move") {
            // Set position and size
            element.style.left = param1 + "px";
            element.style.top = param2 + "px";
            element.style.width = param3 + "px";
            element.style.height = param4 + "px";
          } else if (action === "focus" && (element instanceof HTMLInputElement || element instanceof HTMLElement)) {
            // Focus on the element
            element.focus();
          } else if (action === "text") {
            // Set new text content
            element.textContent = param1;
          } else if (action === "hide") {
            // Hide the element
            element.style.display = "none";
          } else if (action === "show") {
            // Show the element
            element.style.display = "";
          } else if (action === "enable") {
            // Enable the element
            element.disabled = false;
          } else if (action === "disable") {
            // Disable the element
            element.disabled = true;
          } else if (action === "font") {
            // Set font size
            element.style.fontSize = param1 + "px";
          } else if (action === "destroy") {
            // Remove the element from the DOM
            element.parentNode.removeChild(element);
          } else if (action === "color") {
            // Set color
            element.style.color = param1;
          } else if (action === "picture") {
            // Change the image source
            if (element instanceof HTMLImageElement) {
              element.src = param1;
            } else {
              console.error("Element is not an <img> tag, cannot change picture.");
            }
          } else if (action === "textide") {
            // Set value for Ace editor
            var editor = ace.edit(id); // Access the Ace editor instance using its ID
            if (editor && param1) {
              editor.session.setValue(param1);
            } else {
              console.error("Element is not an Ace editor or parameter is missing.");
            }
          }
        } else {
          // Handle canvas or non-existing element
          if (action === "move") {
            // Update position and size of the rectangle
            updateRectangle(id, param1, param2, param3, param4);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          } else if (action === "color") {
            // Update color of the rectangle
            updateRectangleColor(id, param1);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          }
        }
      }

      function BuildInVars(varName) {
        switch (varName) {
          case "A_ScreenWidth":
            // Return screen width
            return window.innerWidth;
          case "A_LastKey":
            // Return screen width
            return getLastKeyPressed();
          case "A_ScreenHeight":
            // Return screen height
            return window.innerHeight;
          case "A_TimeIdle":
            // Return time idle
            return A_TimeIdle();
          case "A_TickCount":
            // Return tick count in milliseconds
            return A_TickCount();
          case "A_Now":
            // Return current local timestamp
            return new Date().toLocaleString();
          case "A_YYYY":
            // Return current year
            return new Date().getFullYear();
          case "A_MM":
            // Return current month
            return (new Date().getMonth() + 1).toString().padStart(2, "0");
          case "A_DD":
            // Return current day
            return new Date().getDate().toString().padStart(2, "0");
          case "A_MMMM":
            // Return full month name
            return new Date().toLocaleDateString(undefined, { month: "long" });
          case "A_MMM":
            // Return short month name
            return new Date().toLocaleDateString(undefined, { month: "short" });
          case "A_DDDD":
            // Return full day name
            return new Date().toLocaleDateString(undefined, { weekday: "long" });
          case "A_DDD":
            // Return short day name
            return new Date().toLocaleDateString(undefined, { weekday: "short" });
          case "A_Hour":
            // Return current hour
            return new Date().getHours().toString().padStart(2, "0");
          case "A_Min":
            // Return current minute
            return new Date().getMinutes().toString().padStart(2, "0");
          case "A_Sec":
            // Return current second
            return new Date().getSeconds().toString().padStart(2, "0");
          case "A_Space":
            // Return space character
            return " ";
          case "A_Tab":
            // Return tab character
            return "\t";

          default:
            // Handle unknown variable names
            return null;
        }
      }

      function Chr(number) {
        // Check if the number is null
        if (number === null) {
          // Return an empty string
          return "";
        }

        // Check if the number is within the valid range
        if (number >= 0 && number <= 0x10ffff) {
          // Convert the number to a character using String.fromCharCode
          return String.fromCharCode(number);
        } else {
          // Return an empty string for invalid numbers
          return "";
        }
      }

      // Define the custom "ht" language for Ace Editor with AHK rules
      ace.define("ace/mode/ht", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/text_highlight_rules"], function (require, exports, module) {
        var oop = require("ace/lib/oop");
        var TextMode = require("ace/mode/text").Mode;
        var TextHighlightRules = require("ace/mode/text_highlight_rules").TextHighlightRules;

        var HTHighlightRules = function () {
          this.$rules = {
            start: [{ token: "comment", regex: "\/\/.*$" },
              { token: "keywords", regex: "\\b(if|else if|else|while|for|Loop|Loop,|Loop, Parse,|continue|break|func|await|switch|case|throw|Try|Catch|Finally|var|let|const|return|end)\\b" },
              { token: "command", regex: "\\b(StringTrimLeft|StringTrimRight)(?=\\,)" },
              { token: "functions", regex: "\\b(LoopParseFunc|LoopParseFunc|LoopParseFunc|HTVM_func1|print|print|INT|STR|FLOAT|InStr|Random|Sleep|input|FileRead|FileAppend|FileDelete|StrLen|Asc|Abs|ACos|ASin|ATan|Ceil|Cos|Exp|Ln|Log|Round|Sin|Sqrt|Tan|SubStr|Trim|StrReplace|StringTrimLeft|StringTrimRight|StrLower|StrSplit|Chr|Mod|Floor|Sort|getDataFromAPI|FileCreateDir|FileRemoveDir|FileExist|isWindows|GetParams|BuildInVars|RegExReplace|RunCMD|RegExMatch|ExitApp|ErrorMsg)(?=\\()" },
              { token: "BuildInFunc", regex: "\\b(A_Index|A_LoopField)\\b" },
              { token: "arrayMethods", regex: "\\.(\\|\\pop|\\size|\\insert|\\rm|\\indexOf)\\b" },
              { token: "static_types", regex: "\\b(int|str|bool|float|int8|int16|int32|int64|arr|arr int|arr str|arr float|arr bool)\\b" },
              { token: "operators", regex: " && | or | and | && " },
              { token: "trueANDfalse", regex: "\\b(true|false|global)\\b" },
              { token: "variables", regex: "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b" },
              { token: "constant.numeric", regex: "\\b[0-9]+\\b" },
              { token: "braces_Open", regex: "\\{" },
              { token: "braces_Close", regex: "\\}" },
              { token: "string", regex: '".*?"' },
              // Multi-line comments
              {
                token: "comment.block", // Token for multi-line comments
                regex: /\/\\*/, // Start of multi-line comment
                next: "comment_block",
              },
            ],
            comment_block: [
              {
                token: "comment.block",
                regex: /.*?\\*\//, // End of multi-line comment
                next: "start", // Go back to the start state
              },
              {
                token: "comment.block",
                regex: /.*/, // Any other content within the comment
              },
            ],
          };
        };
 oop.inherits(HTHighlightRules, TextHighlightRules);

        var HTMode = function () {
          this.HighlightRules = HTHighlightRules;
        };
        oop.inherits(HTMode, TextMode);

        exports.Mode = HTMode;
      });

      function AddIDE(parent, xPos, yPos, w, h, id, font = 18, langName = "autohotkey", onChangeFunc, initialText = "") {
        var langTools = ace.require("ace/ext/language_tools");

        let Completer = {
          getCompletions: function (editor, session, pos, prefix, callback) {
            if (prefix.startsWith("p")) {
              // Continue executing if the prefix starts with "p"
            } else {
              // Return early if the prefix does not start with "p" and its length is not greater than 1
              if (prefix.length <= 1) {
                callback(null, []); // Return an empty array of completions
                return;
              }
            }

            let prefixLower = prefix.toLowerCase();
            let filteredTables = hth.filter(function (table) {
              return table.name.toLowerCase().startsWith(prefixLower);
            });
            // filteredTables.sort(function(a, b) {
            //     return a.name.length - b.name.length;
            // });
            let limitedTables = filteredTables; //.slice(-10);

            callback(
              null,
              limitedTables.map(function (table) {
                return {
                  caption: table.name,
                  value: table.name,
                };
              }),
            );
          },
        };
        // Combined keywords for "ht" and AHK
        let hth = [{ name: "if" }, { name: "else if" }, { name: "else" }, { name: "while" }, { name: "for" }, { name: "Loop" }, { name: "Loop," }, { name: "Loop, Parse," }, { name: "continue" }, { name: "break" }, { name: "func" }, { name: "await" }, { name: "switch" }, { name: "case" }, { name: "throw" }, { name: "Try" }, { name: "Catch" }, { name: "Finally" }, { name: "var" }, { name: "let" }, { name: "const" }, { name: "return" }, { name: "end" }, { name: "StringTrimLeft" }, { name: "StringTrimRight" }, { name: "LoopParseFunc" }, { name: "LoopParseFunc" }, { name: "LoopParseFunc" }, { name: "HTVM_func1" }, { name: "print" }, { name: "print" }, { name: "INT" }, { name: "STR" }, { name: "FLOAT" }, { name: "InStr" }, { name: "Random" }, { name: "Sleep" }, { name: "input" }, { name: "FileRead" }, { name: "FileAppend" }, { name: "FileDelete" }, { name: "StrLen" }, { name: "Asc" }, { name: "Abs" }, { name: "ACos" }, { name: "ASin" }, { name: "ATan" }, { name: "Ceil" }, { name: "Cos" }, { name: "Exp" }, { name: "Ln" }, { name: "Log" }, { name: "Round" }, { name: "Sin" }, { name: "Sqrt" }, { name: "Tan" }, { name: "SubStr" }, { name: "Trim" }, { name: "StrReplace" }, { name: "StringTrimLeft" }, { name: "StringTrimRight" }, { name: "StrLower" }, { name: "StrSplit" }, { name: "Chr" }, { name: "Mod" }, { name: "Floor" }, { name: "Sort" }, { name: "getDataFromAPI" }, { name: "FileCreateDir" }, { name: "FileRemoveDir" }, { name: "FileExist" }, { name: "isWindows" }, { name: "GetParams" }, { name: "BuildInVars" }, { name: "RegExReplace" }, { name: "RunCMD" }, { name: "RegExMatch" }, { name: "ExitApp" }, { name: "ErrorMsg" }, { name: "A_LoopField" }, { name: "A_Index" }, { name: "" }, { name: "pop" }, { name: "size" }, { name: "insert" }, { name: "rm" }, { name: "indexOf" }, { name: "int" }, { name: "str" }, { name: "bool" }, { name: "float" }, { name: "int8" }, { name: "int16" }, { name: "int32" }, { name: "int64" }, { name: "arr" }, { name: "arr int" }, { name: "arr str" }, { name: "arr float" }, { name: "arr bool" }, { name: "global" }];

        // Create a new div element for the editor
        var editorDiv = document.createElement("div");
        editorDiv.id = id;
        editorDiv.style.position = "absolute";
        editorDiv.style.left = xPos + "px";
        editorDiv.style.top = yPos + "px";
        editorDiv.style.width = w + "px";
        editorDiv.style.height = h + "px";
        editorDiv.style.fontSize = font + "px";

        // Append the editor div to the parent
        parent.appendChild(editorDiv);

        // Create a new editor instance inside the div
        var editor = ace.edit(id);
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/" + "ht");
        // editor.setOptions({
        //   enableBasicAutocompletion: true,
        //   enableLiveAutocompletion: true,
        //   behavioursEnabled: false, // Disable auto-pairing of characters
        // });

        editor.setOptions({
          enableBasicAutocompletion: false,
          enableSnippets: false,
          enableLiveAutocompletion: true,
          behavioursEnabled: false,
          showPrintMargin: false,
        });

        langTools.setCompleters([]);
        langTools.addCompleter(Completer);

        // Set initial text if provided
        if (initialText) {
          editor.setValue(initialText, -1); // -1 to move cursor to the beginning
        }

        // Track Vim mode status
        var isVimMode = false;

        // Hotkey to toggle Vim mode on/off (Ctrl + Alt + Shift + V)
        editor.commands.addCommand({
          name: "toggleVimMode",
          bindKey: { win: "Ctrl-Alt-Shift-V", mac: "Command-Alt-Shift-V" },
          exec: function () {
            if (isVimMode) {
              editor.setKeyboardHandler(null); // Disable Vim (back to default)
              isVimMode = false;
              console.log("Vim mode disabled");
            } else {
              editor.setKeyboardHandler("ace/keyboard/vim"); // Enable Vim
              isVimMode = true;
              console.log("Vim mode enabled");
            }
          },
        });

        // Apply CSS styles for the editor

        var css = `
                      body {
                        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                        background-color: #1a1818;
                        color: #ffffff;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        height: 100vh;
                        margin: 0;
                      }

                      .controls {
                        display: flex;
                        justify-content: center;
                        gap: 1rem;
                        margin: 1rem;
                        padding: 1rem;
                      }

                      button {
                        padding: 0.7rem;
                        font-size: 1.2em;
                        cursor: pointer;
                        background-color: #bababa;
                        color: #000000;
                        border: none;
                        border-radius: 0.2rem;
                        transition: background-color 0.3s;
                      }

                      button:hover {
                        background-color: #27ae60;
                      }

                      #${id} {
                        width: ${w}px;
                        height: ${h}px;
                        font-size: 1em;
                        border-radius: 0.3rem;
                      }

                      #result {
                        margin-top: 1rem;
                        font-size: 1.2em;
                        color: #999c9a;
                        font-weight: bold;
                        text-align: center;
                      }

                      .ace-monokai .ace_marker-layer .ace_active-line {
                        background-color: #103010 !important;
                      }

                      .ace-monokai {
                        background-color: #121212 !important;
                        color: #f8f8f2;
                      }

                      .ace-monokai .ace_gutter {
                        background: #204020 !important;
                        color: #cbcdc3 !important;
                      }

                      .ace-monokai .ace_gutter-active-line {
                        background-color: transparent !important;
                      }

                      .ace-monokai .ace_entity.ace_name.ace_tag,
                      .ace-monokai .ace_keyword,
                      .ace-monokai .ace_meta.ace_tag,
                      .ace-monokai .ace_storage {
                        color: #40a0e0 !important;
                      }

                      .ace-monokai .ace_entity.ace_name.ace_function,
                      .ace-monokai .ace_entity.ace_other,
                      .ace-monokai .ace_entity.ace_other.ace_attribute-name,
                      .ace-monokai .ace_variable {
                        color: #ff80df !important;
                      }

                      .ace-monokai .ace_comment {
                        color: #40d080 !important;
                        font-weight: line-through !important;
                      }

                      .ace-monokai .ace_commentOpen_Close {
                        color: #40d080 !important;
                        font-weight: line-through !important;
                      }

                      .ace-monokai .ace_variables {
                        color: #ffffff !important;
                      }

                      .ace-monokai .ace_functions {
                        color: #80dfff !important;
                      }

                    .ace-monokai .ace_keywords {
                color: #8080e0 !important; /* Customize color as needed */
                font-weight: bold !important;
            }
                      .ace-monokai .ace_braces_Open {
                        color: #FFFFff !important;
                      }

                      .ace-monokai .ace_braces_Close {
                        color: #FFFFff !important;
                      }

                      .ace-monokai .ace_arrayMethods {
                        color: #FAB820 !important;
                      }

                      .ace-monokai .ace_BuildInFunc {
                        color: #ff80df !important;
                      }

                      .ace-monokai .ace_command {
                        color: #40a0e0 !important;
                        font-weight: bold !important;
                      }

                      .ace-monokai .ace_static_types {
                        color: #569cd6 !important;
                        font-weight: bold !important;
                      }

                      .ace-monokai .ace_string {
                        color: #ffa0a0 !important;
                        font-weight: lighter !important;
                      }

                      .ace-monokai .ace_operators {
                        color: #00ffff !important;
                        font-weight: lighter !important;
                      }


                      .ace-monokai .ace_trueANDfalse {
                        color: #00ffff !important;
                        font-weight: lighter !important;
                      }

                      .ace-monokai .ace_escape-char {
                        color: #ff8000 !important;
                        font-weight: bold !important;
                      }

                      .ace-monokai .ace_punctuation,
                      .ace-monokai .ace_punctuation.ace _tag {
                        color: #ffa0a0 !important;
                      }

                      *::-webkit-scrollbar {
                        width: 1em;
                      }

                      *::-webkit-scrollbar-track {
                        box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
                      }

                      *::-webkit-scrollbar-thumb {
                        background-color: darkgrey;
                        outline: 1px solid slategrey;
                      }
                    `;

        var style = document.createElement("style");
        style.type = "text/css";
        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(document.createTextNode(css));
        }
        document.head.appendChild(style);

        // Bind change event listener to the editor
        editor.getSession().on("change", function () {
          var code = editor.getValue();
          if (typeof onChangeFunc === "function") {
            onChangeFunc(code);
          }
        });
      }

      // Helper function to set the internal array's size as a string
      function setInternalArraySize(element, size) {
        if (typeof element === "string") {
          return size.toString();
        }
        return size;
      }

      // Convert string to int
      function INT(str) {
        return str;
      }

      // Convert various types to string
      function STR(value) {
        return value;
      }

      // Exponential
      function Exp(num) {
        if (num === null || isNaN(num)) return null;
        return Math.exp(num);
      }

      // Base-10 logarithm
      function Log(num) {
        if (num === null || isNaN(num)) return null;
        return Math.log10(num);
      }

      function Chr(number) {
        // Check if the number is null
        if (number === null) {
          // Return an empty string
          return "";
        }

        // Check if the number is within the valid range
        if (number >= 0 && number <= 0x10ffff) {
          // Convert the number to a character using String.fromCharCode
          return String.fromCharCode(number);
        } else {
          // Return an empty string for invalid numbers
          return "";
        }
      }

      // InStr
      function InStr(Haystack, Needle, CaseSensitive = true, StartingPos = 1, Occurrence = 1) {
        if (Haystack === null || Needle === null) return false;

        // Adjust starting position if less than 1
        StartingPos = Math.max(StartingPos, 1);

        // Case-sensitive search by default
        if (!CaseSensitive) {
          Haystack = Haystack.toLowerCase();
          Needle = Needle.toLowerCase();
        }

        let pos = -1;
        let count = 0;
        for (let i = StartingPos - 1; i < Haystack.length; i++) {
          if (Haystack.substring(i, i + Needle.length) === Needle) {
            count++;
            if (count === Occurrence) {
              pos = i + 1;
              break;
            }
          }
        }

        return pos > 0; // Return true if the substring is found, false otherwise
      }

      // RegExMatch
      function RegExMatch(Haystack, NeedleRegEx, OutputVar, StartingPos) {
        if (Haystack === null || NeedleRegEx === null) return null;

        const regex = new RegExp(NeedleRegEx);
        let match;

        if (typeof Haystack === "string") {
          match = Haystack.match(regex);
        }

        if (match) {
          if (OutputVar) {
            OutputVar.push(match[0]);
          }
          return match.index + 1;
        } else {
          return 0;
        }
      }

      // StrLen
      function StrLen(str) {
        if (typeof str !== "string") {
          console.error("Invalid input: expected a string but received:", str);
          return 0; // Return 0 or handle as needed
        }
        return str.length;
      }

      function SubStr(str, startPos, length) {
        // If str is null or undefined, return an empty string
        if (str === null || str === undefined) {
          return "";
        }

        // If length is not provided or is blank, default to "all characters"
        if (length === undefined || length === "") {
          length = str.length - startPos + 1;
        }

        // If startPos is less than 1, adjust it to start from the end of the string
        if (startPos < 1) {
          startPos = str.length + startPos;
        }

        // Extract the substring based on startPos and length
        return str.substr(startPos - 1, length);
      }

      function Trim(inputString) {
        // Check if inputString is null or undefined
        if (inputString == null) {
          return ""; // Return an empty string if inputString is null or undefined
        }
        return inputString.replace(/^\s+|\s+$/g, ""); // Removes leading and trailing whitespace
      }

      async function ParseInt(num) {
        if (num === null) {
          return null;
        }

        num = num.trim();
        num++;
        num--;

        return num;
      }

      function StrReplace(originalString, find, replaceWith) {
        // Check if originalString is a string
        if (typeof originalString !== "string") {
          return originalString; // Return originalString as is
        }

        // Escape special characters in the 'find' string to be used literally
        const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Use replace method to replace all occurrences of 'find' with 'replaceWith'
        return originalString.replace(new RegExp(escapedFind, "g"), replaceWith);
      }

      // Custom Mod function
      function Mod(dividend, divisor) {
        return dividend % divisor;
      }

      // Function to trim specified number of characters from the left side of a string
      function StringTrimLeft(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      // Function to trim specified number of characters from the right side of a string
      function StringTrimRight(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(0, input.length - numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      function StrLower(string) {
        if (typeof string !== "string") {
          console.error("Invalid input: expected a string but received:", string);
          return ""; // Return an empty string or handle as needed
        }
        return string.toLowerCase();
      }

      function StrSplit(inputStr, delimiter, num) {
        // Check if inputStr is a valid string
        if (typeof inputStr !== "string") {
          return ""; // Return empty string for invalid input
        }

        // Split the input string based on the delimiter
        const parts = inputStr.split(delimiter);

        // Return the part specified by the num parameter (1-based index)
        if (num > 0 && num <= parts.length) {
          return parts[num - 1]; // Return the specified part (0-based index)
        } else {
          return ""; // Return an empty string if num is out of range
        }
      }

      // Function to simulate AutoHotkey's RegExReplace in JavaScript
      function RegExReplace(inputStr, regexPattern, replacement) {
        // Create a regular expression object using the provided pattern
        const regex = new RegExp(regexPattern, "g"); // 'g' flag for global match

        // Use the replace() method to perform the regex replacement
        const resultStr = inputStr.replace(regex, replacement);

        // Return the modified string
        return resultStr;
      }

      // Function to escape special characters for regex
      function escapeRegex(str) {
        if (typeof str !== "string") {
          console.error("Invalid input for escapeRegex: expected a string but received:", str);
          return "";
        }
        return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      // Function to split a string based on delimiters
      function LoopParseFunc(var_, delimiter1 = "", delimiter2 = "") {
        if (typeof var_ !== "string") {
          console.error("Invalid input: expected a string but received:", var_);
          return []; // Return an empty array or handle as needed
        }

        if (!delimiter1 && !delimiter2) {
          return var_.split("");
        } else {
          const escapedDelimiters = escapeRegex(delimiter1 + delimiter2);
          const pattern = new RegExp(`[${escapedDelimiters}]+`);
          return var_.split(pattern).filter(Boolean);
        }
      }

      // MsgBox function
      function MsgBox(value) {
        console.log(value.toString());
      }

      // Sorting function

      function SortLikeAHK(varName, options = "") {
        let delimiter = "\n"; // Default delimiter
        let delimiterIndex = options.indexOf("D");

        if (delimiterIndex !== -1) {
          let delimiterChar = options[delimiterIndex + 1];
          delimiter = delimiterChar === "" ? "," : delimiterChar;
        }

        let items = varName.split(new RegExp(delimiter === "," ? "," : "\\" + delimiter));

        // Remove empty items and trim whitespace
        items = items.filter((item) => item.trim() !== "");

        // Apply sorting based on options
        if (options.includes("N")) {
          // Numeric sort
          items.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
        } else if (options.includes("Random")) {
          // Random sort
          for (let i = items.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [items[i], items[j]] = [items[j], items[i]];
          }
        } else {
          // Default alphabetical sort
          items.sort((a, b) => {
            const keyA = options.includes("C") ? a : a.toLowerCase();
            const keyB = options.includes("C") ? b : b.toLowerCase();
            if (keyA < keyB) return -1;
            if (keyA > keyB) return 1;
            return 0;
          });
        }

        // Reverse if 'R' option is present
        if (options.includes("R")) {
          items.reverse();
        }

        // Remove duplicates if 'U' option is present
        if (options.includes("U")) {
          const seen = new Map();
          items = items.filter((item) => {
            const key = options.includes("C") ? item : item.toLowerCase();
            if (!seen.has(key)) {
              seen.set(key, item);
              return true;
            }
            return false;
          });
        }

        // Join the sorted items back into a string
        const sortedVar = items.join(delimiter === "," ? "," : "\n");

        return sortedVar;
      }

      function MakeHotKey(hotkey, callback) {
        document.addEventListener("keydown", function (event) {
          const keys = hotkey.split("+").map((key) => key.trim().toLowerCase());
          const modifiers = {
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
          };

          let hotkeyPressed = true;
          keys.forEach((key) => {
            if (key === "ctrl" || key === "shift" || key === "alt") {
              if (!modifiers[key]) {
                hotkeyPressed = false;
              }
            } else if (key === "backspace") {
              if (event.key !== "Backspace") {
                hotkeyPressed = false;
              }
            } else if (key.startsWith("arrow")) {
              const arrowDirection = key.replace("arrow", "");
              if (arrowDirection === "up" && event.key !== "ArrowUp") {
                hotkeyPressed = false;
              } else if (arrowDirection === "down" && event.key !== "ArrowDown") {
                hotkeyPressed = false;
              } else if (arrowDirection === "left" && event.key !== "ArrowLeft") {
                hotkeyPressed = false;
              } else if (arrowDirection === "right" && event.key !== "ArrowRight") {
                hotkeyPressed = false;
              }
            } else if (key === "enter") {
              if (event.key !== "Enter") {
                hotkeyPressed = false;
              }
            } else if (!event.key.match(/^[0-9a-zA-Z]$/) && event.key !== key) {
              hotkeyPressed = false;
            } else if (event.key.toLowerCase() !== key && event.key.match(/^[a-zA-Z]$/)) {
              hotkeyPressed = false;
            }
          });

          if (hotkeyPressed) {
            if (modifiers["shift"]) {
              callback(hotkey.toUpperCase());
            } else {
              callback(hotkey.toLowerCase());
            }
          }
        });
      }

      // InStr
      function InStr(Haystack, Needle, CaseSensitive = true, StartingPos = 1, Occurrence = 1) {
        if (Haystack === null || Needle === null) return false;

        // Adjust starting position if less than 1
        StartingPos = Math.max(StartingPos, 1);

        // Case-sensitive search by default
        if (!CaseSensitive) {
          Haystack = Haystack.toLowerCase();
          Needle = Needle.toLowerCase();
        }

        let pos = -1;
        let count = 0;
        for (let i = StartingPos - 1; i < Haystack.length; i++) {
          if (Haystack.substring(i, i + Needle.length) === Needle) {
            count++;
            if (count === Occurrence) {
              pos = i + 1;
              break;
            }
          }
        }

        return pos > 0; // Return true if the substring is found, false otherwise
      }

      function Trim(inputString) {
        // Check if inputString is null or undefined
        if (inputString == null) {
          return ""; // Return an empty string if inputString is null or undefined
        }
        return inputString.replace(/^\s+|\s+$/g, ""); // Removes leading and trailing whitespace
      }

      function StrReplace(originalString, find, replaceWith) {
        // Check if originalString is a string
        if (typeof originalString !== "string") {
          return originalString; // Return originalString as is
        }

        // Escape special characters in the 'find' string to be used literally
        const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Use replace method to replace all occurrences of 'find' with 'replaceWith'
        return originalString.replace(new RegExp(escapedFind, "g"), replaceWith);
      }

      // Function to trim specified number of characters from the right side of a string
      function StringTrimRight(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(0, input.length - numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      // Define the str function
      function str(value) {
        return String(value);
      }

      // Single async function to structure the entire script
      async function runScript() {
        // Declare and assign a variable

        MakeHotKey("Alt+Shift+Ctrl+F", function (hotkey) {
          HotKeyCalledAltShiftCtrlF();
        });

        MakeHotKey("Alt+Shift+Ctrl+G", function (hotkey) {
          HotKeyCalledAltShiftCtrlG();
        });

        var Gui1 = {};
        Gui1 = document.createElement("div");
        Gui1.id = "Gui1";

        // Declare and assign a variable
        let variables = {
          null: null,
        };

        Gui1.style.position = "absolute";
        Gui1.style.width = window.innerWidth + "px"; // Set the width
        Gui1.style.height = "" + BuildInVars("A_ScreenHeight") + "px"; // Set the height
        Gui1.style.background = "linear-gradient(90deg, " + "#121212" + " 0%, " + "#121212" + " 100%)";
        Gui1.style.backgroundColor = "linear-gradient(90deg, " + "#121212" + " 0%, " + "#121212" + " 100%)";
        Gui1.style.color = "white";
        Gui1.style.fontSize = "15px";
        Gui1.style.padding = "0px";
        Gui1.style.borderRadius = "0px";
        Gui1.style.fontFamily = ", sans-serif"; // Specify your desired font here
        Gui1.style.zIndex = "10";
        document.body.appendChild(Gui1); // Append the GUI window to the body
        Gui1.style.display = "block";
        let textOldSave;
        document.documentElement.setAttribute("style", "padding: 0; margin: 0;");
        document.head.setAttribute("style", "padding: 0; margin: 0;");
        document.body.setAttribute("style", "overflow-x: hidden;padding: 0; margin: 0;");
        variables.ideTEXT = `// This is the preview of your language, and this is how your programming language will look.

// If you use types here how they will look like if you only define them:
int varName1;
str varName2;
bool varName3;
float varName4;
int8 varName5;
int16 varName6;
int32 varName7;
int64 varName8;

// You can also define them like this if you like:
int varName9 = 34;

// Here is how if, else if and else will work and look like
if (varName1 == varName9) {
	print("varName1 is = to varName9");
}
else if (varName1 != varName9 or varName1 <= varName9) {
	print("varName1 is less or equal to varName9");
} else {
	print("varName1 is NOT less or equal to varName9 or someting else");
}

// Preview is still in development.
// Preview is still in development.
`;
        
        // Assuming variables.theSHA is already set
        const shaKey = "HTVM-IDE-5b4d8a2e372f41d0140299e6b38c7eb35dd63477fd72432fe23b4de0d342ea5b";

        // Retrieve the plain text from local storage
        variables.idetext = localStorage.getItem(shaKey) || variables.ideTEXT;
        variables.AScreenHeight = BuildInVars("A_ScreenHeight") - 20;
        variables.AScreenWidth = BuildInVars("A_ScreenWidth") - 20;
        var saveBackCodeBugFix = variables.ideTEXT;
        AddIDE(Gui1, 10, 10, variables.AScreenWidth, variables.AScreenHeight, "Gui1IDE1", 18, "autohotkey", IDE1, variables.ideTEXT);

        async function IDE1(A_GuiControl) {
          variables.idetext = A_GuiControl;
          localStorage.setItem(shaKey, variables.idetext); // Update storage with the new content
        }
        async function HotKeyCalledAltShiftCtrlF() {
          // console.log("HotKeyCalled AltShiftCtrlF")
          textOldSave = variables.idetext;
          variables.TextData = "";
          variables.out = "";
          variables.base64ImageData = "";
          variables.base64soundList = "";
          variables.base64iconList = "";
          variables.base64VideoData = "";
          variables.jsCode01CanvasW = "";
          variables.jsCode01CanvasH = "";
          variables.skipLeftCuleyForFuncPLS = 0;
          variables.eavbnsalvbaslv = 0;
          variables.ifWeUseCanvas = 0;
          variables.weUseCnanvasAtALL = 0;
          variables.numOfTextData = 0;
          variables.funcs = "let funcs = {\n";
          variables.doWeEvenDecAnyFuncHUH = 0;
          variables.onKeyPress = "";
          variables.jsCodeGui = "";
          variables.isFullScrenOnce = 0;
          variables.HotKeyCalledHotKyes = "";
          variables.jsCode = "";
          variables.outAHKCodeTrimed = "";
          variables.idetext = await StrReplace(variables.idetext, await Chr(13), "");
          var items1 = LoopParseFunc(variables.idetext, "\n", "\r");
          for (/* Loop Parse */ let A_Index1 = 1; A_Index1 <= items1.length; A_Index1++) {
            variables.A_Index1 = A_Index1;
            variables.A_LoopField1 = items1[A_Index1 - 1];
            variables.outAHKCodeTrimed += (await Trim(variables.A_LoopField1)) + "\n";
          }
          variables.idetext = StringTrimRight(variables.outAHKCodeTrimed, 1);
          variables.AHKcodeOUT754754 = "";
          variables.areWEinSome34sNum = 0;
          variables.theIdNumOfThe34 = 0;
          var items2 = LoopParseFunc(variables.idetext);
          for (/* Loop Parse */ let A_Index2 = 1; A_Index2 <= items2.length; A_Index2++) {
            variables.A_Index2 = A_Index2;
            variables.A_LoopField2 = items2[A_Index2 - 1];
            variables["theIdNumOfThe34theVar" + variables.A_Index2] = await Chr(34);
          }
          var items3 = LoopParseFunc(variables.idetext);
          for (/* Loop Parse */ let A_Index3 = 1; A_Index3 <= items3.length; A_Index3++) {
            variables.A_Index3 = A_Index3;
            variables.A_LoopField3 = items3[A_Index3 - 1];
            if (variables.A_LoopField3 == (await Chr(34))) {
              variables.areWEinSome34sNum += 1;
            }
            if (variables.areWEinSome34sNum == 1) {
              if (variables.A_LoopField3 != (await Chr(34))) {
                variables["theIdNumOfThe34theVar" + variables.theIdNumOfThe34] += variables.A_LoopField3;
              } else {
                variables.theIdNumOfThe34 += 1;
                variables.AHKcodeOUT754754 += "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" + (await Chr(65)) + (await Chr(65)) + (await str(variables.theIdNumOfThe34)) + (await Chr(65)) + (await Chr(65));
              }
            }
            if (variables.areWEinSome34sNum == 2 || variables.areWEinSome34sNum == 0) {
              if (variables.A_LoopField3 != (await Chr(34))) {
                variables.AHKcodeOUT754754 += variables.A_LoopField3;
              }
              variables.areWEinSome34sNum = 0;
            }
          }
          variables.idetext = variables.AHKcodeOUT754754;
          for (/* Normal Loop */ variables.A_Index4 = 1; variables.A_Index4 <= variables.theIdNumOfThe34; variables.A_Index4++) {
            variables["theIdNumOfThe34theVar" + variables.A_Index4] += await Chr(34);
          }
          variables.sstr23IfFuncInNAMEnum = 0;
          variables.outCodeFixBraces = "";
          for (/* Normal Loop */ variables.A_Index5 = 1; variables.A_Index5 <= 2; variables.A_Index5++) {
            variables.outCodeFixBraces = "";
            var items6 = LoopParseFunc(variables.idetext, "\n", "\r");
            for (/* Loop Parse */ let A_Index6 = 1; A_Index6 <= items6.length; A_Index6++) {
              variables.A_Index6 = A_Index6;
              variables.A_LoopField6 = items6[A_Index6 - 1];
              if ((await InStr(await Trim(variables.A_LoopField6), "{")) && (await Trim(variables.A_LoopField6)) != "{") {
                variables.outCodeFixBraces += (await Trim(await StrReplace(await Trim(variables.A_LoopField6), "{", ""))) + "\n{\n";
              } else if ((await InStr(await Trim(variables.A_LoopField6), "}")) && (await Trim(variables.A_LoopField6)) != "}") {
                variables.outCodeFixBraces += "}\n" + (await Trim(await StrReplace(await Trim(variables.A_LoopField6), "}", ""))) + "\n";
              } else {
                variables.outCodeFixBraces += (await Trim(variables.A_LoopField6)) + "\n";
              }
            }
            variables.idetext = StringTrimRight(variables.outCodeFixBraces, 1);
          }
          variables.idetext = await KandRstyleFormat(await indent_nested_curly_braces(variables.idetext));
          for (/* Normal Loop */ variables.A_Index7 = 1; variables.A_Index7 <= variables.theIdNumOfThe34; variables.A_Index7++) {
            variables.idetext = await StrReplace(variables.idetext, "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" + (await Chr(65)) + (await Chr(65)) + (await str(variables.A_Index7)) + (await Chr(65)) + (await Chr(65)), variables["theIdNumOfThe34theVar" + variables.A_Index7]);
          }
          GuiControl("textide", "Gui1IDE1", variables.idetext);
        }
        async function KandRstyleFormat(code) {
          variables.code = code;
          variables.codeOut = "";
          var items8 = LoopParseFunc(variables.code, "\n", "\r");
          for (/* Loop Parse */ let A_Index8 = 1; A_Index8 <= items8.length; A_Index8++) {
            variables.A_Index8 = A_Index8;
            variables.A_LoopField8 = items8[A_Index8 - 1];
            variables["lookInTheFurtre" + variables.A_Index8] = await Trim(variables.A_LoopField8);
          }
          variables["lookInTheFurtre" + variables.A_Index] = " ";
          variables.skipLine = 0;
          var items9 = LoopParseFunc(variables.code, "\n", "\r");
          for (/* Loop Parse */ let A_Index9 = 1; A_Index9 <= items9.length; A_Index9++) {
            variables.A_Index9 = A_Index9;
            variables.A_LoopField9 = items9[A_Index9 - 1];
            variables.AIndex = variables.A_Index9 + 1;
            if (variables.skipLine == 1) {
              variables.skipLine = 0;
            } else {
              if (variables["lookInTheFurtre" + variables.AIndex] != "{") {
                variables.codeOut += variables.A_LoopField9 + "\n";
              }
            }
            if (variables["lookInTheFurtre" + variables.AIndex] == "{") {
              variables.skipLine = 1;
              variables.codeOut += variables.A_LoopField9 + " {\n";
            }
          }
          variables.codeOut = StringTrimRight(variables.codeOut, 1);
          variables.codeOut2 = "";
          var items10 = LoopParseFunc(variables.codeOut, "\n", "\r");
          for (/* Loop Parse */ let A_Index10 = 1; A_Index10 <= items10.length; A_Index10++) {
            variables.A_Index10 = A_Index10;
            variables.A_LoopField10 = items10[A_Index10 - 1];
            variables["lookInTheFurtre" + variables.A_Index10] = await Trim(variables.A_LoopField10);
          }
          variables["lookInTheFurtre" + variables.A_Index] = " ";
          variables.skipLine = 0;
          var items11 = LoopParseFunc(variables.codeOut, "\n", "\r");
          for (/* Loop Parse */ let A_Index11 = 1; A_Index11 <= items11.length; A_Index11++) {
            variables.A_Index11 = A_Index11;
            variables.A_LoopField11 = items11[A_Index11 - 1];
            variables.AIndex = variables.A_Index11 + 1;
            if (variables.skipLine == 1) {
              variables.skipLine = 0;
            } else {
              if (variables["lookInTheFurtre" + variables.AIndex] != "else {") {
                variables.codeOut2 += variables.A_LoopField11 + "\n";
              }
            }
            if (variables["lookInTheFurtre" + variables.AIndex] == "else {") {
              variables.skipLine = 1;
              variables.scoaceses = "";
              var items12 = LoopParseFunc(variables.A_LoopField11);
              for (/* Loop Parse */ let A_Index12 = 1; A_Index12 <= items12.length; A_Index12++) {
                variables.A_Index12 = A_Index12;
                variables.A_LoopField12 = items12[A_Index12 - 1];
                if (variables.A_LoopField12 != " ") {
                  break;
                } else {
                  variables.scoaceses += " ";
                }
              }
              variables.codeOut2 += variables.scoaceses + "} else" + " {\n";
            }
          }
          variables.codeOut = StringTrimRight(variables.codeOut2, 1);
          return variables.codeOut;
        }
        async function RepeatSpaces(count) {
          variables.count = count;
          variables.spaces = "";
          for (/* Normal Loop */ variables.A_Index10 = 1; variables.A_Index10 <= variables.count; variables.A_Index10++) {
            variables.spaces += " ";
          }
          return variables.spaces;
        }
        async function indent_nested_curly_braces(input_string) {
          variables.input_string = input_string;
          variables.indent_size = 4;
          variables.current_indent = 0;
          variables.result = "";
          var items11 = variables.input_string.split(/\r?\n|\r/);
          for (/* Loop Parse */ let A_Index11 = 1; A_Index11 <= items11.length; A_Index11++) {
            variables.A_Index11 = A_Index11;
            variables.A_LoopField11 = items11[A_Index11 - 1];
            variables.trimmed_line = await Trim(variables.A_LoopField11);
            if (variables.trimmed_line == (await Chr(123))) {
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
              variables.current_indent = variables.current_indent + variables.indent_size;
            } else if (variables.trimmed_line == (await Chr(125))) {
              variables.current_indent = variables.current_indent - variables.indent_size;
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
            } else {
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
            }
          }
          variables.result = StringTrimRight(variables.result, 1);
          // Return the result
          return variables.result;
        }
      }

      // Call the async function to start the script
      runScript();
        </script>
  </body>
</html>