
___js start
let allKeyWordsIn = ""; // Global variable to store the result
let HTVM_Syntax_AutoComplete = []; // Global array for autocomplete
let allKeyWordsOut = "";
let allFunctionNamesString = ""; // Global string to store function names

async function getFunctionNames() {
    const url = 'https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt';
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        
        // Split text by line and get lines starting from line 162
        const lines = text.split('\n').slice(161); // Line 162 starts at index 161
        
        // Extract function names that start with "name: "
        const functionNames = lines
            .map(line => line.trim()) // Trim each line
            .filter(line => line.startsWith("name: ")) // Only lines that start with "name: "
            .map(line => line.replace("name: ", "").trim()) // Get function name (remove "name: " part)
            .filter((value, index, self) => self.indexOf(value) === index); // Remove duplicates
        
        // Save the function names in the global variable
        allFunctionNamesString = functionNames.join('\n');
        
    } catch (error) {
        console.error('Error fetching the text file:', error);
    }
}


// Function to fetch the first 149 lines from a remote text file
async function fetchFirst149Lines(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        return text.split('\n').slice(0, 149).join('\n');
    } catch (error) {
        console.error('Error fetching the text file:', error);
        return null;
    }
}

// Main function to handle localStorage and data retrieval
async function getAllKeyWordsIn() {
    const id = new URLSearchParams(window.location.search).get('id');
    if (!id) {
        console.error('No ID found in the URL');
        return;
    }

    let data = localStorage.getItem("htvm_lang_" + id);
    
    if (data) {
        try {
            const arrayData = JSON.parse(data);
            if (Array.isArray(arrayData)) {
                allKeyWordsIn = arrayData.slice(0, 149).join('\n'); // Save in global variable
                return;
            } else {
                console.error('Stored data is not an array');
                return;
            }
        } catch (error) {
            console.error('Error parsing JSON from localStorage:', error);
            return;
        }
    }

    // If key doesn't exist, fetch data from the remote file
    const url = 'https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt';
    const fetchedData = await fetchFirst149Lines(url);

    if (fetchedData) {
        localStorage.setItem("htvm_lang_" + id, JSON.stringify(fetchedData.split('\n'))); // Store in localStorage
        allKeyWordsIn = fetchedData; // Save in global variable
    } else {
        console.error('Failed to fetch data from the remote file');
    }
}

___js end





async func str getAllKeyWords()
{
await getAllKeyWordsIn()
await getFunctionNames()


str allKeyWordsIn_OUT := ""
str allKeyWordsIn_OUT_TEMP := ""

Loop, Parse, allKeyWordsIn, `n, `r
{
if (A_Index != 0) and (A_Index != 1)
{

if (A_Index = 2)
{
Loop, Parse, A_LoopField, "|"
{
Loop, Parse, A_LoopField, `,
{
if (A_Index = 0)
{
allKeyWordsIn_OUT .= A_LoopField . "`n"
break
}
}
}
}
else
{
allKeyWordsIn_OUT_TEMP := A_LoopField
___js start
const isValidStart = /^[A-Za-z_]{2}/.test(allKeyWordsIn_OUT_TEMP);
___js end
if (isValidStart)
{
allKeyWordsIn_OUT .= A_LoopField . "`n"
}

}

}
}

allKeyWordsOut := allKeyWordsIn_OUT . allFunctionNamesString

}



___js start

(async function () {
    await getAllKeyWords();
    //console.log(allKeyWordsOut);
    
    // Convert to the required format
    HTVM_Syntax_AutoComplete = allKeyWordsOut.split('\n')
        .map(line => line.trim()) // Trim each line
        .filter(line => line.length > 0) // Remove empty lines
        .map(line => ({ name: line })); // Convert to object format
})();

let Completer = {
    getCompletions: function (editor, session, pos, prefix, callback) {
        // If the prefix starts with "p", we allow autocompletion.
        if (prefix.startsWith("p")) {
            // Proceed with filtering completions
        } else {
            // If the prefix length is not more than 1, we return early
            if (prefix.length <= 1) {
                callback(null, []); // Empty array means no suggestions
                return;
            }
        }

        let prefixLower = prefix.toLowerCase();
        let filteredTables = HTVM_Syntax_AutoComplete.filter(function (table) {
            return table.name.toLowerCase().startsWith(prefixLower);
        });

        let limitedTables = filteredTables;

        // Return the filtered and mapped completions
        callback(
            null,
            limitedTables.map(function (table) {
                return {
                    caption: table.name,
                    value: table.name,
                };
            })
        );
    }
};

___js end
