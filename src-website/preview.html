<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTVM IDE</title>
    <style>
      body {
        background-color: #202020;
        font-family:
          "Open Sans",
          -apple-system,
          BlinkMacSystemFont,
          "Segoe UI",
          Roboto,
          Oxygen-Sans,
          Ubuntu,
          Cantarell,
          "Helvetica Neue",
          Helvetica,
          Arial,
          sans-serif;
      }
      
    </style>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
      <!-- HTVM transpiler in js -->
      <script src="../HTVM.js"></script>
    <!-- Include Ace Editor CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.2/ace.js" integrity="sha512-JLIRlxWh96sND3uUgI2RVHZJpgkWHg3+xoUY8XkgTPKpqRaqdk7zD/ck/XHXFSMW84o6GrP67dlqN3b98NB/yA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-language_tools.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  </head>
  <body>
    </div>
    <script>
       

      function changeFaviconAtTheBeginning(faviconUrl) {
        // Create a new favicon link element
        const newFavicon = document.createElement("link");
        newFavicon.rel = "icon";
        newFavicon.href = faviconUrl;

        // Get the current favicon element (if exists)
        const existingFavicon = document.querySelector('link[rel="icon"]');

        // Replace the current favicon with the new one
        if (existingFavicon) {
          // If a favicon exists, replace it
          document.head.removeChild(existingFavicon); // Remove the existing favicon
        }

        // Append the new favicon to the head
        document.head.appendChild(newFavicon);
      }

      // Call the function with the desired favicon URL
      changeFaviconAtTheBeginning("https://i.ibb.co/Jpty1B8/305182938-1a0efe63-726e-49ca-a13c-d0ed627f2ea7.png");

      function showCustomMessageBox(options, title, text, value, timeout) {
        return new Promise((resolve) => {
          // Define default options for the message box
          let defaultOptions = {
            title: title || "", // Default title is empty
            text: text || "Press OK to continue.", // Default text if not provided
            showCancelButton: false, // Default is to not show Cancel button
            showDenyButton: false, // Default is to not show Deny button
            confirmButtonText: "OK", // Default text for OK button
            focusConfirm: true, // Default focus on OK button
          };

          let numOriginal = value;

          let num = numOriginal;

          let done1 = 0;

          let done2 = 0;

          let done3 = 0;

          let AIndex = 0;

          for (AIndex = 1; AIndex <= 1; AIndex++) {
            // this is about if you add always on top in a msgbox it will be removed in js cuz its kinda useless...
            // becouse if you like adding always on top in ahk in js we dont realy do it so yeah
            if (num >= 262144) {
              num = num - 262144;
              numOriginal = numOriginal - 262144;
            }

            if (num >= 256 && num < 500) {
              num = num - 256;

              done3 = 256;
            }

            if (num >= 512) {
              num = num - 512;

              done3 = 512;
            }

            if (num == 0) {
              done1 = 0;

              break;
            }

            if (num <= 6) {
              done1 = num;

              break;
            }

            if (num >= 64 && num < 64 * 2) {
              done2 = 64;

              if (num == 64) {
                done1 = 0;

                break;
              } else {
                done1 = num - 64;

                break;
              }
            }

            if (num >= 48 && num < 63) {
              done2 = 48;

              if (num == 48) {
                done1 = 0;

                break;
              } else {
                done1 = num - 48;

                break;
              }
            }

            if (num >= 32 && num < 47) {
              done2 = 32;

              if (num == 32) {
                done1 = 0;

                break;
              } else {
                done1 = num - 32;

                break;
              }
            }

            if (num >= 16 && num < 30) {
              done2 = 16;

              if (num == 16) {
                done1 = 0;

                break;
              } else {
                done1 = num - 16;

                break;
              }
            }
          }

          let doneAdded = done1 + done2 + done3;

          if (doneAdded !== numOriginal) {
            // displayMessage("The calc was wrong!");
          } else {
            // displayMessage("num was: " + numOriginal + "\ndone1: " + done1 + "\ndone2: " + done2 + "\ndone3: " + done3);
          }

          // Parse the value to determine the options for the message box
          if (done1 === 1) defaultOptions.showCancelButton = true; // OK/Cancel in ahk but here it will show Ok/Cancel wiat its same haha

          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 2) {
          //     defaultOptions.showCancelButton = true; // Abort/Retry/Ignore
          //     defaultOptions.showDenyButton = true;
          //   }
          if (done1 === 3) {
            defaultOptions.showCancelButton = true; // Yes/No/Cancel in ahk but here it will show Ok/No/Cancel
            defaultOptions.showDenyButton = true;
          }
          if (done1 === 4) {
            // defaultOptions.showCancelButton = true;
            defaultOptions.showDenyButton = true; // Yes/No in ahk but here it will show Ok/No
          }
          if (done1 === 5) {
            defaultOptions.showCancelButton = true; // Retry/Cancel in ahk but here it will show Ok/Cancel tip you can write in the Msgbox press ok to retry
          }
          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 6) {
          //     defaultOptions.showCancelButton = true; // Cancel/Try Again/Continue
          //     defaultOptions.showDenyButton = true;
          //   }

          if (done2 === 16) defaultOptions.icon = "error"; // Icon Hand (stop/error)
          if (done2 === 32) defaultOptions.icon = "question"; // Icon Question
          if (done2 === 48) defaultOptions.icon = "warning"; // Icon Exclamation
          if (done2 === 64) defaultOptions.icon = "info"; // Icon Asterisk (info)

          if (done3 === 256) defaultOptions.focusDeny = true; // Makes the 3rd button the default
          if (done3 === 512) defaultOptions.focusCancel = true; // Makes the 2nd button the default

          // Set timeout if provided
          if (timeout) {
            defaultOptions.timer = timeout * 1000; // Convert timeout to milliseconds
          }

          // Merge default options with provided options
          Object.assign(defaultOptions, options);

          // Display the message box with the constructed options
          Swal.fire(defaultOptions).then((result) => {
            if (result.isConfirmed) {
              resolve("OK");
            } else if (result.isDenied) {
              resolve("No");
            } else {
              resolve("Cancel");
            }
          });
        });
      }

      var lastKeyPressed = "";

      function trackLastKeyPressed() {
        document.addEventListener("keydown", function (event) {
          lastKeyPressed = event.key;
          // console.log(lastKeyPressed);
        });
      }

      function getLastKeyPressed() {
        return lastKeyPressed;
      }

      // Call the trackLastKeyPressed function to start tracking key presses
      trackLastKeyPressed();

      let lastInputTime = Date.now(); // Initialize with current timestamp
      let startTimestamp = Date.now(); // Initialize with current timestamp

      // Event listener to track user activity
      function resetIdleTimer() {
        lastInputTime = Date.now(); // Update last input time
      }

      document.addEventListener("mousemove", resetIdleTimer);
      document.addEventListener("keypress", resetIdleTimer);

      // Function to calculate time since last input event
      function A_TimeIdle() {
        return Date.now() - lastInputTime; // Calculate time difference
      }

      // Function to calculate tick count in milliseconds
      function A_TickCount() {
        return Date.now() - startTimestamp;
      }

      function GuiControl(action, id, param1, param2, param3, param4) {
        const element = document.getElementById(id);
        if (element) {
          // Handle DOM elements
          if (action === "move") {
            // Set position and size
            element.style.left = param1 + "px";
            element.style.top = param2 + "px";
            element.style.width = param3 + "px";
            element.style.height = param4 + "px";
          } else if (action === "focus" && (element instanceof HTMLInputElement || element instanceof HTMLElement)) {
            // Focus on the element
            element.focus();
          } else if (action === "text") {
            // Set new text content
            element.textContent = param1;
          } else if (action === "hide") {
            // Hide the element
            element.style.display = "none";
          } else if (action === "show") {
            // Show the element
            element.style.display = "";
          } else if (action === "enable") {
            // Enable the element
            element.disabled = false;
          } else if (action === "disable") {
            // Disable the element
            element.disabled = true;
          } else if (action === "font") {
            // Set font size
            element.style.fontSize = param1 + "px";
          } else if (action === "destroy") {
            // Remove the element from the DOM
            element.parentNode.removeChild(element);
          } else if (action === "color") {
            // Set color
            element.style.color = param1;
          } else if (action === "picture") {
            // Change the image source
            if (element instanceof HTMLImageElement) {
              element.src = param1;
            } else {
              console.error("Element is not an <img> tag, cannot change picture.");
            }
          } else if (action === "textide") {
            // Set value for Ace editor
            var editor = ace.edit(id); // Access the Ace editor instance using its ID
            if (editor && param1) {
              editor.session.setValue(param1);
            } else {
              console.error("Element is not an Ace editor or parameter is missing.");
            }
          }
        } else {
          // Handle canvas or non-existing element
          if (action === "move") {
            // Update position and size of the rectangle
            updateRectangle(id, param1, param2, param3, param4);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          } else if (action === "color") {
            // Update color of the rectangle
            updateRectangleColor(id, param1);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          }
        }
      }

      function BuildInVars(varName) {
        switch (varName) {
          case "A_ScreenWidth":
            // Return screen width
            return window.innerWidth;
          case "A_LastKey":
            // Return screen width
            return getLastKeyPressed();
          case "A_ScreenHeight":
            // Return screen height
            return window.innerHeight;
          case "A_TimeIdle":
            // Return time idle
            return A_TimeIdle();
          case "A_TickCount":
            // Return tick count in milliseconds
            return A_TickCount();
          case "A_Now":
            // Return current local timestamp
            return new Date().toLocaleString();
          case "A_YYYY":
            // Return current year
            return new Date().getFullYear();
          case "A_MM":
            // Return current month
            return (new Date().getMonth() + 1).toString().padStart(2, "0");
          case "A_DD":
            // Return current day
            return new Date().getDate().toString().padStart(2, "0");
          case "A_MMMM":
            // Return full month name
            return new Date().toLocaleDateString(undefined, { month: "long" });
          case "A_MMM":
            // Return short month name
            return new Date().toLocaleDateString(undefined, { month: "short" });
          case "A_DDDD":
            // Return full day name
            return new Date().toLocaleDateString(undefined, { weekday: "long" });
          case "A_DDD":
            // Return short day name
            return new Date().toLocaleDateString(undefined, { weekday: "short" });
          case "A_Hour":
            // Return current hour
            return new Date().getHours().toString().padStart(2, "0");
          case "A_Min":
            // Return current minute
            return new Date().getMinutes().toString().padStart(2, "0");
          case "A_Sec":
            // Return current second
            return new Date().getSeconds().toString().padStart(2, "0");
          case "A_Space":
            // Return space character
            return " ";
          case "A_Tab":
            // Return tab character
            return "\t";

          default:
            // Handle unknown variable names
            return null;
        }
      }

      function Chr(number) {
        // Check if the number is null
        if (number === null) {
          // Return an empty string
          return "";
        }

        // Check if the number is within the valid range
        if (number >= 0 && number <= 0x10ffff) {
          // Convert the number to a character using String.fromCharCode
          return String.fromCharCode(number);
        } else {
          // Return an empty string for invalid numbers
          return "";
        }
      }
      let allKeyWordsIn = ""; // Global variable to store the result
let allKeyWordsOut = "";
let allFunctionNamesString = ""; // Global string to store function names
async function getFunctionNames() {
    const url = 'https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt';
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        
        // Split text by line and get lines starting from line 162
        const lines = text.split('\n').slice(162); // Line 162 starts at index 161
        
        // Extract function names that start with "name: "
        const functionNames = lines
            .map(line => line.trim()) // Trim each line
            .filter(line => line.startsWith("name: ")) // Only lines that start with "name: "
            .map(line => line.replace("name: ", "").trim()) // Get function name (remove "name: " part)
            .filter((value, index, self) => self.indexOf(value) === index); // Remove duplicates
        
        // Save the function names in the global variable
        allFunctionNamesString = functionNames.join('\n');
        
    } catch (error) {
        console.error('Error fetching the text file:', error);
    }
}
// Function to fetch the first 161 lines from a remote text file
async function fetchFirst161Lines(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        return text.split('\n').slice(0, 162).join('\n');
    } catch (error) {
        console.error('Error fetching the text file:', error);
        return null;
    }
}
// Main function to handle localStorage and data retrieval
async function getAllKeyWordsIn() {
    const id = new URLSearchParams(window.location.search).get('id');
    if (!id) {
        console.error('No ID found in the URL');
        return;
    }
    const storageKey = "htvm_lang_" + id;
    let storedData = localStorage.getItem(storageKey);
    
    // If the key exists, use localStorage data and return
    if (storedData !== null) {
        try {
            const arrayData = JSON.parse(storedData);
            if (Array.isArray(arrayData)) {
                allKeyWordsIn = arrayData.slice(0, 162).join('\n'); // Save in global variable
                return;
            } else {
                console.error('Stored data is not an array');
                return;
            }
        } catch (error) {
            console.error('Error parsing JSON from localStorage:', error);
            return;
        }
    }
    else
    {
        // If key is missing, fetch data from the remote file
    const url = 'https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt';
    const fetchedData = await fetchFirst161Lines(url);
    if (fetchedData) 
    {
        localStorage.setItem(storageKey, JSON.stringify(fetchedData.split('\n'))); // Store in localStorage
        allKeyWordsIn = fetchedData; // Save in global variable
    } 
    else
    {
        console.error('Failed to fetch data from the remote file');
    } 
    }
}
function fixSomeBugUGH() {
    var var123Out = "";
    const id = new URLSearchParams(window.location.search).get('id');
if (!id) {
    console.error('No ID found in the URL');
    return;
}
const storageKey = "htvm_lang_" + id;
let storedData = localStorage.getItem(storageKey);
// If the key exists, use localStorage data and return
if (storedData !== null) {
    allKeyWordsIn = JSON.parse(storedData);
    // Convert the array into a string (each index becomes a new line)
    allKeyWordsIn = allKeyWordsIn.join('\n'); // This turns the array into a string with each element on a new line
    // Now you can use the allKeyWordsIn string here for further processing
    //console.log(allKeyWordsIn);  // Example of using the resulting string
} else {
    console.error('No data found in localStorage for the given key');
}
    var allKeyWordsIn_OUT = "";
    var allKeyWordsIn_OUT_TEMP = "";
    items1 = LoopParseFunc(allKeyWordsIn, "\n", "\r")
    for (let A_Index1 = 0; A_Index1 < items1.length + 0; A_Index1++) {
        const A_LoopField1 = items1[A_Index1 - 0];
        if (A_Index1 != 0 && A_Index1 != 1) {
            allKeyWordsIn_OUT += A_LoopField1 + "\n";
        }
    }
    allKeyWordsIn_OUT = StringTrimRight(allKeyWordsIn_OUT, 1);
    var123Out = allKeyWordsIn_OUT;
    return var123Out;
}
async function getAllKeyWords() {
    await getAllKeyWordsIn();
    await getFunctionNames();
    const id = new URLSearchParams(window.location.search).get('id');
if (!id) {
    console.error('No ID found in the URL');
    return;
}
const storageKey = "htvm_lang_" + id;
let storedData = localStorage.getItem(storageKey);
// If the key exists, use localStorage data and return
if (storedData !== null) {
    allKeyWordsIn = JSON.parse(storedData);
    // Convert the array into a string (each index becomes a new line)
    allKeyWordsIn = allKeyWordsIn.join('\n'); // This turns the array into a string with each element on a new line
    // Now you can use the allKeyWordsIn string here for further processing
    //console.log(allKeyWordsIn);  // Example of using the resulting string
} else {
    console.error('No data found in localStorage for the given key');
}
    var allKeyWordsIn_OUT = "";
    var allKeyWordsIn_OUT_TEMP = "";
    items2 = LoopParseFunc(allKeyWordsIn, "\n", "\r")
    for (let A_Index2 = 0; A_Index2 < items2.length + 0; A_Index2++) {
        const A_LoopField2 = items2[A_Index2 - 0];
        if (A_Index2 != 0 && A_Index2 != 1) {
            allKeyWordsIn_OUT += A_LoopField2 + "\n";
        }
    }
    allKeyWordsIn_OUT = StringTrimRight(allKeyWordsIn_OUT, 1);
    allKeyWordsOut = allKeyWordsIn_OUT;
}
let allFunctionNamesString2 = "";
(async function () {
    await getAllKeyWords();
    //console.log(allKeyWordsOut);
allFunctionNamesString2 = Trim(StrReplace(allFunctionNamesString, Chr(10), "|"));
//print("=============================")
//print(allFunctionNamesString2)
//print("=============================")
// Get the URL parameter 'id'
const urlParams = new URLSearchParams(window.location.search);
const id = urlParams.get('id');
// Check if 'id' is present in the URL
if (id) {
    // Create the key for localStorage
    const storageKey = `htvm_lang_${id}_allFunctionNamesString`;
    const storageKey2 = `htvm_lang_${id}_allKeyWordsOut`;
    // Save 'allFunctionNamesString2' to localStorage
    localStorage.setItem(storageKey, allFunctionNamesString2);
    localStorage.setItem(storageKey2, allKeyWordsOut);
} else {
    console.error('URL parameter "id" is missing.');
}
})();

      // Define the custom "ht" language for Ace Editor with AHK rules
      ace.define("ace/mode/ht", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/text_highlight_rules"], function (require, exports, module) {
    var oop = require("ace/lib/oop");
    var TextMode = require("ace/mode/text").Mode;
    var TextHighlightRules = require("ace/mode/text_highlight_rules").TextHighlightRules;
    var HTVMHighlightRules = function() {
        
        //console.log(new URLSearchParams(window.location.search).get('id'));
let allFunctionNamesString3 = "";
let allKeyWordsOut3 = "";
// Get the URL parameter 'id'
const urlParams = new URLSearchParams(window.location.search);
const id = urlParams.get('id');
// Check if 'id' is present in the URL
if (id) {
    // Create the key for localStorage
    const storageKey = `htvm_lang_${id}_allFunctionNamesString`;
    const storageKey2 = `htvm_lang_${id}_allKeyWordsOut`;
    // Retrieve 'allFunctionNamesString' from localStorage
    allFunctionNamesString3 = localStorage.getItem(storageKey);
    if (localStorage.getItem("htvm_lang_" + id))
    {
        allKeyWordsOut3 = fixSomeBugUGH();
    }
    else
    {
        allKeyWordsOut3 = localStorage.getItem(storageKey2);    
    }
} else {
    console.error('URL parameter "id" is missing.');
}
var builtInCommands_temp = "";
var htvmKeywords_temp = "";
var staticTypes_temp = "";
var builtInVars_temp = "";
var operators_temp = "";
var arrayMethods_temp = "";
var programmingBlocksAndImport_temp = "";
var htvm_trueFalseGlobalNull_temp = "";
var htvm_comment_temp = "";
var htvm_commentOpen1_temp = "";
var htvm_commentClose2_temp = "";
items3 = LoopParseFunc(allKeyWordsOut3, "\n", "\r")
for (let A_Index3 = 0; A_Index3 < items3.length + 0; A_Index3++) {
    const A_LoopField3 = items3[A_Index3 - 0];
    if (Trim(A_LoopField3) != "") {
        if (A_Index3 == 0) {
            items4 = LoopParseFunc(A_LoopField3, "|")
            for (let A_Index4 = 0; A_Index4 < items4.length + 0; A_Index4++) {
                const A_LoopField4 = items4[A_Index4 - 0];
                items5 = LoopParseFunc(A_LoopField4, ",");
                for (let A_Index5 = 0; A_Index5 < items5.length + 0; A_Index5++) {
                    const A_LoopField5 = items5[A_Index5 - 0];
                    builtInCommands_temp += Trim(A_LoopField5) + "|";
                }
            }
        }
        if (A_Index3 == 1 || A_Index3 == 2 || A_Index3 == 3 || A_Index3 == 4 || A_Index3 == 5 || A_Index3 == 64 || A_Index3 == 65 || A_Index3 == 66 || A_Index3 == 67 || A_Index3 == 68 || A_Index3 == 69 || A_Index3 == 70 || A_Index3 == 71 || A_Index3 == 72 || A_Index3 == 73 || A_Index3 == 74 || A_Index3 == 75 || A_Index3 == 76 || A_Index3 == 78 || A_Index3 == 79 || A_Index3 == 80 || A_Index3 == 81 || A_Index3 == 93 || A_Index3 == 94 || A_Index3 == 95 || A_Index3 == 96) {
            htvmKeywords_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 77) {
            allFunctionNamesString3 += "|" + Trim(A_LoopField3);
        }
        if (A_Index3 >= 49 && A_Index3 <= 63) {
            staticTypes_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 88 && A_Index3 <= 92) {
            staticTypes_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 145 || A_Index3 == 146 || A_Index3 == 6) {
            builtInVars_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 103 && A_Index3 <= 126) {
            operators_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 140 && A_Index3 <= 141) {
            operators_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 82 && A_Index3 <= 87) {
            arrayMethods_temp += Trim(StrReplace(A_LoopField3, ".", "")) + "|";
        }
        if (A_Index3 >= 7 && A_Index3 <= 43) {
            programmingBlocksAndImport_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 98) {
            htvm_comment_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 99) {
            htvm_commentOpen1_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 100) {
            htvm_commentClose2_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 46 || A_Index3 == 47 || A_Index3 == 48 || A_Index3 == 97) {
            htvm_trueFalseGlobalNull_temp += A_LoopField3 + "|";
        }
    }
}
builtInCommands_temp = StringTrimRight(builtInCommands_temp, 1);
htvmKeywords_temp = StringTrimRight(htvmKeywords_temp, 1);
staticTypes_temp = StringTrimRight(staticTypes_temp, 1);
builtInVars_temp = StringTrimRight(builtInVars_temp, 1);
operators_temp = StringTrimRight(operators_temp, 1);
arrayMethods_temp = StringTrimRight(arrayMethods_temp, 1);
programmingBlocksAndImport_temp = StringTrimRight(programmingBlocksAndImport_temp, 1);
htvm_trueFalseGlobalNull_temp = StringTrimRight(htvm_trueFalseGlobalNull_temp, 1);
var htvmKeywords = htvmKeywords_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInCommands = builtInCommands_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInFunctions = allFunctionNamesString3.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var staticTypes = staticTypes_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInVars = builtInVars_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var arrayMethods = arrayMethods_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var programmingBlocksAndImport = programmingBlocksAndImport_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var htvm_trueFalseGlobalNull = htvm_trueFalseGlobalNull_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var htvm_operators = operators_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
        
        
        var htvm_comment = htvm_comment_temp;
        // Escape special characters in the comment symbol (just in case)
        var escapedComment = htvm_comment.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var htvm_commentOpen1 = htvm_commentOpen1_temp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var htvm_commentClose2 = htvm_commentClose2_temp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        this.$rules = {
            start: [
                { token: "comment", regex: escapedComment + ".*$" },
                { token: "comment.block", regex: new RegExp(htvm_commentOpen1), next: "comment_block" },
                { token: "keyword", regex: "\\b(?:" + htvmKeywords + ")\\b" },
                { token: "command", regex: "\\b(?:" + builtInCommands + ")(?=\\,)" },
                { token: "functions", regex: "\\b(?:" + builtInFunctions + ")(?=\\()" },
                { token: "BuildInFunc", regex: "\\b(?:" + builtInVars + ")\\b" },
                { token: "arrayMethods", regex: "\\.(?:" + arrayMethods + ")\\b" },
                { token: "static_types", regex: "\\b(?:" + staticTypes + ")\\b" },
                { token: "programmingBlocksAndImport", regex: "\\b(?:" + programmingBlocksAndImport + ")\\b" },
                { token: "operators", regex: "\\b(?:" + htvm_operators + ")\\b" },
                { token: "trueANDfalse", regex: "\\b(?:" + htvm_trueFalseGlobalNull + ")\\b" },
                { token: "variables", regex: "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b" },
                { token: "constant.numeric", regex: "\\b[0-9]+\\b" },
                { token: "braces_Open", regex: "\\{" },
                { token: "braces_Close", regex: "\\}" },
              { token: "string", regex: '".*?"' },
              // Multi-line comments
              {
                token: "comment.block", // Token for multi-line comments
               regex: new RegExp(htvm_commentOpen1),
                next: "comment_block",
              },
            ],
            comment_block: [
              {
                token: "comment.block",
                regex: new RegExp(htvm_commentClose2),
                next: "start", // Go back to the start state
              },
              {
                token: "comment.block",
                regex: /.*/, // Any other content within the comment
              },
            ],
          };
        };
 oop.inherits(HTVMHighlightRules, TextHighlightRules);

        var HTMode = function () {
          this.HighlightRules = HTVMHighlightRules;
        };
        oop.inherits(HTMode, TextMode);

        exports.Mode = HTMode;
      });

      function AddIDE(parent, xPos, yPos, w, h, id, font = 18, langName = "autohotkey", onChangeFunc, initialText = "") {
        var langTools = ace.require("ace/ext/language_tools");

        let Completer = {
          getCompletions: function (editor, session, pos, prefix, callback) {
            if (prefix.startsWith("p")) {
              // Continue executing if the prefix starts with "p"
            } else {
              // Return early if the prefix does not start with "p" and its length is not greater than 1
              if (prefix.length <= 1) {
                callback(null, []); // Return an empty array of completions
                return;
              }
            }

            let prefixLower = prefix.toLowerCase();
            let filteredTables = hth.filter(function (table) {
              return table.name.toLowerCase().startsWith(prefixLower);
            });
            // filteredTables.sort(function(a, b) {
            //     return a.name.length - b.name.length;
            // });
            let limitedTables = filteredTables; //.slice(-10);

            callback(
              null,
              limitedTables.map(function (table) {
                return {
                  caption: table.name,
                  value: table.name,
                };
              }),
            );
          },
        };
        // Combined keywords for "ht"
        let hth = [{ name: "none" }]

        // Create a new div element for the editor
        var editorDiv = document.createElement("div");
        editorDiv.id = id;
        editorDiv.style.position = "absolute";
        editorDiv.style.left = xPos + "px";
        editorDiv.style.top = yPos + "px";
        editorDiv.style.width = w + "px";
        editorDiv.style.height = h + "px";
        editorDiv.style.fontSize = font + "px";

        // Append the editor div to the parent
        parent.appendChild(editorDiv);

        // Create a new editor instance inside the div
        var editor = ace.edit(id);
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/" + "ht");
        editor.setReadOnly(true);
        // editor.setOptions({
        //   enableBasicAutocompletion: true,
        //   enableLiveAutocompletion: true,
        //   behavioursEnabled: false, // Disable auto-pairing of characters
        // });

        editor.setOptions({
          enableBasicAutocompletion: false,
          enableSnippets: false,
          enableLiveAutocompletion: true,
          behavioursEnabled: false,
          showPrintMargin: false,
        });

        langTools.setCompleters([]);
        langTools.addCompleter(Completer);

        // Set initial text if provided
        if (initialText) {
          editor.setValue(initialText, -1); // -1 to move cursor to the beginning
        }



        // Apply CSS styles for the editor

var css = `
    .ace-monokai .ace_marker-layer .ace_active-line {
      background-color: #103010 !important;
    }
    
    .ace-monokai {
      background-color: #050505 !important;
      color: #f8f8f2;
    }
    
    .ace-monokai .ace_gutter {
      background: #204020 !important;
      color: #cbcdc3 !important;
    }
    
    .ace-monokai .ace_gutter-active-line {
      background-color: transparent !important;
    }
    
    .ace-monokai .ace_entity.ace_name.ace_tag,
    .ace-monokai .ace_keyword,
    .ace-monokai .ace_meta.ace_tag,
    .ace-monokai .ace_storage {
      color: #40a0e0 !important;
    }
    
    .ace-monokai .ace_entity.ace_name.ace_function,
    .ace-monokai .ace_entity.ace_other,
    .ace-monokai .ace_entity.ace_other.ace_attribute-name,
    .ace-monokai .ace_variable {
      color: #ff80df !important;
    }
    
    .ace-monokai .ace_comment {
      color: #40d080 !important;
      font-weight: line-through !important;
    }
    
    .ace-monokai .ace_commentOpen_Close {
      color: #40d080 !important;
      font-weight: line-through !important;
    }
    
    .ace-monokai .ace_variables {
      color: #ffffff !important;
    }
    
    .ace-monokai .ace_functions {
      color: #80dfff !important;
    }
    
    .ace-monokai .ace_keyword {
    color: #8080e0 !important; /* Customize color as needed */
    font-weight: bold !important;
    }
    .ace-monokai .ace_braces_Open {
      color: #FFFFff !important;
    }
    
    .ace-monokai .ace_braces_Close {
      color: #FFFFff !important;
    }
    
    .ace-monokai .ace_arrayMethods {
      color: #FAB820 !important;
    }
    
    .ace-monokai .ace_BuildInFunc {
      color: #ff80df !important;
    }
    
    .ace-monokai .ace_command {
      color: #40a0e0 !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_static_types {
      color: #569cd6 !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_string {
      color: #ffa0a0 !important;
      font-weight: lighter !important;
    }
    
    .ace-monokai .ace_operators {
      color: #00ffff !important;
      font-weight: lighter !important;
    }
    
    
    .ace-monokai .ace_trueANDfalse {
      color: #00ffff !important;
      font-weight: lighter !important;
    }
    
    .ace-monokai .ace_escape-char {
      color: #ff8000 !important;
      font-weight: bold !important;
    }

    .ace-monokai .ace_programmingBlocksAndImport {
      color: #F0401C !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_punctuation,
    .ace-monokai .ace_punctuation.ace _tag {
      color: #ffa0a0 !important;
    }
    
    *::-webkit-scrollbar {
      width: 1em;
    }
    
    *::-webkit-scrollbar-track {
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    }
    
    *::-webkit-scrollbar-thumb {
      background-color: darkgrey;
      outline: 1px solid slategrey;
    }
`;

        var style = document.createElement("style");
        style.type = "text/css";
        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(document.createTextNode(css));
        }
        document.head.appendChild(style);

        // Bind change event listener to the editor
        editor.getSession().on("change", function () {
          var code = editor.getValue();
          if (typeof onChangeFunc === "function") {
            onChangeFunc(code);
          }
        });
      }

      // Helper function to set the internal array's size as a string
      function setInternalArraySize(element, size) {
        if (typeof element === "string") {
          return size.toString();
        }
        return size;
      }

      // Convert string to int
      function INT(str) {
        return str;
      }

      // Convert various types to string
      function STR(value) {
        return value;
      }

      // Exponential
      function Exp(num) {
        if (num === null || isNaN(num)) return null;
        return Math.exp(num);
      }

      // Base-10 logarithm
      function Log(num) {
        if (num === null || isNaN(num)) return null;
        return Math.log10(num);
      }

      function Chr(number) {
        // Check if the number is null
        if (number === null) {
          // Return an empty string
          return "";
        }

        // Check if the number is within the valid range
        if (number >= 0 && number <= 0x10ffff) {
          // Convert the number to a character using String.fromCharCode
          return String.fromCharCode(number);
        } else {
          // Return an empty string for invalid numbers
          return "";
        }
      }

      // InStr
      function InStr(Haystack, Needle, CaseSensitive = true, StartingPos = 1, Occurrence = 1) {
        if (Haystack === null || Needle === null) return false;

        // Adjust starting position if less than 1
        StartingPos = Math.max(StartingPos, 1);

        // Case-sensitive search by default
        if (!CaseSensitive) {
          Haystack = Haystack.toLowerCase();
          Needle = Needle.toLowerCase();
        }

        let pos = -1;
        let count = 0;
        for (let i = StartingPos - 1; i < Haystack.length; i++) {
          if (Haystack.substring(i, i + Needle.length) === Needle) {
            count++;
            if (count === Occurrence) {
              pos = i + 1;
              break;
            }
          }
        }

        return pos > 0; // Return true if the substring is found, false otherwise
      }

      // RegExMatch
      function RegExMatch(Haystack, NeedleRegEx, OutputVar, StartingPos) {
        if (Haystack === null || NeedleRegEx === null) return null;

        const regex = new RegExp(NeedleRegEx);
        let match;

        if (typeof Haystack === "string") {
          match = Haystack.match(regex);
        }

        if (match) {
          if (OutputVar) {
            OutputVar.push(match[0]);
          }
          return match.index + 1;
        } else {
          return 0;
        }
      }

      // StrLen
      function StrLen(str) {
        if (typeof str !== "string") {
          console.error("Invalid input: expected a string but received:", str);
          return 0; // Return 0 or handle as needed
        }
        return str.length;
      }

      function SubStr(str, startPos, length) {
        // If str is null or undefined, return an empty string
        if (str === null || str === undefined) {
          return "";
        }

        // If length is not provided or is blank, default to "all characters"
        if (length === undefined || length === "") {
          length = str.length - startPos + 1;
        }

        // If startPos is less than 1, adjust it to start from the end of the string
        if (startPos < 1) {
          startPos = str.length + startPos;
        }

        // Extract the substring based on startPos and length
        return str.substr(startPos - 1, length);
      }

      function Trim(inputString) {
        // Check if inputString is null or undefined
        if (inputString == null) {
          return ""; // Return an empty string if inputString is null or undefined
        }
        return inputString.replace(/^\s+|\s+$/g, ""); // Removes leading and trailing whitespace
      }

      async function ParseInt(num) {
        if (num === null) {
          return null;
        }

        num = num.trim();
        num++;
        num--;

        return num;
      }

      function StrReplace(originalString, find, replaceWith) {
        // Check if originalString is a string
        if (typeof originalString !== "string") {
          return originalString; // Return originalString as is
        }

        // Escape special characters in the 'find' string to be used literally
        const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Use replace method to replace all occurrences of 'find' with 'replaceWith'
        return originalString.replace(new RegExp(escapedFind, "g"), replaceWith);
      }

      // Custom Mod function
      function Mod(dividend, divisor) {
        return dividend % divisor;
      }

      // Function to trim specified number of characters from the left side of a string
      function StringTrimLeft(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      // Function to trim specified number of characters from the right side of a string
      function StringTrimRight(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(0, input.length - numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      function StrLower(string) {
        if (typeof string !== "string") {
          console.error("Invalid input: expected a string but received:", string);
          return ""; // Return an empty string or handle as needed
        }
        return string.toLowerCase();
      }

      function StrSplit(inputStr, delimiter, num) {
        // Check if inputStr is a valid string
        if (typeof inputStr !== "string") {
          return ""; // Return empty string for invalid input
        }

        // Split the input string based on the delimiter
        const parts = inputStr.split(delimiter);

        // Return the part specified by the num parameter (1-based index)
        if (num > 0 && num <= parts.length) {
          return parts[num - 1]; // Return the specified part (0-based index)
        } else {
          return ""; // Return an empty string if num is out of range
        }
      }

      // Function to simulate AutoHotkey's RegExReplace in JavaScript
      function RegExReplace(inputStr, regexPattern, replacement) {
        // Create a regular expression object using the provided pattern
        const regex = new RegExp(regexPattern, "g"); // 'g' flag for global match

        // Use the replace() method to perform the regex replacement
        const resultStr = inputStr.replace(regex, replacement);

        // Return the modified string
        return resultStr;
      }

      // Function to escape special characters for regex
      function escapeRegex(str) {
        if (typeof str !== "string") {
          console.error("Invalid input for escapeRegex: expected a string but received:", str);
          return "";
        }
        return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }

      // Function to split a string based on delimiters
      function LoopParseFunc(var_, delimiter1 = "", delimiter2 = "") {
        if (typeof var_ !== "string") {
          console.error("Invalid input: expected a string but received:", var_);
          return []; // Return an empty array or handle as needed
        }

        if (!delimiter1 && !delimiter2) {
          return var_.split("");
        } else {
          const escapedDelimiters = escapeRegex(delimiter1 + delimiter2);
          const pattern = new RegExp(`[${escapedDelimiters}]+`);
          return var_.split(pattern).filter(Boolean);
        }
      }

      // MsgBox function
      function MsgBox(value) {
        console.log(value.toString());
      }

      // Sorting function

      function SortLikeAHK(varName, options = "") {
        let delimiter = "\n"; // Default delimiter
        let delimiterIndex = options.indexOf("D");

        if (delimiterIndex !== -1) {
          let delimiterChar = options[delimiterIndex + 1];
          delimiter = delimiterChar === "" ? "," : delimiterChar;
        }

        let items = varName.split(new RegExp(delimiter === "," ? "," : "\\" + delimiter));

        // Remove empty items and trim whitespace
        items = items.filter((item) => item.trim() !== "");

        // Apply sorting based on options
        if (options.includes("N")) {
          // Numeric sort
          items.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
        } else if (options.includes("Random")) {
          // Random sort
          for (let i = items.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [items[i], items[j]] = [items[j], items[i]];
          }
        } else {
          // Default alphabetical sort
          items.sort((a, b) => {
            const keyA = options.includes("C") ? a : a.toLowerCase();
            const keyB = options.includes("C") ? b : b.toLowerCase();
            if (keyA < keyB) return -1;
            if (keyA > keyB) return 1;
            return 0;
          });
        }

        // Reverse if 'R' option is present
        if (options.includes("R")) {
          items.reverse();
        }

        // Remove duplicates if 'U' option is present
        if (options.includes("U")) {
          const seen = new Map();
          items = items.filter((item) => {
            const key = options.includes("C") ? item : item.toLowerCase();
            if (!seen.has(key)) {
              seen.set(key, item);
              return true;
            }
            return false;
          });
        }

        // Join the sorted items back into a string
        const sortedVar = items.join(delimiter === "," ? "," : "\n");

        return sortedVar;
      }

      function MakeHotKey(hotkey, callback) {
        document.addEventListener("keydown", function (event) {
          const keys = hotkey.split("+").map((key) => key.trim().toLowerCase());
          const modifiers = {
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
          };

          let hotkeyPressed = true;
          keys.forEach((key) => {
            if (key === "ctrl" || key === "shift" || key === "alt") {
              if (!modifiers[key]) {
                hotkeyPressed = false;
              }
            } else if (key === "backspace") {
              if (event.key !== "Backspace") {
                hotkeyPressed = false;
              }
            } else if (key.startsWith("arrow")) {
              const arrowDirection = key.replace("arrow", "");
              if (arrowDirection === "up" && event.key !== "ArrowUp") {
                hotkeyPressed = false;
              } else if (arrowDirection === "down" && event.key !== "ArrowDown") {
                hotkeyPressed = false;
              } else if (arrowDirection === "left" && event.key !== "ArrowLeft") {
                hotkeyPressed = false;
              } else if (arrowDirection === "right" && event.key !== "ArrowRight") {
                hotkeyPressed = false;
              }
            } else if (key === "enter") {
              if (event.key !== "Enter") {
                hotkeyPressed = false;
              }
            } else if (!event.key.match(/^[0-9a-zA-Z]$/) && event.key !== key) {
              hotkeyPressed = false;
            } else if (event.key.toLowerCase() !== key && event.key.match(/^[a-zA-Z]$/)) {
              hotkeyPressed = false;
            }
          });

          if (hotkeyPressed) {
            if (modifiers["shift"]) {
              callback(hotkey.toUpperCase());
            } else {
              callback(hotkey.toLowerCase());
            }
          }
        });
      }

      // InStr
      function InStr(Haystack, Needle, CaseSensitive = true, StartingPos = 1, Occurrence = 1) {
        if (Haystack === null || Needle === null) return false;

        // Adjust starting position if less than 1
        StartingPos = Math.max(StartingPos, 1);

        // Case-sensitive search by default
        if (!CaseSensitive) {
          Haystack = Haystack.toLowerCase();
          Needle = Needle.toLowerCase();
        }

        let pos = -1;
        let count = 0;
        for (let i = StartingPos - 1; i < Haystack.length; i++) {
          if (Haystack.substring(i, i + Needle.length) === Needle) {
            count++;
            if (count === Occurrence) {
              pos = i + 1;
              break;
            }
          }
        }

        return pos > 0; // Return true if the substring is found, false otherwise
      }

      function Trim(inputString) {
        // Check if inputString is null or undefined
        if (inputString == null) {
          return ""; // Return an empty string if inputString is null or undefined
        }
        return inputString.replace(/^\s+|\s+$/g, ""); // Removes leading and trailing whitespace
      }

      function StrReplace(originalString, find, replaceWith) {
        // Check if originalString is a string
        if (typeof originalString !== "string") {
          return originalString; // Return originalString as is
        }

        // Escape special characters in the 'find' string to be used literally
        const escapedFind = find.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Use replace method to replace all occurrences of 'find' with 'replaceWith'
        return originalString.replace(new RegExp(escapedFind, "g"), replaceWith);
      }

      // Function to trim specified number of characters from the right side of a string
      function StringTrimRight(input, numChars) {
        if (typeof input === "string" && typeof numChars === "number" && numChars >= 0) {
          return input.length > numChars ? input.substring(0, input.length - numChars) : "";
        } else {
          console.error("Invalid input provided.");
          return input; // Return original input if trimming is not possible
        }
      }

      // Define the str function
      function str(value) {
        return String(value);
      }

      // Single async function to structure the entire script
      async function runScript() {
        // Declare and assign a variable

    
    
        var Gui1 = {};
        Gui1 = document.createElement("div");
        Gui1.id = "Gui1";

        // Declare and assign a variable
        let variables = {
          null: null,
        };

        Gui1.style.position = "absolute";
        Gui1.style.width = window.innerWidth + "px"; // Set the width
        Gui1.style.height = "" + BuildInVars("A_ScreenHeight") + "px"; // Set the height
        Gui1.style.background = "linear-gradient(90deg, " + "#121212" + " 0%, " + "#121212" + " 100%)";
        Gui1.style.backgroundColor = "linear-gradient(90deg, " + "#121212" + " 0%, " + "#121212" + " 100%)";
        Gui1.style.color = "white";
        Gui1.style.fontSize = "15px";
        Gui1.style.padding = "0px";
        Gui1.style.borderRadius = "0px";
        Gui1.style.fontFamily = ", sans-serif"; // Specify your desired font here
        Gui1.style.zIndex = "10";
        document.body.appendChild(Gui1); // Append the GUI window to the body
        Gui1.style.display = "block";
        let textOldSave;
        document.documentElement.setAttribute("style", "padding: 0; margin: 0;");
        document.head.setAttribute("style", "padding: 0; margin: 0;");
        document.body.setAttribute("style", "overflow-x: hidden;padding: 0; margin: 0;");
        
        
        
        
  



  
let build_in_funcs = '';
let allInstFormGithub = "";
function fetchBuildInFuncs() {
    // Fetch the HTVM-instructions.txt file from the URL
    fetch('https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt')
        .then(response => response.text())  // Get the raw text of the file
        .then(data => {
            // Split the text into an array of lines
            const lines = data.split('\n');
            let allInstFormGithub = "";
            allInstFormGithub = String(data);
            localStorage.setItem('allInstFromGithubFIX', allInstFormGithub);
            

            // Extract the lines from 163 to the end (index 162 to the end of the array)
            build_in_funcs = lines.slice(162).join('\n');
            
            // You now have the build_in_funcs variable populated with lines from 163 to the end
            //console.log(build_in_funcs);  // Optionally print the result to check
        })
        .catch(error => {
            console.error('Error fetching HTVM-instructions.txt:', error);
        });
}

// Call the function to fetch the data
fetchBuildInFuncs();




let urlParams = new URLSearchParams(window.location.search);
let id = urlParams.get('id');

if (id) {
    const storedData = localStorage.getItem(`htvm_lang_${id}`);

    if (storedData) {
        try {
            const dataArray = JSON.parse(storedData);

            if (Array.isArray(dataArray)) {
                // Replace the first element with "htvm" and join the rest of the trimmed lines
                dataArray[0] = "htvm2";  // Replace the first line with "htvm"
                dataArray[1] = "htvm2";  // Replace the first line with "htvm"
                const finalText = dataArray.map(line => line.trim()).join("\n");

                argHTVMinstrMORE.push(finalText);
            } else {
                console.error("Stored data is not an array:", dataArray);
            }
        } catch (error) {
            console.error("Error parsing JSON:", error);
        }
    } else {
        console.error("No data found in localStorage for key:", `htvm_lang_${id}`);
    }
} else {
    console.error("No 'id' found in URL parameters.");
}


allInstFormGithub = localStorage.getItem('allInstFromGithubFIX');

//console.log(allInstFormGithub)
//console.log("=-----------------------------=")
//console.log(argHTVMinstrMORE[0])


variables.ideTEXT = `; This is a preview of your language and how it will look.

; This is a preview of your language and how it will look.

; Here's how types will appear if you only define them:
int varName1
str varName2
bool varName3
float varName4
int8 varName5
int16 varName6
int32 varName7
int64 varName8

; Alternatively, you can define them like this:
int varName9 := 34

; Here is how to define a function with static types if you convert to C++.
; However, it will still work even if you are not converting to C++; types will be stripped away.
func void funcName1(int paramVar1, str paramVar2 := "", bool paramVar3 := false, float paramVar4 := 1.5) {
	; This is how the global keyword works if we convert to Python.
	; But even if we don't, it will just be removed, so you can add it if you want to convert to Python as well.
	global varName5

	; Here's how if, else if, and else statements will look:
	if (varName1 = paramVar1) {
		print("varName1 is equal to paramVar1")
	} 
	else if (varName1 != paramVar1 or varName1 <= paramVar1) {
		print("varName1 is less than or equal to paramVar1")
	} else {
		print("varName1 is NOT less than or equal to paramVar1 or something else")
	} 

	; this is how the return keyword will look like in your lang
	return
} 

main ; This is where the main function will start. It's just a label, so don't worry.
funcName1(varName9)

; this is how a while loop works in your lang
bool var1 := false
while (var1 = false) {
	print("we are inside the while loop")
	var1 := true
} 
print("we are outside the while loop")


; this is how to use a loop whit arrays
arr str array123 := ["hey"]
array123.add("hello")
array123.add("how")
array123.add("are")
array123.add("you")
array123.add("doing")
Loop, % array123.size() {
	print("iteration: " . STR(A_Index))
	print("Item: " . array123[A_Index])
} 

print("this is how the escape char looks like \`nthis is a new line")
\'\'\'1
this is a comment block
this is a comment block
\'\'\'2

; this is how to use an AutoHotKey like Loop
Loop, 10 {
	if (A_Index % 2 = 0) {
		continue
	} 
	print(A_Index)
} 

; this is how to use an AutoHotKey like infinite Loop
Loop {
	if (A_Index = 5) {
		break
	} else {
		print(A_Index)
	} 
} 

; this is how to use an AutoHotKey like Loop, parse
str someText := "hello how are you doing\`ntoday we are good."
Loop, Parse, someText, " ", \`n {
	print(A_LoopField)
} 

; Error Handling
try {
	throw ErrorMsg("Something went wrong!")
} 
catch (e) {
	print(e)
} 
finally {
	print("Finally block executed")
}

`;

let OUTCODE = "";

if (allInstFormGithub)
{
        OUTCODE = compiler(variables.ideTEXT, allInstFormGithub, "full", "htvm2");
//console.log("==========12")
//console.log(OUTCODE)
//console.log("==========123")
        //resetGlobalVarsOfHTVMjs();
}
        
        // Assuming variables.theSHA is already set
    
        // Retrieve the plain text from local storage
variables.idetext = OUTCODE;
        variables.AScreenHeight = BuildInVars("A_ScreenHeight") - 20;
        variables.AScreenWidth = BuildInVars("A_ScreenWidth") - 20;
        var saveBackCodeBugFix = variables.ideTEXT;
        AddIDE(Gui1, 10, 10, variables.AScreenWidth, variables.AScreenHeight, "Gui1IDE1", 15, "autohotkey", IDE1, variables.idetext);


        async function IDE1(A_GuiControl) {
          variables.idetext = A_GuiControl;

        }
        async function HotKeyCalledAltShiftCtrlF() {
          // console.log("HotKeyCalled AltShiftCtrlF")
          textOldSave = variables.idetext;
          variables.TextData = "";
          variables.out = "";
          variables.base64ImageData = "";
          variables.base64soundList = "";
          variables.base64iconList = "";
          variables.base64VideoData = "";
          variables.jsCode01CanvasW = "";
          variables.jsCode01CanvasH = "";
          variables.skipLeftCuleyForFuncPLS = 0;
          variables.eavbnsalvbaslv = 0;
          variables.ifWeUseCanvas = 0;
          variables.weUseCnanvasAtALL = 0;
          variables.numOfTextData = 0;
          variables.funcs = "let funcs = {\n";
          variables.doWeEvenDecAnyFuncHUH = 0;
          variables.onKeyPress = "";
          variables.jsCodeGui = "";
          variables.isFullScrenOnce = 0;
          variables.HotKeyCalledHotKyes = "";
          variables.jsCode = "";
          variables.outAHKCodeTrimed = "";
          variables.idetext = await StrReplace(variables.idetext, await Chr(13), "");
          var items1 = LoopParseFunc(variables.idetext, "\n", "\r");
          for (/* Loop Parse */ let A_Index1 = 1; A_Index1 <= items1.length; A_Index1++) {
            variables.A_Index1 = A_Index1;
            variables.A_LoopField1 = items1[A_Index1 - 1];
            variables.outAHKCodeTrimed += (await Trim(variables.A_LoopField1)) + "\n";
          }
          variables.idetext = StringTrimRight(variables.outAHKCodeTrimed, 1);
          variables.AHKcodeOUT754754 = "";
          variables.areWEinSome34sNum = 0;
          variables.theIdNumOfThe34 = 0;
          var items2 = LoopParseFunc(variables.idetext);
          for (/* Loop Parse */ let A_Index2 = 1; A_Index2 <= items2.length; A_Index2++) {
            variables.A_Index2 = A_Index2;
            variables.A_LoopField2 = items2[A_Index2 - 1];
            variables["theIdNumOfThe34theVar" + variables.A_Index2] = await Chr(34);
          }
          var items3 = LoopParseFunc(variables.idetext);
          for (/* Loop Parse */ let A_Index3 = 1; A_Index3 <= items3.length; A_Index3++) {
            variables.A_Index3 = A_Index3;
            variables.A_LoopField3 = items3[A_Index3 - 1];
            if (variables.A_LoopField3 == (await Chr(34))) {
              variables.areWEinSome34sNum += 1;
            }
            if (variables.areWEinSome34sNum == 1) {
              if (variables.A_LoopField3 != (await Chr(34))) {
                variables["theIdNumOfThe34theVar" + variables.theIdNumOfThe34] += variables.A_LoopField3;
              } else {
                variables.theIdNumOfThe34 += 1;
                variables.AHKcodeOUT754754 += "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" + (await Chr(65)) + (await Chr(65)) + (await str(variables.theIdNumOfThe34)) + (await Chr(65)) + (await Chr(65));
              }
            }
            if (variables.areWEinSome34sNum == 2 || variables.areWEinSome34sNum == 0) {
              if (variables.A_LoopField3 != (await Chr(34))) {
                variables.AHKcodeOUT754754 += variables.A_LoopField3;
              }
              variables.areWEinSome34sNum = 0;
            }
          }
          variables.idetext = variables.AHKcodeOUT754754;
          for (/* Normal Loop */ variables.A_Index4 = 1; variables.A_Index4 <= variables.theIdNumOfThe34; variables.A_Index4++) {
            variables["theIdNumOfThe34theVar" + variables.A_Index4] += await Chr(34);
          }
          variables.sstr23IfFuncInNAMEnum = 0;
          variables.outCodeFixBraces = "";
          for (/* Normal Loop */ variables.A_Index5 = 1; variables.A_Index5 <= 2; variables.A_Index5++) {
            variables.outCodeFixBraces = "";
            var items6 = LoopParseFunc(variables.idetext, "\n", "\r");
            for (/* Loop Parse */ let A_Index6 = 1; A_Index6 <= items6.length; A_Index6++) {
              variables.A_Index6 = A_Index6;
              variables.A_LoopField6 = items6[A_Index6 - 1];
              if ((await InStr(await Trim(variables.A_LoopField6), "{")) && (await Trim(variables.A_LoopField6)) != "{") {
                variables.outCodeFixBraces += (await Trim(await StrReplace(await Trim(variables.A_LoopField6), "{", ""))) + "\n{\n";
              } else if ((await InStr(await Trim(variables.A_LoopField6), "}")) && (await Trim(variables.A_LoopField6)) != "}") {
                variables.outCodeFixBraces += "}\n" + (await Trim(await StrReplace(await Trim(variables.A_LoopField6), "}", ""))) + "\n";
              } else {
                variables.outCodeFixBraces += (await Trim(variables.A_LoopField6)) + "\n";
              }
            }
            variables.idetext = StringTrimRight(variables.outCodeFixBraces, 1);
          }
          variables.idetext = await KandRstyleFormat(await indent_nested_curly_braces(variables.idetext));
          for (/* Normal Loop */ variables.A_Index7 = 1; variables.A_Index7 <= variables.theIdNumOfThe34; variables.A_Index7++) {
            variables.idetext = await StrReplace(variables.idetext, "ihuiuuhuuhtheidFor--asas-theuhturtyphoutr-" + (await Chr(65)) + (await Chr(65)) + (await str(variables.A_Index7)) + (await Chr(65)) + (await Chr(65)), variables["theIdNumOfThe34theVar" + variables.A_Index7]);
          }
          GuiControl("textide", "Gui1IDE1", variables.idetext);
        }
        async function KandRstyleFormat(code) {
          variables.code = code;
          variables.codeOut = "";
          var items8 = LoopParseFunc(variables.code, "\n", "\r");
          for (/* Loop Parse */ let A_Index8 = 1; A_Index8 <= items8.length; A_Index8++) {
            variables.A_Index8 = A_Index8;
            variables.A_LoopField8 = items8[A_Index8 - 1];
            variables["lookInTheFurtre" + variables.A_Index8] = await Trim(variables.A_LoopField8);
          }
          variables["lookInTheFurtre" + variables.A_Index] = " ";
          variables.skipLine = 0;
          var items9 = LoopParseFunc(variables.code, "\n", "\r");
          for (/* Loop Parse */ let A_Index9 = 1; A_Index9 <= items9.length; A_Index9++) {
            variables.A_Index9 = A_Index9;
            variables.A_LoopField9 = items9[A_Index9 - 1];
            variables.AIndex = variables.A_Index9 + 1;
            if (variables.skipLine == 1) {
              variables.skipLine = 0;
            } else {
              if (variables["lookInTheFurtre" + variables.AIndex] != "{") {
                variables.codeOut += variables.A_LoopField9 + "\n";
              }
            }
            if (variables["lookInTheFurtre" + variables.AIndex] == "{") {
              variables.skipLine = 1;
              variables.codeOut += variables.A_LoopField9 + " {\n";
            }
          }
          variables.codeOut = StringTrimRight(variables.codeOut, 1);
          variables.codeOut2 = "";
          var items10 = LoopParseFunc(variables.codeOut, "\n", "\r");
          for (/* Loop Parse */ let A_Index10 = 1; A_Index10 <= items10.length; A_Index10++) {
            variables.A_Index10 = A_Index10;
            variables.A_LoopField10 = items10[A_Index10 - 1];
            variables["lookInTheFurtre" + variables.A_Index10] = await Trim(variables.A_LoopField10);
          }
          variables["lookInTheFurtre" + variables.A_Index] = " ";
          variables.skipLine = 0;
          var items11 = LoopParseFunc(variables.codeOut, "\n", "\r");
          for (/* Loop Parse */ let A_Index11 = 1; A_Index11 <= items11.length; A_Index11++) {
            variables.A_Index11 = A_Index11;
            variables.A_LoopField11 = items11[A_Index11 - 1];
            variables.AIndex = variables.A_Index11 + 1;
            if (variables.skipLine == 1) {
              variables.skipLine = 0;
            } else {
              if (variables["lookInTheFurtre" + variables.AIndex] != "else {") {
                variables.codeOut2 += variables.A_LoopField11 + "\n";
              }
            }
            if (variables["lookInTheFurtre" + variables.AIndex] == "else {") {
              variables.skipLine = 1;
              variables.scoaceses = "";
              var items12 = LoopParseFunc(variables.A_LoopField11);
              for (/* Loop Parse */ let A_Index12 = 1; A_Index12 <= items12.length; A_Index12++) {
                variables.A_Index12 = A_Index12;
                variables.A_LoopField12 = items12[A_Index12 - 1];
                if (variables.A_LoopField12 != " ") {
                  break;
                } else {
                  variables.scoaceses += " ";
                }
              }
              variables.codeOut2 += variables.scoaceses + "} else" + " {\n";
            }
          }
          variables.codeOut = StringTrimRight(variables.codeOut2, 1);
          return variables.codeOut;
        }
        async function RepeatSpaces(count) {
          variables.count = count;
          variables.spaces = "";
          for (/* Normal Loop */ variables.A_Index10 = 1; variables.A_Index10 <= variables.count; variables.A_Index10++) {
            variables.spaces += " ";
          }
          return variables.spaces;
        }
        async function indent_nested_curly_braces(input_string) {
          variables.input_string = input_string;
          variables.indent_size = 4;
          variables.current_indent = 0;
          variables.result = "";
          var items11 = variables.input_string.split(/\r?\n|\r/);
          for (/* Loop Parse */ let A_Index11 = 1; A_Index11 <= items11.length; A_Index11++) {
            variables.A_Index11 = A_Index11;
            variables.A_LoopField11 = items11[A_Index11 - 1];
            variables.trimmed_line = await Trim(variables.A_LoopField11);
            if (variables.trimmed_line == (await Chr(123))) {
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
              variables.current_indent = variables.current_indent + variables.indent_size;
            } else if (variables.trimmed_line == (await Chr(125))) {
              variables.current_indent = variables.current_indent - variables.indent_size;
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
            } else {
              variables.result += (await RepeatSpaces(variables.current_indent)) + (variables.trimmed_line + "\n");
            }
          }
          variables.result = StringTrimRight(variables.result, 1);
          // Return the result
          return variables.result;
        }
      }

      // Call the async function to start the script
      runScript();
        </script>
  </body>
</html>
