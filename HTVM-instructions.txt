cpp
htvm
StringTrimLeft,OUTVAR,INVAR,param1|StringTrimRight,OUTVAR,INVAR,param1|Random,OUTVAR,param1,param2|Sleep,INVAR|FileRead,OUTVAR,'param1|FileAppend,INVAR,'param1|FileDelete,'INVAR|Sort,INOUTVAR,'param1|MsgBox,'param1
alliance
crew
proc
struct
prop
this
include
___start
___end
___cpp start
___cpp end
___py start
___py end
___js start
___js end
___go start
___go end
___lua start
___lua end
___cs start
___cs end
___java start
___java end
___kt start
___kt end
___rb start
___rb end
___nim start
___nim end
___ahk start
___ahk end
___swift start
___swift end
___dart start
___dart end
___ts start
___ts end
___groovy start
___groovy end
___htvm start
___htvm end
___inhtvm start
___inhtvm end
{
}
null
true
false
void
double
char
uint8
uint16
uint32
uint64
int
str
bool
float
int8
int16
int32
int64
if
else if
else
while
Loop
Loop,
Loop, Parse,
continue
break
func
await
async
throw
ErrorMsg
try
catch
finally
return
.add
.pop
.size
.insert
.rm
.indexOf
arr
arr int
arr str
arr float
arr bool
var
let
const
end
global
;
'''1
'''2
`
main
.
+
-
*
/
%
**
=
===
!=
>
<
>=
<=
and
or
!
&
|
^
~
<<
>>
>>>
:=
+=
.=
-=
*=
/=
%=
<<=
>>=
>>>=
&=
|=
^=
?
:
++
--
0
A_Index
A_LoopField
on
off
off
on
on
off
off
off
on
off
on
off
off


func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null

// add the function here

funcEND======================funcEND==============



func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null
// add the function here
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null
// add the function here
funcEND======================funcEND==============
func======================func==============
lang: lua
name: infinite_HTVM_Lua_Loop_HTVM
libs: null
description: null
function infinite_HTVM_Lua_Loop_HTVM()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end
funcEND======================funcEND==============

func======================func==============
lang: cs
name: ResetList
libs: null
description: null
    // Dynamic function to reset lists, detects type and returns an empty list of the same type
    static dynamic ResetList(dynamic arr)
    {
        // Get the type of the elements in the list
        Type elementType = arr.GetType().GetGenericArguments()[0];

        // Create a new empty list of the same type and return it
        Type listType = typeof(List<>).MakeGenericType(elementType);
        return Activator.CreateInstance(listType);
    }
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: LoopParseFunc
libs: #include <vector>|#include <string>|#include <regex>
description: null
// Function to escape special characters for regex
std::string escapeRegex(const std::string& str) {
    static const std::regex specialChars{R"([-[\]{}()*+?.,\^$|#\s])"};
    return std::regex_replace(str, specialChars, R"(\$&)");
}
// Function to split a string based on delimiters
std::vector<std::string> LoopParseFunc(const std::string& var, const std::string& delimiter1 = "", const std::string& delimiter2 = "") {
    std::vector<std::string> items;
    if (delimiter1.empty() && delimiter2.empty()) {
        // If no delimiters are provided, return a list of characters
        for (char c : var) {
            items.push_back(std::string(1, c));
        }
    } else {
        // Escape delimiters for regex
        std::string escapedDelimiters = escapeRegex(delimiter1 + delimiter2);
        // Construct the regular expression pattern for splitting the string
        std::string pattern = "[" + escapedDelimiters + "]+";
        std::regex regexPattern(pattern);
        std::sregex_token_iterator iter(var.begin(), var.end(), regexPattern, -1);
        std::sregex_token_iterator end;
        while (iter != end) {
            items.push_back(*iter++);
        }
    }
    return items;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: LoopParseFunc
libs: import re
description: null
def LoopParseFunc(var, delimiter1="", delimiter2=""):
    if not delimiter1 and not delimiter2:
        # If no delimiters are provided, return a list of characters
        items = list(var)
    else:
        # Construct the regular expression pattern for splitting the string
        pattern = r'[' + re.escape(delimiter1) + re.escape(delimiter2) + r']+'
        # Split the string using the constructed pattern
        items = re.split(pattern, var)
    return items
funcEND======================funcEND==============

func======================func==============
lang: go
name: LoopParseFunc
libs: "regexp"
description: null
func LoopParseFunc(varString string, delimiter1 string, delimiter2 string) []string {
    var items []string
    if delimiter1 == "" && delimiter2 == "" {
        // If no delimiters are provided, convert string to slice of strings
        items = make([]string, len(varString))
        for i, c := range varString {
            items[i] = string(c)
        }
    } else {
        // Construct the regular expression pattern for splitting the string
        pattern := fmt.Sprintf("[%s%s]+", delimiter1, delimiter2)
        // Split the string using the constructed pattern
        items = regexp.MustCompile(pattern).Split(varString, -1)
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString, delimiter1, delimiter2)
    local items = {}
    delimiter1 = delimiter1 or ""
    delimiter2 = delimiter2 or ""

    -- Changed: Don't escape the delimiters since we want them literal
    -- Just use them directly in the pattern
    if delimiter1 == "" and delimiter2 == "" then
        for i = 1, #varString do
            table.insert(items, varString:sub(i, i))
        end
    else
        -- Changed: Simplified pattern to directly match \n and \r
        local pattern = delimiter1 .. delimiter2
        for item in varString:gmatch("([^" .. pattern .. "]+)") do
            table.insert(items, item)
        end
    end
    return items
end
funcEND======================funcEND==============


func======================func==============
lang: cs
name: LoopParseFunc
libs: using System.Linq;|using System.Text.RegularExpressions;
description: null
    public static string[] LoopParseFunc(string varString, string delimiter1 = "", string delimiter2 = "")
    {
        string[] items;
        if (string.IsNullOrEmpty(delimiter1) && string.IsNullOrEmpty(delimiter2))
        {
            // If no delimiters are provided, return an array of characters
            items = varString.ToCharArray().Select(c => c.ToString()).ToArray();
        }
        else
        {
            // Construct the regular expression pattern for splitting the string
            string pattern = "[" + Regex.Escape(delimiter1) + Regex.Escape(delimiter2) + "]+";
            // Split the string using the constructed pattern
            items = Regex.Split(varString, pattern);
        }
        return items;
    }
funcEND======================funcEND==============


func======================func==============
lang: java
name: LoopParseFunc
libs: null
description: null
    public static String[] LoopParseFunc(String varString, String delimiter1, String delimiter2) {
        String[] items;
        if (delimiter1.isEmpty() && delimiter2.isEmpty()) {
            // If no delimiters are provided, return an array of characters
            items = varString.split("");
        } else {
            // Construct the regular expression pattern for splitting the string
            String pattern = "[" + Pattern.quote(delimiter1) + Pattern.quote(delimiter2) + "]+";
            // Split the string using the constructed pattern
            items = varString.split(pattern);
        }
        return items;
    }

funcEND======================funcEND==============


func======================func==============
lang: kt
name: LoopParseFunc
libs: null
description: null
fun LoopParseFunc(varString: String, delimiter1: String = "", delimiter2: String = ""): List<String> {
    val items: MutableList<String> = mutableListOf()
    if (delimiter1.isEmpty() && delimiter2.isEmpty()) {
        // If no delimiters are provided, return a list of characters
        for (char in varString) {
            items.add(char.toString())
        }
    } else {
        // Construct the regular expression pattern for splitting the string
        val pattern = "[$delimiter1$delimiter2]+"
        // Split the string using the constructed pattern
        items.addAll(varString.split(Regex(pattern)))
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: rb
name: LoopParseFunc
libs: null
description: null
def LoopParseFunc(varString, delimiter1 = "", delimiter2 = "")
    items = []
    if delimiter1.empty? && delimiter2.empty?
        # If no delimiters are provided, return an array of characters
        items = varString.chars
    else
        # Construct the regular expression pattern for splitting the string
        pattern = "[#{delimiter1}#{delimiter2}]+"
        # Split the string using the constructed pattern
        items = varString.split(Regexp.new(pattern))
    end
    return items
end
funcEND======================funcEND==============


func======================func==============
lang: nim
name: LoopParseFunc
libs: import strutils
description: null

proc LoopParseFunc(varString: string, delimiter1: string = "", delimiter2: string = ""): seq[string] =
  var items: seq[string] = @[]

  if delimiter1.len == 0 and delimiter2.len == 0:
    # If no delimiters are provided, return a sequence of characters
    for i in 0..<varString.len:
      items.add($varString[i])
  else:
    if delimiter2.len == 0:
      # If only one delimiter is provided, use simple split
      items = varString.split(delimiter1)
    else:
      # If both delimiters are provided, first split by delimiter1
      let tempItems = varString.split(delimiter1)
      # Then split each item by delimiter2 if needed
      for item in tempItems:
        let subItems = item.split(delimiter2)
        for subItem in subItems:
          if subItem.len > 0:  # Only add non-empty items
            items.add(subItem)

  return items


funcEND======================funcEND==============


func======================func==============
lang: ahk
name: LoopParseFunc
libs: null
description: null
;LoopParseFunc

funcEND======================funcEND==============


func======================func==============
lang: swift
name: LoopParseFunc
libs: null
description: null
func LoopParseFunc(_ varString: String, _ delimiter1: String = "", _ delimiter2: String = "") -> [String] {
    var items: [String] = []

    // If no delimiters are provided, return an array of characters
    if delimiter1.isEmpty && delimiter2.isEmpty {
        items = Array(varString).map { String($0) }
    } else {
        // Use the first delimiter for splitting the string
        let delimiter = delimiter1.isEmpty ? delimiter2 : delimiter1
        items = varString.split(separator: Character(delimiter)).map { String($0) }
    }

    return items
}

funcEND======================funcEND==============


func======================func==============
lang: dart
name: LoopParseFunc
libs: null
description: null
List<String> LoopParseFunc(String varString, [String delimiter1 = "", String delimiter2 = ""]) {
    List<String> items = [];
    if (delimiter1.isEmpty && delimiter2.isEmpty) {
        // If no delimiters are provided, return a list of characters
        items.addAll(varString.split(''));
    } else {
        // Construct the regular expression pattern for splitting the string
        String pattern = "[$delimiter1$delimiter2]+";
        // Split the string using the constructed pattern
        items.addAll(varString.split(RegExp(pattern)));
    }
    return items;
}
funcEND======================funcEND==============


func======================func==============
lang: ts
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString: string, delimiter1: string = "", delimiter2: string = ""): string[] {
    let items: string[];
    if (delimiter1 === "" && delimiter2 === "") {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        const pattern = `[${delimiter1}${delimiter2}]+`;
        // Split the string using the constructed pattern
        items = varString.split(new RegExp(pattern));
    }
    return items;
}
funcEND======================funcEND==============




func======================func==============
lang: groovy
name: LoopParseFunc
libs: null
description: null
def LoopParseFunc(String varString, String delimiter1 = "", String delimiter2 = "") {
    def items = []
    if (delimiter1 == "" && delimiter2 == "") {
        // If no delimiters are provided, return an array of characters
        items = varString.toList()
    } else {
        // Construct the regular expression pattern for splitting the string
        def pattern = "[${delimiter1}${delimiter2}]"
        // Split the string using the constructed pattern
        items = varString.split(pattern)
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: print
libs: #include <iostream>|#include <string>|#include <type_traits>
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for const char* specifically
void print(const char* value) {
    std::cout << std::string(value) << std::endl;  // Convert const char* to std::string
}
// Print function that converts all types to string if needed
template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
function print(value) {
    console.log(value)
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
# used the print func
funcEND======================funcEND==============


func======================func==============
lang: go
name: print
libs: )|"fmt"
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
func print(value interface{}) {
    fmt.Println(value)
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
-- Print function for different types

funcEND======================funcEND==============

func======================func==============
lang: cs
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types

    public static void print(object value)
    {
        Console.WriteLine(value);
    }
funcEND======================funcEND==============

func======================func==============
lang: java
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types

    public static void print(Object value) {
        System.out.println(value);
    }

funcEND======================funcEND==============

func======================func==============
lang: kt
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types
fun print(value: Any) {
  println(value)
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
# Print function for various types

def print(value)
  if value.is_a?(String)
    puts value
  elsif value.is_a?(Numeric)
    puts value.to_s
  elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
    puts value ? "true" : "false"
  else
    puts "Unsupported type"
  end
end


funcEND======================funcEND==============

func======================func==============
lang: nim
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
# Print function for various types
proc print(value: auto) =  # Use 'auto' instead of 'untyped'
  echo value

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
; Print function for various types
print(value) {
    if IsObject(value) {
        str := ""
        for index, element in value
            str .= element ", "
        MsgBox % Trim(str, ", ")  ; Remove trailing comma and space
    } else {
        MsgBox % value
    }
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types



funcEND======================funcEND==============

func======================func==============
lang: dart
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types

funcEND======================funcEND==============

func======================func==============
lang: ts
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~
// Print function for various types
function print(value: any): void {
    console.log(value);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: print
libs: null
description: io~~~The `print` function is a versatile utility for outputting data to the standard console. It accepts various data types including strings, numbers (integers, floats), and booleans. When given a boolean, it will print "1" for true and "0" for false (or the language-equivalent boolean string representation). For other types, it attempts to convert them to a string representation before printing. Each call to `print` typically appends a newline character, ensuring subsequent outputs appear on a new line.~~~Here is how to use it:~~~```htvm~~~; Example 1: Printing a string~~~str message := "Hello, HTVM!"~~~; Should print: Hello, HTVM!~~~print(message)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 2: Printing an integer~~~int count := 100~~~; Should print: 100~~~print(count)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 3: Printing a float~~~float piApprox := 3.14159~~~; Should print: 3.14159~~~print(piApprox)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 4: Printing a boolean (true)~~~bool isActive := true~~~; Should print: 1 (or true, depending on language)~~~print(isActive)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 5: Printing a boolean (false)~~~bool isDone := false~~~; Should print: 0 (or false, depending on language)~~~print(isDone)~~~print("--------------------")~~~; ----------------------------------------------------~~~; Example 6: Printing concatenated string and number~~~str label := "Score: "~~~int score := 42~~~; Should print: Score: 42~~~print(label . STR(score))~~~print("--------------------")~~~; ----------------------------------------------------~~~; Test: Printing a null-like value (if HTVM has 'null' keyword and print handles it)~~~str nullVar := null~~~; Behavior for null depends on language (e.g. "null", "", error)~~~print(nullVar)~~~```~~~


// Print function
def print = { message ->
    System.out.println(message)
}

funcEND======================funcEND==============


func======================func==============
lang: js
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
// Convert value to string
function STR(value) {
    if (value === null || value === undefined) {
        return ""; // Return a string for null or undefined
    } else if (typeof value === 'number') {
        return value.toString();
    } else if (typeof value === 'boolean') {
        return value ? "1" : "0";
    } else if (typeof value === 'string') {
        return value; // Return the string as is
    } else {
        // Handle any unexpected types gracefully
        return String(value); // Convert any other type to a string
    }
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
// Convert value to integer
function INT(value) {
    const intValue = parseInt(value, 10);
    if (Number.isNaN(intValue)) {
        console.warn(`Invalid input: ${value} cannot be converted to an integer.`);
        return 0;  // Or any other default value
    }
    return intValue;
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
// Convert value to float
function FLOAT(value) {
    const floatValue = parseFloat(value);
    if (isNaN(floatValue)) {
        throw new TypeError("Cannot convert to float");
    }
    return floatValue;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
# Convert value to string
def STR(value):
    if isinstance(value, (int, float)):
        return str(value)
    elif isinstance(value, bool):
        return "1" if value else "0"
    elif isinstance(value, str):
        return value  # If the value is already a string, return it as-is
    else:
        raise TypeError("Unsupported type")
funcEND======================funcEND==============
func======================func==============
lang: py
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
# Convert value to integer
def INT(value):
    try:
        # Try converting the value to an integer
        return int(float(value))
    except ValueError:
        # If conversion fails, raise a TypeError
        raise TypeError("Cannot convert to integer")
funcEND======================funcEND==============
func======================func==============
lang: py
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
# Convert value to float
def FLOAT(value):
    try:
        return float(value)
    except ValueError:
        raise TypeError("Cannot convert to float")
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: INT
libs: #include <string>|#include <sstream>
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
// Convert std::string to int
int INT(const std::string& str) {
    std::istringstream iss(str);
    int value;
    iss >> value;
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: STR
libs: #include <string>
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
// Convert various types to std::string
std::string STR(int value) {
    return std::to_string(value);
}
// Convert various types to std::string
std::string STR(long long value) {
    return std::to_string(value);
}
std::string STR(float value) {
    return std::to_string(value);
}
std::string STR(double value) {
    return std::to_string(value);
}
std::string STR(size_t value) {
    return std::to_string(value);
}
std::string STR(bool value) {
    return value ? "1" : "0";
}
std::string STR(const char* value) {
    return std::string(value);
}
std::string STR(const std::string& value) {
    return value;
}
funcEND======================funcEND==============


func======================func==============
lang: go
name: STR
libs: )|"strconv"
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
func STR(value interface{}) string {
    switch v := value.(type) {
    case int:
        return strconv.Itoa(v)
    case int64:
        return strconv.FormatInt(v, 10)
    case float64:
        return fmt.Sprintf("%f", v)
    case bool:
        if v {
            return "1"
        } else {
            return "0"
        }
    case string:
        return v
    default:
        return fmt.Sprintf("%v", v)
    }
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
function STR(value)
    if type(value) == "number" then
        return tostring(value)
    elseif type(value) == "boolean" then
        return value and "1" or "0"
    elseif type(value) == "string" then
        return value
    else
        return tostring(value)
    end
end
funcEND======================funcEND==============


func======================func==============
lang: cs
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
public static string STR(object value) {
    if (value is int)
        return value.ToString();
    else if (value is long)
        return value.ToString();
    else if (value is float)
        return value.ToString();
    else if (value is double)
        return value.ToString();
    else if (value is bool)
        return (bool)value ? "1" : "0";
    else if (value is string)
        return (string)value;
    else
        return value.ToString();
}
funcEND======================funcEND==============

func======================func==============
lang: java
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
public static String STR(Object value) {
    if (value instanceof Integer) {
        return value.toString();
    } else if (value instanceof Long) {
        return value.toString();
    } else if (value instanceof Float) {
        return value.toString();
    } else if (value instanceof Double) {
        return value.toString();
    } else if (value instanceof Boolean) {
        return (Boolean) value ? "1" : "0";
    } else if (value instanceof String) {
        return (String) value;
    } else {
        return value.toString();
    }
}
funcEND======================funcEND==============


func======================func==============
lang: kt
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
fun STR(value: Any): String {
    return when (value) {
        is Int -> value.toString()
        is Long -> value.toString()
        is Float -> value.toString()
        is Double -> value.toString()
        is Boolean -> if (value) "1" else "0"
        is String -> value
        else -> value.toString()
    }
}
funcEND======================funcEND==============


func======================func==============
lang: rb
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
def STR(value)
  if value.is_a?(Integer) || value.is_a?(Float)
    return value.to_s
  elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
    return value ? "1" : "0"
  elsif value.is_a?(String)
    return value
  else
    return value.to_s
  end
end

funcEND======================funcEND==============

func======================func==============
lang: nim
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
proc STR(value: auto): string =
  when value is int | int64 | float | float64:
    return $value
  elif value is bool:
    return if value: "1" else: "0"
  elif value is cstring:
    return $value
  else:
    return $value
funcEND======================funcEND==============

func======================func==============
lang: ahk
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
STR(value) {
    return value
}
funcEND======================funcEND==============


func======================func==============
lang: swift
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
func STR(_ value: Any) -> String {
    if let value = value as? Int {
        return String(value)
    } else if let value = value as? Float {
        return String(value)
    } else if let value = value as? Double {
        return String(value)
    } else if let value = value as? Bool {
        return value ? "1" : "0"
    } else if let value = value as? String {
        return value
    } else {
        return "\(value)"
    }
}
funcEND======================funcEND==============


func======================func==============
lang: dart
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
String STR(dynamic value) {
  if (value is int || value is double || value is num) {
    return value.toString();
  } else if (value is bool) {
    return value ? "1" : "0";
  } else if (value is String) {
    return value;
  } else {
    return value.toString();
  }
}
funcEND======================funcEND==============

func======================func==============
lang: ts
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
function STR(value: any): string {
    if (typeof value === "number") {
        return value.toString();
    } else if (typeof value === "boolean") {
        return value ? "1" : "0";
    } else if (typeof value === "string") {
        return value;
    } else {
        return String(value);
    }
}
funcEND======================funcEND==============



func======================func==============
lang: groovy
name: STR
libs: null
description: string~~~Converts a given value (number, boolean, or existing string) into its string representation. For booleans, `true` becomes "1" and `false` becomes "0" (or language equivalent). Helpful for concatenation or when a string is explicitly needed.~~~Here is how to use it:~~~```htvm~~~int num := 123~~~str strNum := STR(num)~~~print("STR(123) = '" . strNum . "'")~~~; Expected: '123'~~~if (strNum != "123") {~~~    print("STR int test FAILED!")~~~}~~~; ----------------------------------------------------~~~float flt := -45.67~~~str strFlt := STR(flt)~~~print("STR(-45.67) = '" . strFlt . "'")~~~; Expected: '-45.67' (or similar float string)~~~if (strFlt != "-45.67") {~~~    print("STR float test FAILED!")~~~}~~~; ----------------------------------------------------~~~bool bTrue := true~~~str strTrue := STR(bTrue)~~~print("STR(true) = '" . strTrue . "'")~~~; Expected: '1' (or 'true')~~~if (strTrue != "1" and strTrue != "true") {~~~    print("STR true test FAILED! Got: " . strTrue)~~~}~~~; ----------------------------------------------------~~~bool bFalse := false~~~str strFalse := STR(bFalse)~~~print("STR(false) = '" . strFalse . "'")~~~; Expected: '0' (or 'false')~~~if (strFalse != "0" and strFalse != "false") {~~~    print("STR false test FAILED! Got: " . strFalse)~~~}~~~; ----------------------------------------------------~~~str existingStr := "already_string"~~~str strExisting := STR(existingStr)~~~print("STR('already_string') = '" . strExisting . "'")~~~; Expected: 'already_string'~~~if (strExisting != "already_string") {~~~    print("STR existing string test FAILED!")~~~}~~~```~~~
// Convert various types to String
String STR(int value) {
    return value.toString()
}

// Convert various types to String
String STR(long value) {
    return value.toString()
}

String STR(float value) {
    return value.toString()
}

String STR(double value) {
    return value.toString()
}

String STR(boolean value) {
    return value ? "1" : "0"
}

String STR(String value) {
    return value
}
funcEND======================funcEND==============


func======================func==============
lang: cpp
name: FLOAT
libs: #include <string>|#include <sstream>
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
// Convert std::string to float
float FLOAT(const std::string& str) {
    std::istringstream iss(str);
    float value;
    iss >> value;
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: InStr
libs: #include <string>
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
// Function to find the position of needle in haystack (std::string overload)
int InStr(const std::string& haystack, const std::string& needle) {
    size_t pos = haystack.find(needle);
    return (pos != std::string::npos) ? static_cast<int>(pos) + 1 : 0;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Random
libs: #include <cstdlib>|#include <ctime>|#include <random>
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
int Random(int min, int max) {
    // Create a random device to seed the generator
    std::random_device rd;

    // Create a generator seeded with the random device
    std::mt19937 gen(rd());

    // Define a distribution within the specified range
    std::uniform_int_distribution<> dis(min, max);

    // Generate and return a random number within the specified range
    return dis(gen);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sleep
libs: #include <thread>|#include <chrono>
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
// Function to sleep for a specified number of milliseconds
void Sleep(int milliseconds) {
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: input
libs: #include <iostream>|#include <string>
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
// Function to get input from the user, similar to Python's input() function
std::string input(const std::string& prompt) {
    std::string userInput;
    std::cout << prompt; // Display the prompt to the user
    std::getline(std::cin, userInput); // Get the entire line of input
    return userInput;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileRead
libs: #include <fstream>|#include <string>|#include <filesystem>|#include <stdexcept>
description: file~~~Reads the entire content of a file specified by `path` (string) and returns it as a string. If the file doesn't exist or cannot be read, it may throw an error or return an empty/special value depending on the language. Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str filePath := "test_read_file.txt"~~~str fileContentToWrite := "Hello from HTVM FileRead test!`nLine 2."~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileRead is not available in standard JS. Skipping test.")~~~} else {~~~    ; Create a file with known content~~~    FileAppend(fileContentToWrite, filePath)~~~    if (FileExist(filePath) = true) {~~~        print("Test file '" . filePath . "' created with content.")~~~        str readContent := FileRead(filePath)~~~        print("Content read from '" . filePath . "':`n" . readContent)~~~~~~        ; Normalize newlines for comparison as different OS might handle them differently.~~~        str normalizedRead := StrReplace(Trim(readContent), "`r`n", "`n")~~~        str normalizedExpected := StrReplace(Trim(fileContentToWrite), "`r`n", "`n")~~~~~~        if (normalizedRead = normalizedExpected) {~~~            print("FileRead test PASSED.")~~~        } else {~~~            print("FileRead test FAILED! Content mismatch.")~~~            print("Expected: '" . normalizedExpected . "'")~~~            print("Got     : '" . normalizedRead . "'")~~~        }~~~        ; Cleanup~~~        FileDelete(filePath)~~~    } else {~~~        print("Could not create test file for FileRead.")~~~    }~~~}~~~```~~~
std::string FileRead(const std::string& path) {
    std::ifstream file;
    std::filesystem::path full_path;
    // Check if the file path is an absolute path
    if (std::filesystem::path(path).is_absolute()) {
        full_path = path;
    } else {
        // If it's not a full path, prepend the current working directory
        full_path = std::filesystem::current_path() / path;
    }
    // Open the file
    file.open(full_path);
    if (!file.is_open()) {
        throw std::runtime_error("Error: Could not open the file.");
    }
    // Read the file content into a string
    std::string content;
    std::string line;
    while (std::getline(file, line)) {
        content += line + '\n';
    }
    file.close();
    return content;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileAppend
libs: #include <fstream>|#include <iostream>|#include <string>|#include <filesystem>
description: file~~~Appends `content` (string) to a file specified by `path` (string). Creates the file if it doesn't exist. Returns a boolean indicating success (true) or failure (false). Not available in standard browser JavaScript due to security restrictions; use `FileAppendJs` for browser downloads.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment where file system access is permitted.~~~str filePath := "test_append.txt"~~~str content1 := "First line for test_append.txt`n"~~~bool success1 := FileAppend(content1, filePath)~~~print("Append 1 to '" . filePath . "' success: " . STR(success1))~~~if (success1 = false and HTVM_getLang_HTVM() != "js") {~~~    print("FileAppend test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str content2 := "Second line, appended.`n"~~~bool success2 := FileAppend(content2, filePath)~~~print("Append 2 to '" . filePath . "' success: " . STR(success2))~~~if (success2 = false and HTVM_getLang_HTVM() != "js") {~~~    print("FileAppend test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Optionally, read back and verify (if FileRead is available and working)~~~if (FileExist(filePath) = true and HTVM_getLang_HTVM() != "js") {~~~    str fileContent := FileRead(filePath)~~~    print("Content of '" . filePath . "':`n" . fileContent)~~~    str expectedContent := content1 . content2~~~    if (Trim(fileContent) != Trim(expectedContent)) {~~~        print("FileAppend content verification FAILED!")~~~    } else {~~~        print("FileAppend content verification PASSED.")~~~    }~~~    ; Clean up the test file~~~    FileDelete(filePath)~~~    print("Test file '" . filePath . "' deleted.")~~~} else if (HTVM_getLang_HTVM() = "js") {~~~    print("FileAppend is not available in standard JS. Use FileAppendJs for browser downloads.")~~~}~~~```~~~
bool FileAppend(const std::string& content, const std::string& path) {
    std::ofstream file;
    // Open the file in append mode
    file.open(path, std::ios::app);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open the file for appending." << std::endl;
        return false;
    }
    // Append the content to the file
    file << content;
    // Close the file
    file.close();
    return true;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileDelete
libs: #include <fstream>|#include <iostream>|#include <string>|#include <filesystem>
description: file~~~Deletes a file specified by `path` (string). Returns a boolean indicating success (true) or failure (false, e.g., if the file doesn't exist or due to permissions). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str filePath := "file_to_delete.txt"~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileDelete is not available in standard JS. Skipping test.")~~~} else {~~~    ; Create a dummy file to delete~~~    FileAppend("Temporary content.", filePath)~~~    if (FileExist(filePath) = true) {~~~        print("Dummy file '" . filePath . "' created for deletion test.")~~~        bool deleteSuccess := FileDelete(filePath)~~~        print("Deletion of '" . filePath . "' success: " . STR(deleteSuccess))~~~        if (deleteSuccess = true and FileExist(filePath) = false) {~~~            print("FileDelete test PASSED.")~~~        } else {~~~            print("FileDelete test FAILED! File still exists or deletion reported failure.")~~~        }~~~    } else {~~~        print("Could not create dummy file for FileDelete test.")~~~    }~~~    ; Test deleting a non-existent file~~~    str nonExistentFile := "surely_this_does_not_exist.txt"~~~    bool deleteNonExistentSuccess := FileDelete(nonExistentFile)~~~    print("Attempting to delete non-existent file '" . nonExistentFile . "'. Success: " . STR(deleteNonExistentSuccess))~~~    if (deleteNonExistentSuccess = false) {~~~        print("FileDelete non-existent file test PASSED (reported failure as expected).")~~~    } else {~~~        print("FileDelete non-existent file test FAILED! (Reported success for non-existent file).")~~~    }~~~}~~~```~~~
bool FileDelete(const std::string& path) {
    std::filesystem::path file_path(path);
    // Check if the file exists
    if (!std::filesystem::exists(file_path)) {
        return false;
    }
    // Attempt to remove the file
    if (!std::filesystem::remove(file_path)) {
        return false;
    }
    return true;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrLen
libs: #include <string>
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
size_t StrLen(const std::string& str) {
    return str.length();
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Asc
libs: #include <string>
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
int Asc(const std::string& str) {
    if (!str.empty()) {
        return static_cast<int>(str[0]);
    }
    return -1; // Return -1 if the string is empty
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Abs
libs: #include <string>
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
int Abs(int value) {
    return std::abs(value);
}

float Abs(float value) {
    return std::fabs(value);
}

double Abs(double value) {
    return std::fabs(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ACos
libs: #include <cmath>
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~

// For float input
float ACos(float value) {
    return acosf(value);
}

// For double input
double ACos(double value) {
    return std::acos(value);
}

// For long double input
long double ACos(long double value) {
    return acosl(value);
}

// For int input, convert to double first
double ACos(int value) {
    return std::acos(static_cast<double>(value));
}


funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ASin
libs: #include <cmath>
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
// For float input
float ASin(float value) {
    if (value < -1.0f || value > 1.0f) {
        std::cerr << "Error: Value out of range for arcsine function." << std::endl;
        return NAN;
    }
    return asinf(value);
}

// For double input
double ASin(double value) {
    if (value < -1.0 || value > 1.0) {
        std::cerr << "Error: Value out of range for arcsine function." << std::endl;
        return NAN;
    }
    return asin(value);
}

// For long double input
long double ASin(long double value) {
    if (value < -1.0L || value > 1.0L) {
        std::cerr << "Error: Value out of range for arcsine function." << std::endl;
        return NAN;
    }
    return asinl(value);
}

// For int input, convert to double
double ASin(int value) {
    double dval = static_cast<double>(value);
    if (dval < -1.0 || dval > 1.0) {
        std::cerr << "Error: Value out of range for arcsine function." << std::endl;
        return NAN;
    }
    return asin(dval);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ATan
libs: #include <cmath>
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
// For float input
float ATan(float value) {
    return atanf(value);
}

// For double input
double ATan(double value) {
    return std::atan(value);
}

// For long double input
long double ATan(long double value) {
    return atanl(value);
}

// For int input, convert to double
double ATan(int value) {
    return std::atan(static_cast<double>(value));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Ceil
libs: #include <cmath>
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
// For float input
float Ceil(float value) {
    return ceilf(value);
}

// For double input
double Ceil(double value) {
    return std::ceil(value);
}

// For long double input
long double Ceil(long double value) {
    return ceill(value);
}

// For int input, just return the int itself (ceiling of int is int)
int Ceil(int value) {
    return value;
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Cos
libs: #include <cmath>
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~


// For float input
float Cos(float angle) {
    return cosf(angle);
}
// For double input
double Cos(double angle) {
    return std::cos(angle);
}
// For long double input
long double Cos(long double angle) {
    return cosl(angle);
}
// For int input, convert to double
double Cos(int angle) {
    return std::cos(static_cast<double>(angle));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Exp
libs: #include <cmath>
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~

// For float input
float Exp(float value) {
    return expf(value);
}

// For double input
double Exp(double value) {
    return std::exp(value);
}

// For long double input
long double Exp(long double value) {
    return expl(value);
}

// For int input, convert to double
double Exp(int value) {
    return std::exp(static_cast<double>(value));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Ln
libs: #include <cmath>
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
// For float input
float Ln(float value) {
    return logf(value);
}

// For double input
double Ln(double value) {
    return std::log(value);
}

// For long double input
long double Ln(long double value) {
    return logl(value);
}

// For int input, convert to double
double Ln(int value) {
    return std::log(static_cast<double>(value));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Log
libs: #include <cmath>
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
// For float input
float Log(float value) {
    return log10f(value);
}

// For double input
double Log(double value) {
    return std::log10(value);
}

// For long double input
long double Log(long double value) {
    return log10l(value);
}

// For int input, convert to double
double Log(int value) {
    return std::log10(static_cast<double>(value));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Round
libs: #include <cmath>
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
// For float input
float Round(float value) {
    return roundf(value);
}

// For double input
double Round(double value) {
    return std::round(value);
}

// For long double input
long double Round(long double value) {
    return roundl(value);
}

// For int input, rounding an int is just the int itself
int Round(int value) {
    return value;
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sin
libs: #include <cmath>
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
// For float input
float Sin(float angle) {
    return sinf(angle);
}

// For double input
double Sin(double angle) {
    return std::sin(angle);
}

// For long double input
long double Sin(long double angle) {
    return sinl(angle);
}

// For int input, convert to double
double Sin(int angle) {
    return std::sin(static_cast<double>(angle));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sqrt
libs: #include <cmath>
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
// For float input
float Sqrt(float value) {
    return sqrtf(value);
}

// For double input
double Sqrt(double value) {
    return std::sqrt(value);
}

// For long double input
long double Sqrt(long double value) {
    return sqrtl(value);
}

// For int input, convert to double
double Sqrt(int value) {
    return std::sqrt(static_cast<double>(value));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Tan
libs: #include <cmath>
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
// For float input
float Tan(float angle) {
    return tanf(angle);
}

// For double input
double Tan(double angle) {
    return std::tan(angle);
}

// For long double input
long double Tan(long double angle) {
    return tanl(angle);
}

// For int input, convert to double
double Tan(int angle) {
    return std::tan(static_cast<double>(angle));
}

funcEND======================funcEND==============
func======================func==============
lang: cpp
name: SubStr
libs: #include <string>
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~


std::string SubStr(const std::string& str, int startPos, int length = -1) {
    std::string result;
    size_t strLen = str.size();

    // Handle negative starting positions (counting from the end)
    if (startPos < 0) {
        startPos = strLen + startPos;
        if (startPos < 0) startPos = 0;  // Ensure it doesn't go beyond the start of the string
    }
    else {
        startPos -= 1; // Convert to 0-based index for internal operations
    }

    // Handle length
    if (length < 0) {
        length = strLen - startPos; // Length to the end of the string
    } else if (startPos + length > static_cast<int>(strLen)) {
        length = strLen - startPos; // Adjust length to fit within the string
    }

    // Extract the substring
    result = str.substr(startPos, length);
    return result;
}


funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Trim
libs: #include <string>
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
std::string Trim(const std::string &inputString) {
    if (inputString.empty()) return "";
    size_t start = inputString.find_first_not_of(" \t\n\r\f\v");
    size_t end = inputString.find_last_not_of(" \t\n\r\f\v");
    return (start == std::string::npos) ? "" : inputString.substr(start, end - start + 1);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrReplace
libs: #include <string>
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
std::string StrReplace(const std::string &originalString, const std::string &find, const std::string &replaceWith) {
    std::string result = originalString;
    size_t pos = 0;
    while ((pos = result.find(find, pos)) != std::string::npos) {
        result.replace(pos, find.length(), replaceWith);
        pos += replaceWith.length();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StringTrimLeft
libs: #include <string>
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
std::string StringTrimLeft(const std::string &input, int numChars) {
    return (numChars <= input.length()) ? input.substr(numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StringTrimRight
libs: #include <string>
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
std::string StringTrimRight(const std::string &input, int numChars) {
    return (numChars <= input.length()) ? input.substr(0, input.length() - numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrLower
libs: #include <algorithm>|#include <cctype>|#include <string>
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
std::string StrLower(const std::string &string) {
    std::string result = string;
    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrSplit
libs: #include <string>
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
std::string StrSplit(const std::string &inputStr, const std::string &delimiter, int num) {
    size_t start = 0, end = 0, count = 0;
    while ((end = inputStr.find(delimiter, start)) != std::string::npos) {
        if (++count == num) {
            return inputStr.substr(start, end - start);
        }
        start = end + delimiter.length();
    }
    if (count + 1 == num) {
        return inputStr.substr(start);
    }
    return "";
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Chr
libs: #include <string>
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
std::string Chr(int number) {
    return (number >= 0 && number <= 0x10FFFF) ? std::string(1, static_cast<char>(number)) : "";
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Mod
libs: #include <string>
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
int Mod(int dividend, int divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Floor
libs: #include <cmath>|#include <limits>
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
double Floor(double num) {
    if (std::isnan(num)) {
        return std::numeric_limits<double>::quiet_NaN();
    }
    return std::floor(num);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sort
libs: #include <string>|#include <vector>|#include <algorithm>|#include <sstream>|#include <unordered_set>|#include <cctype>
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
// Helper function to trim whitespace from both ends of a string
std::string trim(const std::string& str) {
    const std::string whitespace = " \t\n\r\f\v";
    size_t start = str.find_first_not_of(whitespace);
    if (start == std::string::npos) return "";
    size_t end = str.find_last_not_of(whitespace);
    return str.substr(start, end - start + 1);
}
// Helper function to convert string to lowercase
std::string toLower(const std::string& str) {
    std::string lowerStr = str;
    std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
    return lowerStr;
}
// Function to sort case-insensitively but ensure lowercase items come last
bool customSortCompare(const std::string& a, const std::string& b) {
    std::string lowerA = toLower(a);
    std::string lowerB = toLower(b);
    if (lowerA == lowerB) {
        // If case-insensitive equivalent, ensure lowercase items come last
        if (std::islower(a[0]) && std::isupper(b[0])) {
            return false; // a should come after b
        } else if (std::isupper(a[0]) && std::islower(b[0])) {
            return true; // a should come before b
        }
        return a < b; // Otherwise, sort lexicographically
    }
    return lowerA < lowerB;
}
// Function to remove exact duplicates (case-sensitive)
std::vector<std::string> removeExactDuplicates(const std::vector<std::string>& items) {
    std::unordered_set<std::string> seen;
    std::vector<std::string> uniqueItems;
    for (const auto& item : items) {
        if (seen.find(item) == seen.end()) {
            seen.insert(item);
            uniqueItems.push_back(item);
        }
    }
    return uniqueItems;
}
// Main sorting function
std::string Sort(const std::string& input, const std::string& options) {
    std::string delimiter = "\n";
    bool caseInsensitive = options.find('C') != std::string::npos;
    bool unique = options.find('U') != std::string::npos;
    bool reverse = options.find('R') != std::string::npos;
    bool random = options.find("Random") != std::string::npos;
    bool numeric = options.find('N') != std::string::npos;
    // Custom delimiter
    if (options.find('D') != std::string::npos) {
        size_t delimiterPos = options.find('D') + 1;
        if (delimiterPos < options.size()) {
            delimiter = options.substr(delimiterPos, 1);
        }
    }
    // Split input by delimiter
    std::vector<std::string> items;
    std::stringstream ss(input);
    std::string item;
    while (std::getline(ss, item, delimiter[0])) {
        item = trim(item);  // Trim whitespace from each item
        if (!item.empty()) {
            items.push_back(item);
        }
    }
    // Sort items
    if (numeric) {
        std::sort(items.begin(), items.end(), [](const std::string& a, const std::string& b) {
            return std::stoi(a) < std::stoi(b);
        });
    } else {
        std::sort(items.begin(), items.end(), customSortCompare);
    }
    // Remove exact duplicates if needed
    if (unique) {
        items = removeExactDuplicates(items);
    }
    // Apply reverse order if needed
    if (reverse) {
        std::reverse(items.begin(), items.end());
    }
    // Separate uppercase and lowercase items
    std::vector<std::string> uppercaseItems;
    std::vector<std::string> lowercaseItems;

    for (const auto& item : items) {
        if (std::isupper(item[0])) {
            uppercaseItems.push_back(item);
        } else {
            lowercaseItems.push_back(item);
        }
    }
    // Combine sorted uppercase items with sorted lowercase items
    std::string result;
    for (const auto& item : uppercaseItems) {
        result += item;
        result += delimiter;
    }
    for (const auto& item : lowercaseItems) {
        result += item;
        if (&item != &lowercaseItems.back()) {
            result += delimiter;
        }
    }
    // Remove trailing delimiter if necessary
    if (!result.empty() && result.back() == delimiter[0]) {
        result.pop_back();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: getDataFromAPI
libs: #include <string>|#include <array>|#include <memory>|#include <stdexcept>| #include <cstdio>
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
// Function to run a system command
std::string getDataFromAPIRunCMD(const std::string& command) {
    std::array<char, 128> buffer;
    std::string result;
#if defined(_WIN32)
    std::unique_ptr<FILE, decltype(&_pclose)> pipe(_popen(command.c_str(), "r"), _pclose);
#else
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
#endif
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}
// Function to fetch data from API
std::string getDataFromAPI(const std::string& url) {
    std::string command = "curl -s " + url;
    return getDataFromAPIRunCMD(command);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileCreateDir
libs: #include <filesystem>|#include <system_error>
description: file~~~Creates a new directory specified by `path` (string). If the directory already exists, it usually does nothing. If intermediate directories in the path do not exist, their creation might depend on the target language's implementation (some create them, some require them to exist). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str dirPath := "test_htvm_dir"~~~print("Attempting to create directory: '" . dirPath . "'")~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileCreateDir is not available in standard JS. Skipping test.")~~~} else {~~~    FileCreateDir(dirPath)~~~    if (FileExist(dirPath) = true) {~~~        print("Directory '" . dirPath . "' created or already existed. PASSED.")~~~        ; Clean up~~~        FileRemoveDir(dirPath)~~~        if (FileExist(dirPath) = false) {~~~            print("Test directory '" . dirPath . "' cleaned up successfully.")~~~        } else {~~~            print("Cleanup of '" . dirPath . "' FAILED.")~~~        }~~~    } else {~~~        print("FileCreateDir test FAILED! Directory not found after creation attempt.")~~~    }~~~    ; ----------------------------------------------------~~~    str nestedDirPath := "parent_dir/child_dir"~~~    print("Attempting to create nested directory: '" . nestedDirPath . "'")~~~    ; Behavior for non-existent 'parent_dir' varies.~~~    FileCreateDir(nestedDirPath)~~~    if (FileExist(nestedDirPath) = true) {~~~        print("Nested directory '" . nestedDirPath . "' creation attempt finished. Check if it exists.")~~~        ; Try to clean up child~~~        FileRemoveDir(nestedDirPath)~~~        ; Try to clean up parent~~~        FileRemoveDir("parent_dir")~~~    } else {~~~        print("Nested directory '" . nestedDirPath . "' not found. This might be expected if parent was not auto-created.")~~~    }~~~}~~~```~~~
// Creates a directory if it does not exist
void FileCreateDir(const std::string& path) {
    try {
        std::filesystem::create_directory(path);
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileRemoveDir
libs: #include <filesystem>|#include <system_error>
description: file~~~Removes a directory specified by `path` (string). If the directory contains files or subdirectories, their removal depends on the target language's implementation (some remove recursively, some fail if not empty). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str dirPath := "dir_to_remove"~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileRemoveDir is not available in standard JS. Skipping test.")~~~} else {~~~    ; Test 1: Remove an empty directory~~~    FileCreateDir(dirPath)~~~    if (FileExist(dirPath) = true) {~~~        print("Directory '" . dirPath . "' created for removal test.")~~~        FileRemoveDir(dirPath)~~~        if (FileExist(dirPath) = false) {~~~            print("FileRemoveDir test 1 (empty dir) PASSED.")~~~        } else {~~~            print("FileRemoveDir test 1 (empty dir) FAILED! Directory still exists.")~~~        }~~~    } else {~~~        print("Could not create directory for FileRemoveDir test 1.")~~~    }~~~~~~    print("--------------------")~~~~~~    ; Test 2: Attempt to remove a directory that might have content (behavior can vary)~~~    str nestedDirPath := "parent_for_remove/child_for_remove"~~~    ; Creates parent/child potentially~~~    FileCreateDir(nestedDirPath) ~~~    FileAppend("dummy", nestedDirPath . "/file.txt")~~~    if (FileExist(nestedDirPath) = true) {~~~        print("Nested directory with file created: '" . nestedDirPath . "'")~~~        ; Attempt to remove parent~~~        FileRemoveDir("parent_for_remove") ~~~        if (FileExist("parent_for_remove") = false) {~~~            print("FileRemoveDir test 2 (potentially non-empty parent) PASSED (removed).")~~~        } else {~~~            print("FileRemoveDir test 2 (potentially non-empty parent) FAILED or partially failed. Check if 'parent_for_remove' still exists.")~~~            ; Cleanup if needed and possible~~~            FileRemoveDir(nestedDirPath)~~~            FileRemoveDir("parent_for_remove")~~~        }~~~    } else {~~~        print("Could not create nested directory for FileRemoveDir test 2.")~~~    }~~~}~~~```~~~
// Removes a directory if it exists
void FileRemoveDir(const std::string& path) {
    try {
        if (std::filesystem::exists(path) && std::filesystem::is_directory(path)) {
            std::filesystem::remove_all(path);
        }
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileExist
libs: #include <filesystem>|#include <system_error>
description: file~~~Checks if a file or directory exists at the specified `path` (string). Returns `true` if it exists, `false` otherwise. Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~; Placeholder, will attempt to use the script's own file if GetParams works.~~~str existingFilePath := ""~~~str nonExistentPath := "this_path_should_not_exist_12345.xyz"~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileExist is not available in standard JS. Skipping test.")~~~} else {~~~    ; Try to get path of the current script or a known file for a positive test~~~    ; This part is a bit tricky without knowing the execution context.~~~    ; For a simple test, we'll create and check a temporary file.~~~    str tempFileForExistTest := "temp_exist_test.txt"~~~    FileAppend("check", tempFileForExistTest)~~~    bool check1 := FileExist(tempFileForExistTest)~~~    print("FileExist('" . tempFileForExistTest . "') = " . STR(check1))~~~    if (check1 = true) {~~~        print("FileExist test 1 (existing file) PASSED.")~~~    } else {~~~        print("FileExist test 1 (existing file) FAILED!")~~~    }~~~    ; Cleanup~~~    FileDelete(tempFileForExistTest)~~~    bool check2 := FileExist(nonExistentPath)~~~    print("FileExist('" . nonExistentPath . "') = " . STR(check2))~~~    if (check2 = false) {~~~        print("FileExist test 2 (non-existent path) PASSED.")~~~    } else {~~~        print("FileExist test 2 (non-existent path) FAILED!")~~~    }~~~    ; Test with a directory~~~    str tempDirForExistTest := "temp_dir_exist_test"~~~    FileCreateDir(tempDirForExistTest)~~~    bool check3 := FileExist(tempDirForExistTest)~~~    print("FileExist('" . tempDirForExistTest . "' as directory) = " . STR(check3))~~~    if (check3 = true) {~~~        print("FileExist test 3 (existing directory) PASSED.")~~~    } else {~~~        print("FileExist test 3 (existing directory) FAILED!")~~~    }~~~    ; Cleanup~~~    FileRemoveDir(tempDirForExistTest)~~~}~~~```~~~
// Checks if a file or directory exists
bool FileExist(const std::string& path) {
    try {
        return std::filesystem::exists(path);
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently; return false if an error occurs
        return false;
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: isWindows
libs: #include <iostream>
description: other~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
// Function to check if the operating system is Windows
bool isWindows() {
    #ifdef _WIN32
        return true;
    #else
        return false;
    #endif
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: GetParams
libs: #include <iostream>|#include <vector>|#include <string>|#include <filesystem>
description: io~~~Retrieves command-line arguments passed to the script. Returns them as a single string, with each argument typically on a new line, or formatted as absolute paths if they correspond to existing files/directories. Behavior and availability vary significantly by environment (e.g., not applicable in browsers).~~~Here is how to use it:~~~```htvm~~~; This function's output depends on how the script is executed with command-line arguments.~~~; For testing, you would run the compiled HTVM script like:~~~; (e.g., if Python) python your_script.py arg1 "argument two" path/to/a/file.txt~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("GetParams is typically not applicable in standard JS browser environments. Skipping direct test.")~~~} else {~~~    print("Retrieving command line parameters...")~~~    str allParams := GetParams()~~~    if (allParams = "") {~~~        print("No command line parameters were provided to the script, or function not fully supported in this context.")~~~    } else {~~~        print("Command Line Parameters Received:")~~~        print(allParams)~~~        print("--- End of Parameters ---")~~~        ; A simple "test" is to check if it returned something if args were expected.~~~        ; This requires manual verification by running with args.~~~        print("GetParams test: Review the output above. If you passed arguments, they should appear here.")~~~    }~~~}~~~; Example of how you might parse it in HTVM if it returns newline-separated args:~~~arr str paramsArray~~~if (allParams != "") {~~~    Loop, Parse, allParams, `n, `r {~~~        print("Param " . STR(A_Index + 1) . ": " . A_LoopField)~~~        if (A_LoopField != "") {~~~            paramsArray.add(A_LoopField) ~~~        }~~~    }~~~    print("Parsed first param (if any): " . paramsArray[0])~~~}~~~```~~~
#ifdef _WIN32
    #define ARGC __argc
    #define ARGV __argv
#else
    extern char **environ;
    int ARGC;
    char** ARGV;
    __attribute__((constructor)) void init_args(int argc, char* argv[], char* envp[]) {
        ARGC = argc;
        ARGV = argv;
    }
#endif
std::string GetParams() {
    std::vector<std::string> params;
    for (int i = 1; i < ARGC; ++i) {
        std::string arg = ARGV[i];
        if (std::filesystem::exists(arg)) {
            arg = std::filesystem::absolute(arg).string();
        }
        params.push_back(arg);
    }
    std::string result;
    for (const auto& param : params) {
        result += param + "\n";
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: BuildInVars
libs: #include <iostream>|#include <chrono>|#include <ctime>|#include <sstream>|#include <iomanip>|#include <string>|#include <limits>
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
// Store the start time as a global variable
std::chrono::time_point<std::chrono::steady_clock> programStartTime = std::chrono::steady_clock::now();
// Function to get built-in variables
std::string BuildInVars(const std::string& varName) {
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm* localTime = std::localtime(&currentTime);
    std::ostringstream oss;
    if (varName == "A_TickCount") {
        // Calculate milliseconds since program start
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - programStartTime).count();
        if (duration > std::numeric_limits<int>::max()) {
            // Handle overflow case
            return "Value too large";
        } else {
            return std::to_string(static_cast<int>(duration));
        }
    } else if (varName == "A_Now") {
        oss << std::put_time(localTime, "%Y-%m-%d %H:%M:%S");
    } else if (varName == "A_YYYY") {
        oss << std::put_time(localTime, "%Y");
    } else if (varName == "A_MM") {
        oss << std::put_time(localTime, "%m");
    } else if (varName == "A_DD") {
        oss << std::put_time(localTime, "%d");
    } else if (varName == "A_MMMM") {
        oss << std::put_time(localTime, "%B");
    } else if (varName == "A_MMM") {
        oss << std::put_time(localTime, "%b");
    } else if (varName == "A_DDDD") {
        oss << std::put_time(localTime, "%A");
    } else if (varName == "A_DDD") {
        oss << std::put_time(localTime, "%a");
    } else if (varName == "A_Hour") {
        oss << std::put_time(localTime, "%H");
    } else if (varName == "A_Min") {
        oss << std::put_time(localTime, "%M");
    } else if (varName == "A_Sec") {
        oss << std::put_time(localTime, "%S");
    } else if (varName == "A_Space") {
        return " ";
    } else if (varName == "A_Tab") {
        return "\t";
    } else {
        return "";
    }
    return oss.str();
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RegExReplace
libs: #include <string>|#include <regex>|#include <iostream>
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
std::string RegExReplace(const std::string& inputStr, const std::string& regexPattern, const std::string& replacement) {
    std::regex re(regexPattern, std::regex_constants::ECMAScript | std::regex_constants::multiline);
    return std::regex_replace(inputStr, re, replacement);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RunCMD
libs: #include <iostream>|#include <stdexcept>|#include <string>|#include <array>|#include <memory>|#include <cstdio>
description: io~~~Executes a system command (shell command) and returns its standard output as a string. Error output might also be captured or cause an error depending on the implementation. Highly environment-dependent and not available in browsers.~~~Here is how to use it:~~~```htvm~~~; This function is highly dependent on the OS and environment.~~~; Not available in browser JS.~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("RunCMD is not available in standard JS browser environments. Skipping test.")~~~} else {~~~    str command := ""~~~    ; Assuming isWindows() built-in exists and works~~~    bool isWin := isWindows() ~~~~~~    if (isWin = true) {~~~        command := "echo Hello from HTVM on Windows"~~~    } else {~~~        ; Single quotes for Unix echo~~~        command := "echo 'Hello from HTVM on Unix-like'" ~~~    }~~~    print("Executing command: " . command)~~~    str output := RunCMD(command)~~~    print("Output from command:")~~~    ; Trim to remove trailing newline from echo~~~    print(Trim(output))~~~~~~    if (isWin = true and Trim(output) = "Hello from HTVM on Windows") {~~~        print("RunCMD test (Windows echo) PASSED.")~~~    } else if (isWin = false and Trim(output) = "Hello from HTVM on Unix-like") {~~~        print("RunCMD test (Unix echo) PASSED.")~~~    } else if (command != "") {~~~        print("RunCMD test FAILED or OS detection mismatch. Output was: '" . Trim(output) . "'")~~~    } else {~~~        print("RunCMD test skipped as command was empty.")~~~    }~~~~~~    ; Example of a command that might list files (OS-dependent)~~~    str listCommand := ""~~~    if (isWin = true) { listCommand := "dir /b" ~~~    } else {~~~        listCommand := "ls -a" ~~~    }~~~    print("---")~~~    print("Attempting to list files with: " . listCommand)~~~    str fileListOutput := RunCMD(listCommand)~~~    print("File list output (first 200 chars): " . SubStr(fileListOutput, 1, 200) . "...")~~~    if (StrLen(fileListOutput) > 0) {~~~        print("RunCMD (list files) seems to have executed and produced output.")~~~    } else {~~~        print("RunCMD (list files) produced no output or failed.")~~~    }~~~}~~~```~~~
std::string RunCMD(const std::string& command) {
    std::array<char, 128> buffer;
    std::string result;
#if defined(_WIN32)
    std::unique_ptr<FILE, decltype(&_pclose)> pipe(_popen(command.c_str(), "r"), _pclose);
#else
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
#endif
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RegExMatch
libs: #include <regex>|#include <string>|#include <iostream>
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
int RegExMatch(const std::string& haystack, const std::string& needle) {
    std::regex re(needle);
    std::smatch match;
    if (std::regex_search(haystack, match, re)) {
        return match.position(0) + 1; // 1-based index
    }
    return 0; // No match
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ExitApp
libs: #include <iostream>|#include <cstdlib>
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
void ExitApp() {
    std::exit(0);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
# Function to find the position of needle in haystack (str overload)
def InStr(haystack: str, needle: str) -> int:
    pos = haystack.find(needle)
    return pos + 1 if pos != -1 else 0
funcEND======================funcEND==============
func======================func==============
lang: js
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
// Function to find the position of needle in haystack (string overload)
function InStr(haystack, needle) {
    const pos = haystack.indexOf(needle);
    return (pos !== -1) ? pos + 1 : 0;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Random
libs: import random
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
def Random(min: int, max: int) -> int:
    # Generate and return a random number within the specified range
    return random.randint(min, max)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
// Function to generate a random integer between min and max (inclusive)
function Random(min, max) {
    // Generate and return a random number within the specified range
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sleep
libs: import time
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
def Sleep(milliseconds: int) -> None:
    # Sleep for the specified number of milliseconds
    time.sleep(milliseconds / 1000)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
function Sleep(milliseconds) {
    // Sleep for the specified number of milliseconds
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
// Function to simulate input() in JavaScript
function input(promptText) {
    // Display the prompt and get user input
    return prompt(promptText);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
# used imput func
funcEND======================funcEND==============
func======================func==============
lang: js
name: FileAppendJs
libs: null
description: file~~~(JavaScript Only - Browser) Initiates a file download in the browser with the given `content` (string) and `filename` (string). This is how file "saving" or "appending" is typically handled in a browser environment due to security restrictions on direct file system access.~~~Here is how to use it:~~~```htvm~~~; This function is specific to JavaScript running in a web browser.~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("Attempting to trigger download using FileAppendJs...")~~~    str fileContent := "This is content for the downloaded file.`n"~~~    str fileName := "downloaded_by_htvm.txt"~~~    FileAppendJs(fileContent, fileName)~~~    print("FileAppendJs called. If in a browser, a download for '" . fileName . "' should have started.")~~~    print("Note: This is a 'save as' operation, not a true append to an existing local file.")~~~    ; No direct way to "test" success other than observing browser behavior.~~~} else {~~~    print("FileAppendJs is only for JavaScript browser environments. Skipping test.")~~~}~~~```~~~
function FileAppendJs(content, filename) {
    // Create a Blob from the content
    const blob = new Blob([content], { type: 'text/plain' });
    const link = document.createElement('a');
    // Set the download attribute with the filename
    link.download = filename;
    link.href = URL.createObjectURL(blob);
    link.click();
    // Clean up the URL object
    URL.revokeObjectURL(link.href);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileDelete
libs: import os
description: file~~~Deletes a file specified by `path` (string). Returns a boolean indicating success (true) or failure (false, e.g., if the file doesn't exist or due to permissions). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str filePath := "file_to_delete.txt"~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileDelete is not available in standard JS. Skipping test.")~~~} else {~~~    ; Create a dummy file to delete~~~    FileAppend("Temporary content.", filePath)~~~    if (FileExist(filePath) = true) {~~~        print("Dummy file '" . filePath . "' created for deletion test.")~~~        bool deleteSuccess := FileDelete(filePath)~~~        print("Deletion of '" . filePath . "' success: " . STR(deleteSuccess))~~~        if (deleteSuccess = true and FileExist(filePath) = false) {~~~            print("FileDelete test PASSED.")~~~        } else {~~~            print("FileDelete test FAILED! File still exists or deletion reported failure.")~~~        }~~~    } else {~~~        print("Could not create dummy file for FileDelete test.")~~~    }~~~    ; Test deleting a non-existent file~~~    str nonExistentFile := "surely_this_does_not_exist.txt"~~~    bool deleteNonExistentSuccess := FileDelete(nonExistentFile)~~~    print("Attempting to delete non-existent file '" . nonExistentFile . "'. Success: " . STR(deleteNonExistentSuccess))~~~    if (deleteNonExistentSuccess = false) {~~~        print("FileDelete non-existent file test PASSED (reported failure as expected).")~~~    } else {~~~        print("FileDelete non-existent file test FAILED! (Reported success for non-existent file).")~~~    }~~~}~~~```~~~
def FileDelete(path: str) -> bool:
    # Check if the file exists and remove it
    if os.path.exists(path):
        os.remove(path)
        return True
    return False
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileAppend
libs: null
description: file~~~Appends `content` (string) to a file specified by `path` (string). Creates the file if it doesn't exist. Returns a boolean indicating success (true) or failure (false). Not available in standard browser JavaScript due to security restrictions; use `FileAppendJs` for browser downloads.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment where file system access is permitted.~~~str filePath := "test_append.txt"~~~str content1 := "First line for test_append.txt`n"~~~bool success1 := FileAppend(content1, filePath)~~~print("Append 1 to '" . filePath . "' success: " . STR(success1))~~~if (success1 = false and HTVM_getLang_HTVM() != "js") {~~~    print("FileAppend test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str content2 := "Second line, appended.`n"~~~bool success2 := FileAppend(content2, filePath)~~~print("Append 2 to '" . filePath . "' success: " . STR(success2))~~~if (success2 = false and HTVM_getLang_HTVM() != "js") {~~~    print("FileAppend test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Optionally, read back and verify (if FileRead is available and working)~~~if (FileExist(filePath) = true and HTVM_getLang_HTVM() != "js") {~~~    str fileContent := FileRead(filePath)~~~    print("Content of '" . filePath . "':`n" . fileContent)~~~    str expectedContent := content1 . content2~~~    if (Trim(fileContent) != Trim(expectedContent)) {~~~        print("FileAppend content verification FAILED!")~~~    } else {~~~        print("FileAppend content verification PASSED.")~~~    }~~~    ; Clean up the test file~~~    FileDelete(filePath)~~~    print("Test file '" . filePath . "' deleted.")~~~} else if (HTVM_getLang_HTVM() = "js") {~~~    print("FileAppend is not available in standard JS. Use FileAppendJs for browser downloads.")~~~}~~~```~~~
def FileAppend(content: str, path: str) -> bool:
    # Open the file in append mode and write the content
    try:
        with open(path, 'a') as file:
            file.write(content)
        return True
    except IOError:
        print("Error: Could not open the file for appending.")
        return False
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileRead
libs: import os
description: file~~~Reads the entire content of a file specified by `path` (string) and returns it as a string. If the file doesn't exist or cannot be read, it may throw an error or return an empty/special value depending on the language. Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str filePath := "test_read_file.txt"~~~str fileContentToWrite := "Hello from HTVM FileRead test!`nLine 2."~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileRead is not available in standard JS. Skipping test.")~~~} else {~~~    ; Create a file with known content~~~    FileAppend(fileContentToWrite, filePath)~~~    if (FileExist(filePath) = true) {~~~        print("Test file '" . filePath . "' created with content.")~~~        str readContent := FileRead(filePath)~~~        print("Content read from '" . filePath . "':`n" . readContent)~~~~~~        ; Normalize newlines for comparison as different OS might handle them differently.~~~        str normalizedRead := StrReplace(Trim(readContent), "`r`n", "`n")~~~        str normalizedExpected := StrReplace(Trim(fileContentToWrite), "`r`n", "`n")~~~~~~        if (normalizedRead = normalizedExpected) {~~~            print("FileRead test PASSED.")~~~        } else {~~~            print("FileRead test FAILED! Content mismatch.")~~~            print("Expected: '" . normalizedExpected . "'")~~~            print("Got     : '" . normalizedRead . "'")~~~        }~~~        ; Cleanup~~~        FileDelete(filePath)~~~    } else {~~~        print("Could not create test file for FileRead.")~~~    }~~~}~~~```~~~
def FileRead(path: str) -> str:
    # Check if the path is absolute, if not prepend the current working directory
    if not os.path.isabs(path):
        path = os.path.join(os.getcwd(), path)
    # Open and read the file content with utf-8 encoding to avoid decode errors
    with open(path, 'r', encoding='utf-8') as file:
        return file.read()
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
def StrLen(s: str) -> int:
    # Return the length of the given string
    return len(s)
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
function StrLen(s) {
    // Return the length of the given string
    return s.length;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
def Chr(number: int) -> str:
    # Return the character corresponding to the Unicode code point, or an empty string if out of range
    return chr(number) if 0 <= number <= 0x10FFFF else ""
funcEND======================funcEND==============
func======================func==============
lang: js
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
function Chr(number) {
    // Return the character corresponding to the Unicode code point, or an empty string if out of range
    return (number >= 0 && number <= 0x10FFFF) ? String.fromCharCode(number) : "";
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
def Asc(s: str) -> int:
    return ord(s[0]) if s else -1
funcEND======================funcEND==============
func======================func==============
lang: py
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
def Abs(value: float) -> float:
    return abs(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ACos
libs: import math
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
def ACos(value: float) -> float:
    return math.acos(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ASin
libs: import math
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
def ASin(value: float) -> float:
    if value < -1.0 or value > 1.0:
        raise ValueError("Error: Value out of range for arcsine function.")
    return math.asin(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ATan
libs: import math
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
def ATan(value: float) -> float:
    return math.atan(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Ceil
libs: import math
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
def Ceil(value: float) -> float:
    return math.ceil(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Cos
libs: import math
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
def Cos(angle: float) -> float:
    return math.cos(angle)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Exp
libs: import math
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
def Exp(value: float) -> float:
    return math.exp(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Ln
libs: import math
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
def Ln(value: float) -> float:
    return math.log(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Log
libs: import math
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
def Log(value: float) -> float:
    return math.log10(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
def Round(value: float) -> float:
    return round(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sin
libs: import math
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
def Sin(angle: float) -> float:
    return math.sin(angle)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sqrt
libs: import math
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
def Sqrt(value: float) -> float:
    return math.sqrt(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Tan
libs: import math
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
def Tan(angle: float) -> float:
    return math.tan(angle)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
function Asc(s) {
    return s.length > 0 ? s.charCodeAt(0) : -1;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
function Abs(value) {
    return Math.abs(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
function ACos(value) {
    return Math.acos(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
function ASin(value) {
    if (value < -1.0 || value > 1.0) {
        throw new RangeError("Error: Value out of range for arcsine function.");
    }
    return Math.asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
function ATan(value) {
    return Math.atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
function Ceil(value) {
    return Math.ceil(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
function Cos(angle) {
    return Math.cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
function Exp(value) {
    return Math.exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
function Ln(value) {
    return Math.log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
function Log(value) {
    return Math.log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
function Round(value) {
    return Math.round(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
function Sin(angle) {
    return Math.sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
function Sqrt(value) {
    return Math.sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
function Tan(angle) {
    return Math.tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
def SubStr(s, startPos, length=-1):
    result = ""
    strLen = len(s)

    # Handle negative starting positions (counting from the end)
    if startPos < 0:
        startPos = strLen + startPos
        if startPos < 0:
            startPos = 0  # Ensure it doesn't go beyond the start of the string
    else:
        startPos -= 1  # Convert to 0-based index for internal operations

    # Handle length
    if length < 0:
        length = strLen - startPos  # Length to the end of the string
    elif startPos + length > strLen:
        length = strLen - startPos  # Adjust length to fit within the string

    # Extract the substring
    result = s[startPos:startPos + length]
    return result

funcEND======================funcEND==============
func======================func==============
lang: js
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
function SubStr(str, startPos, length = -1) {
    let result = "";
    let strLen = str.length;

    // Handle negative starting positions (counting from the end)
    if (startPos < 0) {
        startPos = strLen + startPos;
        if (startPos < 0) startPos = 0;  // Ensure it doesn't go beyond the start of the string
    } else {
        startPos -= 1; // Convert to 0-based index for internal operations
    }

    // Handle length
    if (length < 0) {
        length = strLen - startPos; // Length to the end of the string
    } else if (startPos + length > strLen) {
        length = strLen - startPos; // Adjust length to fit within the string
    }

    // Extract the substring
    result = str.substr(startPos, length);
    return result;
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
def Trim(inputString):
    return inputString.strip() if inputString else ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
def StrReplace(originalString, find, replaceWith):
    return originalString.replace(find, replaceWith)
funcEND======================funcEND==============
func======================func==============
lang: py
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
def StringTrimLeft(input, numChars):
    return input[numChars:] if numChars <= len(input) else input
funcEND======================funcEND==============
func======================func==============
lang: py
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
def StringTrimRight(input, numChars):
    return input[:-numChars] if numChars <= len(input) else input
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
def StrLower(string):
    return string.lower()
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
def StrSplit(inputStr, delimiter, num):
    parts = inputStr.split(delimiter)
    return parts[num - 1] if 0 < num <= len(parts) else ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
def Mod(dividend, divisor):
    return dividend % divisor
funcEND======================funcEND==============
func======================func==============
lang: py
name: Floor
libs: import math
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
def Floor(num):
    return math.floor(num) if not math.isnan(num) else float('nan')
funcEND======================funcEND==============
func======================func==============
lang: js
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimLeft(input, numChars) {
    return (numChars <= input.length) ? input.substring(numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimRight(input, numChars) {
    return (numChars <= input.length) ? input.substring(0, input.length - numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
function StrLower(string) {
    return string.toLowerCase();
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
function StrSplit(inputStr, delimiter, num) {
    const parts = inputStr.split(delimiter);
    return (num > 0 && num <= parts.length) ? parts[num - 1] : "";
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
function Mod(dividend, divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
function Floor(num) {
    return isNaN(num) ? NaN : Math.floor(num);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sort
libs: import random
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
def Sort(var_name, options):
    # Determine delimiter based on options
    delimiter = '\n'
    if 'D' in options:
        delimiter = options[options.index('D') + 1]

    # Split the input variable by delimiter
    items = var_name.split(delimiter)

    # Remove empty items and strip whitespace
    items = [item.strip() for item in items if item.strip()]

    # Apply sorting based on options
    if 'N' in options:
        # Numeric sort
        items.sort(key=lambda x: int(x))
    elif 'Random' in options:
        # Random sort
        random.shuffle(items)
    else:
        # Default alphabetical sort
        items.sort(key=lambda x: x.lower() if 'C' not in options else x)

    # Reverse if 'R' option is present
    if 'R' in options:
        items.reverse()

    # Remove duplicates if 'U' option is present
    if 'U' in options:
        seen = set()
        unique_items = []
        for item in items:
            lower_item = item.lower() if 'C' not in options else item
            if lower_item not in seen:
                seen.add(lower_item)
                unique_items.append(item)
        items = unique_items

    # Join the sorted items back into a string
    sorted_var = delimiter.join(items)

    return sorted_var
funcEND======================funcEND==============
func======================func==============
lang: py
name: getDataFromAPI
libs: import json|import urllib.request|import urllib.error
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
def getDataFromAPI(url):
    try:
        with urllib.request.urlopen(url) as response:
            if response.getcode() == 200:
                return response.read()
            else:
                return None
    except urllib.error.URLError as e:
        print(f"Error accessing URL: {e.reason}")
        return None
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileCreateDir
libs: import os
description: file~~~Creates a new directory specified by `path` (string). If the directory already exists, it usually does nothing. If intermediate directories in the path do not exist, their creation might depend on the target language's implementation (some create them, some require them to exist). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str dirPath := "test_htvm_dir"~~~print("Attempting to create directory: '" . dirPath . "'")~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileCreateDir is not available in standard JS. Skipping test.")~~~} else {~~~    FileCreateDir(dirPath)~~~    if (FileExist(dirPath) = true) {~~~        print("Directory '" . dirPath . "' created or already existed. PASSED.")~~~        ; Clean up~~~        FileRemoveDir(dirPath)~~~        if (FileExist(dirPath) = false) {~~~            print("Test directory '" . dirPath . "' cleaned up successfully.")~~~        } else {~~~            print("Cleanup of '" . dirPath . "' FAILED.")~~~        }~~~    } else {~~~        print("FileCreateDir test FAILED! Directory not found after creation attempt.")~~~    }~~~    ; ----------------------------------------------------~~~    str nestedDirPath := "parent_dir/child_dir"~~~    print("Attempting to create nested directory: '" . nestedDirPath . "'")~~~    ; Behavior for non-existent 'parent_dir' varies.~~~    FileCreateDir(nestedDirPath)~~~    if (FileExist(nestedDirPath) = true) {~~~        print("Nested directory '" . nestedDirPath . "' creation attempt finished. Check if it exists.")~~~        ; Try to clean up child~~~        FileRemoveDir(nestedDirPath)~~~        ; Try to clean up parent~~~        FileRemoveDir("parent_dir")~~~    } else {~~~        print("Nested directory '" . nestedDirPath . "' not found. This might be expected if parent was not auto-created.")~~~    }~~~}~~~```~~~
def FileCreateDir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileRemoveDir
libs: import shutil
description: file~~~Removes a directory specified by `path` (string). If the directory contains files or subdirectories, their removal depends on the target language's implementation (some remove recursively, some fail if not empty). Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~str dirPath := "dir_to_remove"~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileRemoveDir is not available in standard JS. Skipping test.")~~~} else {~~~    ; Test 1: Remove an empty directory~~~    FileCreateDir(dirPath)~~~    if (FileExist(dirPath) = true) {~~~        print("Directory '" . dirPath . "' created for removal test.")~~~        FileRemoveDir(dirPath)~~~        if (FileExist(dirPath) = false) {~~~            print("FileRemoveDir test 1 (empty dir) PASSED.")~~~        } else {~~~            print("FileRemoveDir test 1 (empty dir) FAILED! Directory still exists.")~~~        }~~~    } else {~~~        print("Could not create directory for FileRemoveDir test 1.")~~~    }~~~~~~    print("--------------------")~~~~~~    ; Test 2: Attempt to remove a directory that might have content (behavior can vary)~~~    str nestedDirPath := "parent_for_remove/child_for_remove"~~~    ; Creates parent/child potentially~~~    FileCreateDir(nestedDirPath) ~~~    FileAppend("dummy", nestedDirPath . "/file.txt")~~~    if (FileExist(nestedDirPath) = true) {~~~        print("Nested directory with file created: '" . nestedDirPath . "'")~~~        ; Attempt to remove parent~~~        FileRemoveDir("parent_for_remove") ~~~        if (FileExist("parent_for_remove") = false) {~~~            print("FileRemoveDir test 2 (potentially non-empty parent) PASSED (removed).")~~~        } else {~~~            print("FileRemoveDir test 2 (potentially non-empty parent) FAILED or partially failed. Check if 'parent_for_remove' still exists.")~~~            ; Cleanup if needed and possible~~~            FileRemoveDir(nestedDirPath)~~~            FileRemoveDir("parent_for_remove")~~~        }~~~    } else {~~~        print("Could not create nested directory for FileRemoveDir test 2.")~~~    }~~~}~~~```~~~
def FileRemoveDir(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileExist
libs: import os
description: file~~~Checks if a file or directory exists at the specified `path` (string). Returns `true` if it exists, `false` otherwise. Not available in standard browser JavaScript.~~~Here is how to use it:~~~```htvm~~~; This example assumes a non-browser environment.~~~; Placeholder, will attempt to use the script's own file if GetParams works.~~~str existingFilePath := ""~~~str nonExistentPath := "this_path_should_not_exist_12345.xyz"~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("FileExist is not available in standard JS. Skipping test.")~~~} else {~~~    ; Try to get path of the current script or a known file for a positive test~~~    ; This part is a bit tricky without knowing the execution context.~~~    ; For a simple test, we'll create and check a temporary file.~~~    str tempFileForExistTest := "temp_exist_test.txt"~~~    FileAppend("check", tempFileForExistTest)~~~    bool check1 := FileExist(tempFileForExistTest)~~~    print("FileExist('" . tempFileForExistTest . "') = " . STR(check1))~~~    if (check1 = true) {~~~        print("FileExist test 1 (existing file) PASSED.")~~~    } else {~~~        print("FileExist test 1 (existing file) FAILED!")~~~    }~~~    ; Cleanup~~~    FileDelete(tempFileForExistTest)~~~    bool check2 := FileExist(nonExistentPath)~~~    print("FileExist('" . nonExistentPath . "') = " . STR(check2))~~~    if (check2 = false) {~~~        print("FileExist test 2 (non-existent path) PASSED.")~~~    } else {~~~        print("FileExist test 2 (non-existent path) FAILED!")~~~    }~~~    ; Test with a directory~~~    str tempDirForExistTest := "temp_dir_exist_test"~~~    FileCreateDir(tempDirForExistTest)~~~    bool check3 := FileExist(tempDirForExistTest)~~~    print("FileExist('" . tempDirForExistTest . "' as directory) = " . STR(check3))~~~    if (check3 = true) {~~~        print("FileExist test 3 (existing directory) PASSED.")~~~    } else {~~~        print("FileExist test 3 (existing directory) FAILED!")~~~    }~~~    ; Cleanup~~~    FileRemoveDir(tempDirForExistTest)~~~}~~~```~~~
def FileExist(path):
    return os.path.exists(path)
funcEND======================funcEND==============
func======================func==============
lang: py
name: isWindows
libs: import platform
description: other~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
def isWindows():
    return platform.system().lower() == "windows"
funcEND======================funcEND==============
func======================func==============
lang: py
name: GetParams
libs: import os|import sys
description: io~~~Retrieves command-line arguments passed to the script. Returns them as a single string, with each argument typically on a new line, or formatted as absolute paths if they correspond to existing files/directories. Behavior and availability vary significantly by environment (e.g., not applicable in browsers).~~~Here is how to use it:~~~```htvm~~~; This function's output depends on how the script is executed with command-line arguments.~~~; For testing, you would run the compiled HTVM script like:~~~; (e.g., if Python) python your_script.py arg1 "argument two" path/to/a/file.txt~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("GetParams is typically not applicable in standard JS browser environments. Skipping direct test.")~~~} else {~~~    print("Retrieving command line parameters...")~~~    str allParams := GetParams()~~~    if (allParams = "") {~~~        print("No command line parameters were provided to the script, or function not fully supported in this context.")~~~    } else {~~~        print("Command Line Parameters Received:")~~~        print(allParams)~~~        print("--- End of Parameters ---")~~~        ; A simple "test" is to check if it returned something if args were expected.~~~        ; This requires manual verification by running with args.~~~        print("GetParams test: Review the output above. If you passed arguments, they should appear here.")~~~    }~~~}~~~; Example of how you might parse it in HTVM if it returns newline-separated args:~~~arr str paramsArray~~~if (allParams != "") {~~~    Loop, Parse, allParams, `n, `r {~~~        print("Param " . STR(A_Index + 1) . ": " . A_LoopField)~~~        if (A_LoopField != "") {~~~            paramsArray.add(A_LoopField) ~~~        }~~~    }~~~    print("Parsed first param (if any): " . paramsArray[0])~~~}~~~```~~~
def GetParams():
    # Check if any command line arguments are provided
    if len(sys.argv) < 2:
        return ""
    # Store the provided command line arguments
    params = []
    for arg in sys.argv[1:]:
        if os.path.exists(arg):
            arg = os.path.abspath(arg)
        params.append(arg)
    return "\n".join(params)
funcEND======================funcEND==============
func======================func==============
lang: py
name: BuildInVars
libs: import time|from datetime import datetime
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
# Initialize with current timestamp
last_input_time = time.time() * 1000  # Convert to milliseconds
start_timestamp = time.time() * 1000  # Convert to milliseconds
# Function to reset the idle timer
def reset_idle_timer():
    global last_input_time
    last_input_time = time.time() * 1000  # Update last input time in milliseconds
# Function to calculate tick count in milliseconds
def A_TickCount():
    return int(time.time() * 1000 - start_timestamp)
# Function to build in variables
def BuildInVars(varName):
    now = datetime.now()
    if varName == "A_TickCount":
        # Return tick count in milliseconds
        return A_TickCount()
    elif varName == "A_Now":
        # Return current local timestamp
        return now.strftime("%Y-%m-%d %H:%M:%S")
    elif varName == "A_YYYY":
        # Return current year
        return now.strftime("%Y")
    elif varName == "A_MM":
        # Return current month
        return now.strftime("%m")
    elif varName == "A_DD":
        # Return current day
        return now.strftime("%d")
    elif varName == "A_MMMM":
        # Return full month name
        return now.strftime("%B")
    elif varName == "A_MMM":
        # Return short month name
        return now.strftime("%b")
    elif varName == "A_DDDD":
        # Return full day name
        return now.strftime("%A")
    elif varName == "A_DDD":
        # Return short day name
        return now.strftime("%a")
    elif varName == "A_Hour":
        # Return current hour
        return now.strftime("%H")
    elif varName == "A_Min":
        # Return current minute
        return now.strftime("%M")
    elif varName == "A_Sec":
        # Return current second
        return now.strftime("%S")
    elif varName == "A_Space":
        # Return space character
        return " "
    elif varName == "A_Tab":
        # Return tab character
        return "\t"
    else:
        # Handle unknown variable names
        return ""
def Floor(number):
    if number > 0:
        return int(number)
    else:
        return int(number) - (1 if number != int(number) else 0)
funcEND======================funcEND==============
func======================func==============
lang: py
name: RegExReplace
libs: import re
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
def RegExReplace(inputStr, regexPattern, replacement):
    # Create a regular expression object using the provided pattern

    regex = re.compile(regexPattern, re.MULTILINE)  # re.MULTILINE for multi-line matching
    # Use the sub() method to perform the regex replacement
    resultStr = regex.sub(replacement, inputStr)
    # Return the modified string
    return resultStr
funcEND======================funcEND==============
func======================func==============
lang: py
name: RunCMD
libs: import subprocess
description: io~~~Executes a system command (shell command) and returns its standard output as a string. Error output might also be captured or cause an error depending on the implementation. Highly environment-dependent and not available in browsers.~~~Here is how to use it:~~~```htvm~~~; This function is highly dependent on the OS and environment.~~~; Not available in browser JS.~~~~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("RunCMD is not available in standard JS browser environments. Skipping test.")~~~} else {~~~    str command := ""~~~    ; Assuming isWindows() built-in exists and works~~~    bool isWin := isWindows() ~~~~~~    if (isWin = true) {~~~        command := "echo Hello from HTVM on Windows"~~~    } else {~~~        ; Single quotes for Unix echo~~~        command := "echo 'Hello from HTVM on Unix-like'" ~~~    }~~~    print("Executing command: " . command)~~~    str output := RunCMD(command)~~~    print("Output from command:")~~~    ; Trim to remove trailing newline from echo~~~    print(Trim(output))~~~~~~    if (isWin = true and Trim(output) = "Hello from HTVM on Windows") {~~~        print("RunCMD test (Windows echo) PASSED.")~~~    } else if (isWin = false and Trim(output) = "Hello from HTVM on Unix-like") {~~~        print("RunCMD test (Unix echo) PASSED.")~~~    } else if (command != "") {~~~        print("RunCMD test FAILED or OS detection mismatch. Output was: '" . Trim(output) . "'")~~~    } else {~~~        print("RunCMD test skipped as command was empty.")~~~    }~~~~~~    ; Example of a command that might list files (OS-dependent)~~~    str listCommand := ""~~~    if (isWin = true) { listCommand := "dir /b" ~~~    } else {~~~        listCommand := "ls -a" ~~~    }~~~    print("---")~~~    print("Attempting to list files with: " . listCommand)~~~    str fileListOutput := RunCMD(listCommand)~~~    print("File list output (first 200 chars): " . SubStr(fileListOutput, 1, 200) . "...")~~~    if (StrLen(fileListOutput) > 0) {~~~        print("RunCMD (list files) seems to have executed and produced output.")~~~    } else {~~~        print("RunCMD (list files) produced no output or failed.")~~~    }~~~}~~~```~~~
def RunCMD(command):
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return e.stdout + "\n" + e.stderr
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: RegExMatch
libs: import re
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
def RegExMatch(haystack, needle):
    match = re.search(needle, haystack)
    return match.start() + 1 if match else 0 # 1-based index or 0 if no match
funcEND======================funcEND==============
func======================func==============
lang: py
name: ExitApp
libs: import os
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
# Function to handle application termination
def ExitApp():
    os._exit(1)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
function Sort(varName, options = "") {
    let delimiter = '\n'; // Default delimiter
    let delimiterIndex = options.indexOf('D');
    if (delimiterIndex !== -1) {
        let delimiterChar = options[delimiterIndex + 1];
        delimiter = delimiterChar === '' ? ',' : delimiterChar;
    }
    let items = varName.split(new RegExp(delimiter === ',' ? ',' : '\\' + delimiter));
    // Remove empty items and trim whitespace
    items = items.filter(item => item.trim() !== '');
    // Apply sorting based on options
    if (options.includes('N')) {
        // Numeric sort
        items.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
    } else if (options.includes('Random')) {
        // Random sort
        for (let i = items.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [items[i], items[j]] = [items[j], items[i]];
        }
    } else {
        // Default alphabetical sort
        items.sort((a, b) => {
            const keyA = options.includes('C') ? a : a.toLowerCase();
            const keyB = options.includes('C') ? b : b.toLowerCase();
            if (keyA < keyB) return -1;
            if (keyA > keyB) return 1;
            return 0;
        });
    }
    // Reverse if 'R' option is present
    if (options.includes('R')) {
        items.reverse();
    }
    // Remove duplicates if 'U' option is present
    if (options.includes('U')) {
        const seen = new Map();
        items = items.filter(item => {
            const key = options.includes('C') ? item : item.toLowerCase();
            if (!seen.has(key)) {
                seen.set(key, item);
                return true;
            }
            return false;
        });
    }
    // Join the sorted items back into a string
    const sortedVar = items.join(delimiter === ',' ? ',' : '\n');
    return sortedVar;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: getDataFromAPI
libs: null
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
async function getDataFromAPI(url) {
	try {
	    const response = await fetch(url);
	    if (!response.ok) {
		    throw new Error("Network response was not ok");
	    }
	    const data = await response.json();
	    return data;
	} catch (error) {
	    console.error("Error fetching data:", error);
	    return null;
	}
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: getUrlParams
libs: null
description: string~~~(JavaScript Only) Extracts parameter values from the current URL's query string. It typically decodes and concatenates them, often separated by '&'. Primarily used in web browser environments for frontend logic.~~~Here is how to use it:~~~```htvm~~~; This function is JavaScript-specific and relies on browser environment.~~~; The example shows conceptual usage. To test, run in a browser with a URL like:~~~; http://example.com?name=Alice&topic=HTVM&mode=test~~~; This is not really possible to test~~~; This how you might use it:~~~str params := getUrlParams()~~~; Expected (if URL was ?name=Alice&project=HTVM&version=2): "Alice&HTVM&2" or similar~~~; Then you can do this:~~~; Example~~~params := "Alice&HTVM&2"~~~; Loop over the params~~~Loop, Parse, params, "&" {~~~    ; print each value~~~    print(A_LoopField)~~~}~~~```~~~
      function getUrlParams() {
        const queryString = window.location.search.substring(1); // Get the query string without the leading '?'
        const paramPairs = queryString.split("&"); // Split the query string into parameter key-value pairs
        // Array to store parameter values starting from the first key's value
        const paramValues = [];
        // Iterate over each parameter pair
        paramPairs.forEach((pair, index) => {
          const pairParts = pair.split("=");
          if (index === 0 && pairParts.length === 2) {
            // For the first parameter pair (index === 0), add the value directly
            const firstValue = decodeURIComponent(pairParts[1]);
            paramValues.push(firstValue);
          } else if (pairParts.length === 1) {
            // For subsequent parameter pairs (values without keys), add the value directly
            const value = decodeURIComponent(pairParts[0]);
            paramValues.push(value);
          }
        });
        // Join the parameter values into a single string separated by '&'
        const resultString = paramValues.join("&");
        return resultString;
      }

funcEND======================funcEND==============
func======================func==============
lang: js
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
      var lastKeyPressed = "";
      function trackLastKeyPressed() {
        document.addEventListener("keydown", function (event) {
          lastKeyPressed = event.key;
          // console.log(lastKeyPressed);
        });
      }
      function getLastKeyPressed() {
        return lastKeyPressed;
      }
      // Call the trackLastKeyPressed function to start tracking key presses
      trackLastKeyPressed();
      let lastInputTime = Date.now(); // Initialize with current timestamp
      let startTimestamp = Date.now(); // Initialize with current timestamp
      // Event listener to track user activity
      function resetIdleTimer() {
        lastInputTime = Date.now(); // Update last input time
      }
      document.addEventListener("mousemove", resetIdleTimer);
      document.addEventListener("keypress", resetIdleTimer);
      // Function to calculate time since last input event
      function A_TimeIdle() {
        return Date.now() - lastInputTime; // Calculate time difference
      }
      // Function to calculate tick count in milliseconds
      function A_TickCount() {
        return Date.now() - startTimestamp;
      }
      function BuildInVars(varName) {
        switch (varName) {
          case "A_ScreenWidth":
            // Return screen width
            return window.innerWidth;
          case "A_LastKey":
            // Return screen width
            return getLastKeyPressed();
          case "A_ScreenHeight":
            // Return screen height
            return window.innerHeight;
          case "A_TimeIdle":
            // Return time idle
            return A_TimeIdle();
          case "A_TickCount":
            // Return tick count in milliseconds
            return A_TickCount();
          case "A_Now":
            // Return current local timestamp
            return new Date().toLocaleString();
          case "A_YYYY":
            // Return current year
            return new Date().getFullYear();
          case "A_MM":
            // Return current month
            return (new Date().getMonth() + 1).toString().padStart(2, "0");
          case "A_DD":
            // Return current day
            return new Date().getDate().toString().padStart(2, "0");
          case "A_MMMM":
            // Return full month name
            return new Date().toLocaleDateString(undefined, { month: "long" });
          case "A_MMM":
            // Return short month name
            return new Date().toLocaleDateString(undefined, { month: "short" });
          case "A_DDDD":
            // Return full day name
            return new Date().toLocaleDateString(undefined, { weekday: "long" });
          case "A_DDD":
            // Return short day name
            return new Date().toLocaleDateString(undefined, { weekday: "short" });
          case "A_Hour":
            // Return current hour
            return new Date().getHours().toString().padStart(2, "0");
          case "A_Min":
            // Return current minute
            return new Date().getMinutes().toString().padStart(2, "0");
          case "A_Sec":
            // Return current second
            return new Date().getSeconds().toString().padStart(2, "0");
          case "A_Space":
            // Return space character
            return " ";
          case "A_Tab":
            // Return tab character
            return "\t";
          default:
            // Handle unknown variable names
            return "";
        }
      }
funcEND======================funcEND==============
func======================func==============
lang: js
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
      // Function to simulate AutoHotkey's RegExReplace in JavaScript
      function RegExReplace(inputStr, regexPattern, replacement) {
          // Create a regular expression object using the provided pattern
          const regex = new RegExp(regexPattern, 'g'); // 'g' flag for global match
          // Use the replace() method to perform the regex replacement
          const resultStr = inputStr.replace(regex, replacement);
          // Return the modified string
          return resultStr;
      }
funcEND======================funcEND==============
func======================func==============
lang: js
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
// RegExMatch
function RegExMatch(haystack, needle) {
    const regex = new RegExp(needle);
    const match = haystack.match(regex);
    return match ? match.index + 1 : 0; // 1-based index or 0 if no match
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: MsgBox
libs: <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
description: gui~~~(JavaScript Only - Browser) Displays a message box (alert/dialog) to the user.~~~`text`: The main message.~~~`title` (optional string): The title of the message box.~~~`value` (optional int): A number that configures icons.~~~Icons: +16=Error, +32=Question, +48=Warning, +64=Info.~~~`timeout` (optional int): Auto-closes the box after `timeout` seconds.~~~Here is how to use it:~~~```htvm~~~; This function is JavaScript-specific and relies on a browser environment with SweetAlert2.~~~async func RunMsgBoxTests() {~~~    await MsgBox("This is a simple OK message.", "Test 1")~~~    ; 48 = Warning Icon~~~    await MsgBox("Proceed with caution!", "Test 3: Warning Icon", 48)~~~    ; Timeout 2s~~~    await MsgBox("This will auto-close in 2 seconds.", "Test 5: Timeout", 0, 2)~~~    print("MsgBox tests complete. Check browser for dialogs.")~~~}~~~main~~~if (HTVM_getLang_HTVM() = "js") {~~~    print("MsgBox tests will attempt to show dialogs if in a browser.")~~~    await RunMsgBoxTests()~~~~~~} else {~~~    print("MsgBox is only for JavaScript browser environments. Skipping test.")~~~}~~~```~~~
function MsgBox(text, title = " ", value = 0, timeout = null) {
    return new Promise((resolve) => {
        // Define default options for the message box
        let defaultOptions = {
            title: title || " ", // Default title is empty
            text: text || "Press OK to continue.", // Default text if not provided
            showCancelButton: false, // Default is to not show Cancel button
            showDenyButton: false, // Default is to not show Deny button
            confirmButtonText: "OK", // Default text for OK button
            focusConfirm: true, // Default focus on OK button
        };
        let numOriginal = value;
        let num = numOriginal;
        let done1 = 0;
        let done2 = 0;
        let done3 = 0;
        let AIndex = 0;
        for (AIndex = 1; AIndex <= 1; AIndex++) {
            // Handle special case for value adjustments
            if (num >= 262144) {
                num = num - 262144;
                numOriginal = numOriginal - 262144;
            }
            if (num >= 256 && num < 500) {
                num = num - 256;
                done3 = 256;
            }
            if (num >= 512) {
                num = num - 512;
                done3 = 512;
            }
            if (num == 0) {
                done1 = 0;
                break;
            }
            if (num <= 6) {
                done1 = num;
                break;
            }
            if (num >= 64 && num < 64 * 2) {
                done2 = 64;
                if (num == 64) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 64;
                    break;
                }
            }
            if (num >= 48 && num < 63) {
                done2 = 48;
                if (num == 48) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 48;
                    break;
                }
            }
            if (num >= 32 && num < 47) {
                done2 = 32;
                if (num == 32) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 32;
                    break;
                }
            }
            if (num >= 16 && num < 30) {
                done2 = 16;
                if (num == 16) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 16;
                    break;
                }
            }
        }
        let doneAdded = done1 + done2 + done3;
        if (doneAdded !== numOriginal) {
            // displayMessage("The calc was wrong!");
        } else {
            // displayMessage("num was: " + numOriginal + "\ndone1: " + done1 + "\ndone2: " + done2 + "\ndone3: " + done3);
        }
        // Parse the value to determine the options for the message box
        if (done1 === 1) defaultOptions.showCancelButton = true;
        if (done1 === 3) {
            defaultOptions.showCancelButton = true;
            defaultOptions.showDenyButton = true;
        }
        if (done1 === 4) {
            defaultOptions.showDenyButton = true;
        }
        if (done1 === 5) {
            defaultOptions.showCancelButton = true;
        }
        if (done2 === 16) defaultOptions.icon = "error";
        if (done2 === 32) defaultOptions.icon = "question";
        if (done2 === 48) defaultOptions.icon = "warning";
        if (done2 === 64) defaultOptions.icon = "info";
        if (done3 === 256) defaultOptions.focusDeny = true;
        if (done3 === 512) defaultOptions.focusCancel = true;
        // Set timeout if provided
        if (timeout) {
            defaultOptions.timer = timeout * 1000; // Convert timeout to milliseconds
        }
        // Display the message box with the constructed options
        Swal.fire(defaultOptions).then((result) => {
            if (result.isConfirmed) {
                resolve("OK");
            } else if (result.isDenied) {
                resolve("No");
            } else {
                resolve("Cancel");
            }
        });
    });
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: guiInit
libs: null
description: null

/**
 * GUI System State
 * Stores references to elements, counters, and layout information.
 */
const guiState = {
    initialized: false,
    backgroundDiv: null,
    elements: {}, // Stores all GUI elements keyed by their ID { id: { elementRef, type, parentId, properties, children?, lastAutoPosChildElement? ... } }
    elementCounters: {}, // Stores counters for generating default IDs { div: 0, button: 0, text: 0, ... }
    lastAutoPosElement: { // For the top-level grid layout system
        id: null,
        x: 0, // Pixel value
        y: 0, // Pixel value
        width: 0, // Pixel value
        height: 0 // Pixel value
    },
    currentZIndex: 0, // For default z-index generation for top-level guiAdd divs
    autoPosGap: 20, // Gap for automatic grid layout
    idsInUse: new Set() // Keep track of all manually set and generated IDs
};

/**
 * Generates a unique default ID for an element type.
 * @param {string} elementType - The type of the element (e.g., 'div', 'button', 'text').
 * @returns {string} A unique ID (e.g., 'button0', 'text1').
 */
function generateDefaultId(elementType) {
    if (guiState.elementCounters[elementType] === undefined) {
        guiState.elementCounters[elementType] = 0;
    }
    let id;
    do {
        id = `${elementType}${guiState.elementCounters[elementType]++}`;
    } while (guiState.idsInUse.has(id)); // Ensure uniqueness
    guiState.idsInUse.add(id);
    return id;
}

/**
 * Parses a CSS property string (like '10px' or '50%') into value and unit.
 * Assumes 'px' if no unit is provided for numbers. Returns null for 'auto' or invalid.
 * @param {string | number | null} value - The value to parse.
 * @param {string} [defaultUnit='px'] - The default unit if only a number is given.
 * @returns {{value: number, unit: string} | null} - Parsed value and unit or null if not parsable numerically.
 */
function parseCssValue(value, defaultUnit = 'px') {
    if (value === null || value === undefined) return null;
    if (typeof value === 'number') {
        return { value: value, unit: defaultUnit };
    }
    if (typeof value === 'string') {
        const trimmedValue = value.trim().toLowerCase();
        if (trimmedValue === 'auto') {
            return null; // Cannot parse 'auto' numerically
        }
        const match = trimmedValue.match(/^(\d*\.?\d+)\s*([a-z%]*)$/);
        if (match) {
            const num = parseFloat(match[1]);
            const unit = match[2] || defaultUnit;
            return { value: num, unit: unit };
        }
    }
    // Allow number 0 specifically
    if (value === 0) {
        return { value: 0, unit: defaultUnit };
    }
    // console.warn(`Could not parse CSS value numerically: ${value}`); // Reduce noise
    return null; // Indicate parsing failure
}


/**
 * Applies raw CSS string to an element.
 * @param {HTMLElement} element - The element to apply styles to.
 * @param {string | null} rawCss - The raw CSS string (e.g., "color: red; font-weight: bold;").
 */
function applyRawCss(element, rawCss) {
    if (typeof rawCss === 'string' && rawCss.trim() !== '') {
        const styles = rawCss.split(';');
        styles.forEach(style => {
            if (style.trim() !== '') {
                const [property, value] = style.split(':').map(s => s.trim());
                if (property && value) {
                    const camelCaseProperty = property.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                    try {
                        // Special handling for common properties that might have existing values cleared
                        if (element.style[camelCaseProperty] !== undefined) {
                             element.style[camelCaseProperty] = value;
                        } else {
                             // Use setProperty for custom properties or less common ones
                             element.style.setProperty(property, value);
                        }
                    } catch (e) {
                        console.warn(`Failed to apply raw CSS style: ${property}:${value}`, e);
                    }
                }
            }
        });
    }
}

/**
 * Parses the border string ("size color" or "size|color"). Prefers CSS standard space separation.
 * @param {string | null} borderString
 * @param {string} [defaultSize='1px'] - Default border size
 * @param {string} [defaultColor='transparent'] - Default border color
 * @returns {{ size: string, style: string, color: string } | null}
 */
function parseBorder(borderString, defaultSize = '1px', defaultColor = 'transparent') {
    if (borderString === null || borderString === undefined || String(borderString).trim() === '') return null;

    const str = String(borderString);
    // Prioritize pipe, then space
    const parts = str.includes('|') ? str.split('|').map(s => s.trim()) : str.split(/\s+/).map(s => s.trim());

    // Basic parsing: assumes size [style] color or just size or size color
    let size = defaultSize;
    let style = 'solid';
    let color = defaultColor;

    if (parts.length === 1) {
        // Is it a color or a size? Assume size if it looks like a CSS unit value
        if (parseCssValue(parts[0])) {
            size = parts[0];
        } else {
            color = parts[0]; // Assume it's a color name/hex
        }
    } else if (parts.length === 2) {
        // Assume "size color" or "size style" or "style color" - prioritize size/color
        // If first part looks like size, assume "size color"
        if (parseCssValue(parts[0])) {
             size = parts[0];
             color = parts[1];
        } else { // Assume "style color" or "color size"? Less common, default to size/color interpretation
            size = parts[0]; // May not be a valid size, CSS handles it
            color = parts[1];
        }
    } else if (parts.length >= 3) {
        size = parts[0];
        style = parts[1]; // Add style parsing if needed
        color = parts[2];
    }

    // Ensure size has a unit if it's just a number string that's not 0
     const parsedSize = parseCssValue(size, 'px');
     if (parsedSize && parsedSize.unit === 'px' && String(size) === String(parsedSize.value) && parsedSize.value !== 0) {
         size = `${parsedSize.value}px`;
     }


    return { size: size, style: style, color: color };
}

// ==========================================================================
// HELPER: APPLY ENABLED/DISABLED STYLES (REVISED FOR CURSOR)
// ==========================================================================
/**
 * Applies visual and functional styles based on the element's effective enabled state.
 * @param {HTMLElement} element - The DOM element.
 * @param {string} elementType - The type of the element ('button', 'text', 'div', etc.).
 * @param {boolean} isEffectivelyEnabled - The calculated enabled state (considering parent).
 * @param {object} properties - The element's stored properties (needed for callback check).
 */
function _applyEnabledStyles(element, elementType, isEffectivelyEnabled, properties) {
    // Visual indication (Opacity applies universally)
    element.style.opacity = isEffectivelyEnabled ? '1' : '0.5';

    // Functional indication (Pointer events & Cursor)
    if (elementType === 'div') {
        // --- Container DIV Specific Logic ---
        if (!isEffectivelyEnabled) {
            // Disabled Container:
            // - Apply 'not-allowed' cursor via class.
            // - *DO NOT* set pointer-events: none, so hover for cursor works.
            // - Interaction is blocked because children will have pointer-events: none.
            element.classList.add('gui-container-disabled');
            // Ensure pointer-events is not 'none' if previously set
            if (element.style.pointerEvents === 'none') {
                 element.style.pointerEvents = 'auto'; // Or '', restore default behaviour
            }
        } else {
            // Enabled Container:
            // - Remove class.
            // - Restore default pointer events.
            // - Reset cursor (let children define theirs).
            element.classList.remove('gui-container-disabled');
            element.style.pointerEvents = ''; // Default browser handling
            element.style.cursor = '';
        }
    } else {
        // --- Child Element Specific Logic ---
        element.style.pointerEvents = isEffectivelyEnabled ? 'auto' : 'none';

        // Specific disabled attribute for form elements
        if (element.tagName === 'BUTTON' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
            element.disabled = !isEffectivelyEnabled;
        }

        // Cursor for child elements
        element.style.cursor = ''; // Reset first

        if (isEffectivelyEnabled) {
            // Set appropriate cursor only if enabled
            const isInteractive = (
                ['button', 'toggle', 'picture', 'dropdown'].includes(elementType) ||
                ((elementType === 'rectangle' || elementType === 'circle') && properties?.callback)
            );
            if (isInteractive) {
                element.style.cursor = 'pointer';
            } else if (elementType === 'text') {
                element.style.cursor = 'default';
            } else if (elementType === 'edit'){
                element.style.cursor = 'text';
            }
        } else {
            // Child element is effectively disabled
            element.style.cursor = 'default'; // Use 'default' cursor for disabled children
        }
    }
}


// ==========================================================================
// GUI INIT FUNCTION
// ==========================================================================

/**
 * Initializes the main GUI background layer.
 * @param {string | null} [backgroundColor=null] - Background color (hex). Defaults to '#202020'.
 * @param {string | null} [centerText=null] - Text to display in the center. Defaults to null (no text).
 */
function guiInit(backgroundColor = null, centerText = null) {
    if (guiState.initialized) {
        console.warn("GUI already initialized. Re-initializing.");
        if (guiState.backgroundDiv && guiState.backgroundDiv.parentNode) {
            guiState.backgroundDiv.parentNode.removeChild(guiState.backgroundDiv);
        }
        // Reset state if re-initializing cleanly
        Object.keys(guiState.elements).forEach(id => {
             if (guiState.elements[id].elementRef && guiState.elements[id].elementRef.parentNode) {
                 guiState.elements[id].elementRef.parentNode.removeChild(guiState.elements[id].elementRef);
             }
        });
        guiState.elements = {};
        guiState.elementCounters = {};
        guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
        guiState.currentZIndex = 0;
        guiState.idsInUse.clear();
    }

    const finalBgColor = backgroundColor === null ? '#202020' : backgroundColor; // Match body style bg

    const bgDiv = document.createElement('div');
    bgDiv.id = 'gui-background';
    bgDiv.style.position = 'fixed';
    bgDiv.style.top = '0';
    bgDiv.style.left = '0';
    bgDiv.style.width = '100vw';
    bgDiv.style.height = '100vh';
    bgDiv.style.backgroundColor = finalBgColor;
    bgDiv.style.zIndex = '-1'; // Behind other content
    bgDiv.style.overflow = 'hidden'; // Prevent scrollbars

    if (typeof centerText === 'string' && centerText.trim() !== '') {
        const textElement = document.createElement('div');
        textElement.textContent = centerText;
        textElement.style.position = 'absolute';
        textElement.style.top = '50%';
        textElement.style.left = '50%';
        textElement.style.transform = 'translate(-50%, -50%)';
        textElement.style.color = 'white'; // Default color
        textElement.style.fontSize = '20px'; // Default size
        textElement.style.fontFamily = 'sans-serif'; // Default font
        textElement.style.textAlign = 'center';
        textElement.style.pointerEvents = 'none'; // Ignore clicks
        bgDiv.appendChild(textElement);
    }

    document.body.appendChild(bgDiv);
    guiState.backgroundDiv = bgDiv;
    guiState.initialized = true;
    console.log("GUI Initialized.");
}


funcEND======================funcEND==============
func======================func==============
lang: js
name: guiAdd
libs: null
description: null

// ==========================================================================
// GUI ADD FUNCTION (Adds top-level DIVs)
// ==========================================================================
/**
 * Adds or updates a main GUI container element (div).
 * If ID exists, updates the element (enters edit mode).
 * If x and y are null during creation, uses automatic grid layout.
 *
 * @param {object} options - Configuration options for the element.
 * @param {string | number | null} [options.id=null] - Element ID. Auto-generated if null. Reuses if existing.
 * @param {string | number | null} [options.x=null] - Left position ('50px', '50%'). Defaults to auto grid layout on create, center on update if null.
 * @param {string | number | null} [options.y=null] - Top position ('50px', '50%'). Defaults to auto grid layout on create, center on update if null.
 * @param {string | number | null} [options.width='50%'] - Width ('100px', '50%').
 * @param {string | number | null} [options.height='50%'] - Height ('100px', '50%').
 * @param {number | string | null} [options.zIndex=null] - Stacking order. Auto-increments if null during creation. Defaults to 'auto'.
 * @param {string | null} [options.backgroundColor=null] - Background color (hex). Defaults to transparent.
 * @param {number | string | null} [options.rounding=10] - Border radius ('px' or '%'). Null or < 0 for no rounding. Default 10px.
 * @param {string | null} [options.border=null] - Border style ("size [style] color", e.g., "1px white"). Null for no border.
 * @param {string | null} [options.rawCss=null] - Additional raw CSS string.
 * @param {boolean | null} [options.isDeleting=false] - If true, removes the element.
 * @param {boolean | null} [options.isEnabled=true] - If false, visually disables the element (opacity, pointer-events) AND ITS CHILDREN.
 * @param {boolean | null} [options.isVisible=true] - If false, hides the element (display: none).
 */
function guiAdd({
    id = null,
    x = null,
    y = null,
    width = '45%', // Default for guiAdd
    height = '45%', // Default for guiAdd
    zIndex = null, // Default to null -> auto-increment or keep existing
    backgroundColor = "#121212",
    rounding = 10, // Default rounding 10px for guiAdd
    border = null, // Default no border for guiAdd
    rawCss = null,
    isDeleting = false,
    isEnabled = true, // Default to enabled
    isVisible = true
} = {}) {

    if (!guiState.initialized) {
        console.error("GUI Add Error: guiInit() must be called first.");
        return;
    }

    let elementId = id;
    let isEditMode = false;
    let existingElementData = null;

    // --- ID Handling ---
    if (elementId === null) {
        elementId = generateDefaultId('div'); // Default type is div for guiAdd
    } else {
        elementId = String(elementId);
        if (guiState.elements[elementId]) {
            isEditMode = true;
            existingElementData = guiState.elements[elementId];
             if (existingElementData.type !== 'div') {
                 console.warn(`GUI Add Warning: Attempting to update element '${elementId}' which is not a 'div' using guiAdd. Use guiControl or guiAddElement.`);
                 // Allow update for flexibility, but warn.
             }
        } else {
            if (guiState.idsInUse.has(elementId)) {
                console.warn(`GUI Add: Provided ID ${elementId} collides with a previously generated or used ID. Behaviour might be unexpected.`);
            }
            guiState.idsInUse.add(elementId);
        }
    }

    // --- Deleting ---
    if (isDeleting) {
        if (isEditMode) {
            // Recursively delete children first (cleaner state)
            if (existingElementData.children) {
                Object.keys(existingElementData.children).forEach(childId => {
                     // Use guiControl for proper deletion logic of children if needed,
                     // but simpler to just remove element and data here
                     const childData = existingElementData.children[childId];
                     if (childData && childData.elementRef && childData.elementRef.parentNode) {
                         childData.elementRef.parentNode.removeChild(childData.elementRef);
                     }
                     guiState.idsInUse.delete(childId);
                     // No need to delete from parent's children map, as parent is being deleted
                });
            }

            const elRef = existingElementData.elementRef;
            if (elRef && elRef.parentNode) {
                elRef.parentNode.removeChild(elRef);
            }
            delete guiState.elements[elementId];
            guiState.idsInUse.delete(elementId);
            if (guiState.lastAutoPosElement.id === elementId) {
                 guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
            }
            console.log(`GUI Add: Deleted element ID: ${elementId} and its children.`);
        } else {
            if (id !== null) {
                 console.warn(`GUI Add: Attempted to delete non-existent element ID: ${elementId}`);
            }
        }
        return; // Stop execution after deletion
    }

    let divElement;
    let properties = {};
    let oldIsEnabled = true; // Assume true initially or from existing state

    if (isEditMode) {
        divElement = existingElementData.elementRef;
        properties = { ...existingElementData.properties }; // Clone properties for modification
        oldIsEnabled = properties.isEnabled; // Capture old state before potential update
    } else {
        divElement = document.createElement('div');
        divElement.id = elementId;
        divElement.style.position = 'absolute';
        divElement.style.boxSizing = 'border-box';
        divElement.style.overflow = 'hidden'; // Prevent content spill by default
        properties = {};
        // Initialize children map and layout tracker for new elements
        guiState.elements[elementId] = { // Temporarily add to state for children iteration later
            elementRef: divElement,
            type: 'div',
            parentId: null,
            properties: properties, // Reference, will be updated
            children: {},
            lastAutoPosChildElement: { x: 0, y: 0, width: 0, height: 0 }
        };
    }

    // --- Apply Properties (Create or Edit) ---

    // Visibility (Apply early)
    const finalIsVisible = isVisible !== null ? isVisible : (isEditMode ? properties.isVisible : true);
    divElement.style.display = finalIsVisible ? '' : 'none';
    properties.isVisible = finalIsVisible;

    // Size (Width, Height)
    const finalWidth = width !== null ? String(width) : (isEditMode ? properties.width : '50%');
    const finalHeight = height !== null ? String(height) : (isEditMode ? properties.height : '50%');
    divElement.style.width = finalWidth;
    divElement.style.height = finalHeight;
    properties.width = finalWidth;
    properties.height = finalHeight;

    // Position (X, Y)
    let finalX = x !== null ? String(x) : (isEditMode ? properties.x : null);
    let finalY = y !== null ? String(y) : (isEditMode ? properties.y : null);
    let needsCenteringTransform = false;
    let isAutoLayout = false;

    if (finalX === null && finalY === null && !isEditMode) {
        isAutoLayout = true;
        const last = guiState.lastAutoPosElement;
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        let currentW_px = 0;
        let currentH_px = 0;
        let wasAddedTemporarily = false;
        if (!document.body.contains(divElement)) {
            divElement.style.visibility = 'hidden'; divElement.style.left = '-9999px';
            document.body.appendChild(divElement); wasAddedTemporarily = true;
        }
        currentW_px = divElement.offsetWidth;
        currentH_px = divElement.offsetHeight;
        if (wasAddedTemporarily) {
            document.body.removeChild(divElement);
            divElement.style.visibility = ''; divElement.style.left = '';
        }
         if (currentW_px <= 0) {
              const parsedW = parseCssValue(finalWidth);
              currentW_px = parsedW ? ((parsedW.unit === '%') ? (screenWidth * parsedW.value / 100) : parsedW.value) : 200;
         }
         if (currentH_px <= 0) {
              const parsedH = parseCssValue(finalHeight);
              currentH_px = parsedH ? ((parsedH.unit === '%') ? (screenHeight * parsedH.value / 100) : parsedH.value) : 100;
         }

        if (last.id !== null && guiState.elements[last.id]) {
            let nextX = last.x + last.width + guiState.autoPosGap;
            let nextY = last.y;
            if (nextX + currentW_px > screenWidth - guiState.autoPosGap) {
                nextX = guiState.autoPosGap;
                nextY = last.y + last.height + guiState.autoPosGap;
            }
            finalX = nextX + 'px';
            finalY = nextY + 'px';
        } else {
            finalX = guiState.autoPosGap + 'px';
            finalY = guiState.autoPosGap + 'px';
        }
        guiState.lastAutoPosElement = {
            id: elementId, x: parseFloat(finalX), y: parseFloat(finalY),
            width: currentW_px, height: currentH_px
        };
    } else if (!isAutoLayout && (finalX === null || finalY === null || String(finalX).includes('%') || String(finalY).includes('%'))) {
         finalX = finalX ?? (isEditMode ? properties.x : '50%');
         finalY = finalY ?? (isEditMode ? properties.y : '50%');
         needsCenteringTransform = true;
    }

    divElement.style.left = finalX !== null ? String(finalX) : '';
    divElement.style.top = finalY !== null ? String(finalY) : '';
    properties.x = finalX;
    properties.y = finalY;
    divElement.style.transform = needsCenteringTransform ? `translate(-50%, -50%)` : '';

    // Z-Index
    let finalZIndex = zIndex !== null ? String(zIndex) : (isEditMode ? properties.zIndex : null);
    if (finalZIndex === null && !isEditMode) {
        finalZIndex = String(guiState.currentZIndex++);
    } else if (finalZIndex === null && isEditMode) {
         finalZIndex = properties.zIndex;
    }
    divElement.style.zIndex = finalZIndex ?? 'auto';
    properties.zIndex = finalZIndex;

    // Background Color
    const finalBgColor = backgroundColor !== null ? backgroundColor : (isEditMode ? properties.backgroundColor : null);
    divElement.style.backgroundColor = finalBgColor || 'transparent';
    properties.backgroundColor = finalBgColor;

    // Rounding
    const finalRounding = rounding !== null ? rounding : (isEditMode ? properties.rounding : 10);
    if (finalRounding !== null) {
         if (typeof finalRounding === 'string' && finalRounding.includes('%')) {
            divElement.style.borderRadius = finalRounding;
         } else if (!isNaN(parseFloat(finalRounding)) && parseFloat(finalRounding) >= 0) {
             divElement.style.borderRadius = `${parseFloat(finalRounding)}px`;
         } else {
             divElement.style.borderRadius = '0px';
         }
    } else {
        divElement.style.borderRadius = '0px';
    }
    properties.rounding = finalRounding;

    // Border
    const finalBorder = border !== null ? border : (isEditMode ? properties.border : null);
    const parsedBorder = parseBorder(finalBorder);
    divElement.style.border = parsedBorder ? `${parsedBorder.size} ${parsedBorder.style} ${parsedBorder.color}` : 'none';
    properties.border = finalBorder;

    // Raw CSS
    const finalRawCss = rawCss !== null ? rawCss : (isEditMode ? properties.rawCss : null);
    applyRawCss(divElement, finalRawCss);
    properties.rawCss = finalRawCss;

    // Enabled State (Store intent, apply effective state below)
    const finalIsEnabled = isEnabled !== null ? isEnabled : (isEditMode ? properties.isEnabled : true);
    properties.isEnabled = finalIsEnabled; // Store the element's own intended state

    // Apply enabled styles to the div itself
    _applyEnabledStyles(divElement, 'div', finalIsEnabled, properties); // Pass its own properties

    // --- Cascade Enabled State to Children (Only if state changed) ---
    const enabledStateChanged = finalIsEnabled !== oldIsEnabled;
    // Ensure we are referencing the correct element data, especially if just created
    const currentElementData = guiState.elements[elementId];

    if (enabledStateChanged && currentElementData && currentElementData.children) {
        // console.log(`Cascading isEnabled=${finalIsEnabled} from ${elementId} to children`);
        Object.values(currentElementData.children).forEach(childData => {
            if (childData && childData.elementRef) {
                // Calculate child's effective state: its own state AND parent's new state
                const childEffectiveEnabled = childData.properties.isEnabled && finalIsEnabled;
                // Apply styles based on the *effective* state, passing child's properties
                _applyEnabledStyles(childData.elementRef, childData.type, childEffectiveEnabled, childData.properties);
            }
        });
    }

    // --- Add to DOM and State (if new) ---
    if (!isEditMode) {
        document.body.appendChild(divElement); // Add to body
        // Update the properties in the already created state entry
        guiState.elements[elementId].properties = properties;
    } else {
         // Update state for edited element (properties already updated)
         existingElementData.properties = properties; // Ensure update if reference changed
    }
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: guiAddElement
libs: null
description: null


// ==========================================================================
// GUI ADD ELEMENT FUNCTION (MODIFIED to handle optional parentId)
// ==========================================================================

/**
 * Adds or updates an element (button, text, etc.).
 * If parentId is provided, adds inside that container.
 * If parentId is NOT provided, adds directly to the main background.
 * Handles effective enabled state based on parent (if any).
 * Uses global auto-layout if no parentId AND no x/y provided.
 * Uses parent's auto-layout if parentId is provided AND no x/y provided.
 *
 * @param {object} options - Configuration options for the element.
 * @param {string | number | null} [options.parentId=null] - ID of the parent container (optional). If null/omitted, adds to background.
 * @param {string} options.elementType - Required type of element ('button', 'text', etc.).
 * @param {string | number | null} [options.id=null] - Element ID. Auto-generated if null. Reuses if existing (within parent or globally if no parent).
 * @param {string | number | null} [options.x=null] - Left position. Relative to parent if parentId given, otherwise absolute. Auto-layout if null.
 * @param {string | number | null} [options.y=null] - Top position. Relative to parent if parentId given, otherwise absolute. Auto-layout if null.
 * @param {string | number | null} [options.width=null] - Width. Defaults vary by elementType.
 * @param {string | number | null} [options.height=null] - Height. Defaults vary by elementType.
 * @param {number | string | null} [options.zIndex=null] - Stacking order. Auto-increments globally if null & no parentId. Defaults 'auto' inside parent.
 * @param {any} [options.value=null] - Content/state (text, URL, boolean, options string). Defaults vary.
 * @param {string | null} [options.placeholder=null] - Placeholder text (for 'edit').
 * @param {function | string | null} [options.callback=null] - Interaction callback function or name.
 * @param {string | null} [options.backgroundColor=null] - Background color. Defaults vary.
 * @param {string | null} [options.color=null] - Text color. Defaults vary.
 * @param {number | string | null} [options.rounding=null] - Border radius. Defaults vary.
 * @param {string | null} [options.border=null] - Border style. Defaults vary.
 * @param {string | null} [options.rawCss=null] - Additional raw CSS string.
 * @param {number | null} [options.size=null] - Font size (for text-based elements). Defaults vary.
 * @param {boolean | null} [options.isDeleting=false] - If true, removes the element.
 * @param {boolean | null} [options.isEnabled=true] - Element's own intended enabled state.
 * @param {boolean | null} [options.isVisible=true] - Visibility (display: none).
 */
function guiAddElement({
    // Core Identification & Placement
    id = null,
    parentId = null, // <<< MADE OPTIONAL (default null)
    elementType, // Required
    x = null,
    y = null,
    zIndex = null, // Handled differently if top-level

    // Dimensions
    width = null,
    height = null,
    size = null, // Font size

    // Content & State
    value = null,
    placeholder = null,
    isEnabled = true, // Element's own desired state
    isVisible = true,

    // Styling
    backgroundColor = null,
    color = null,
    rounding = null,
    border = null,
    rawCss = null,

    // Interaction & Deletion
    callback = null,
    isDeleting = false

} = {}) { // <<< Added default empty object for destructuring

    // --- INITIAL CHECKS ---
    if (!guiState.initialized) {
        console.error("GUI Add Element Error: guiInit() must be called first.");
        return;
    }
    const validElementTypes = ['button', 'text', 'edit', 'picture', 'toggle', 'rectangle', 'circle', 'video', 'dropdown', 'iframe'];
    if (!elementType || !validElementTypes.includes(elementType)) {
        console.error(`GUI Add Element Error: Invalid or missing elementType. Must be one of: ${validElementTypes.join(', ')}`); return;
    }

    // --- DETERMINE PARENT CONTEXT ---  <<< NEW SECTION >>>
    let parentData = null;
    let parentElement = null;
    let parentIdStr = parentId !== null ? String(parentId) : null; // Keep track if a parent was intended
    let isTopLevelElement = false; // Flag if added directly to background

    if (parentIdStr !== null) {
        // Parent ID provided: Validate and get parent data/element (Original Logic)
        if (!guiState.elements[parentIdStr] || guiState.elements[parentIdStr].type !== 'div') {
            console.error(`GUI Add Element Error: Parent container with ID '${parentIdStr}' not found or is not a div.`); return;
        }
        parentData = guiState.elements[parentIdStr];
        parentElement = parentData.elementRef;
        isTopLevelElement = false;
    } else {
        // No parent ID provided: Use background div
        parentElement = guiState.backgroundDiv;
        parentData = null; // No structured parent data in guiState.elements for the background itself
        isTopLevelElement = true;
        if (!parentElement) {
            // This check prevents adding to background if guiInit wasn't called
            console.error("GUI Add Element Error: Cannot add element without parentId because guiInit() has not been called or backgroundDiv is missing.");
            return;
        }
    }
    // --- END NEW SECTION ---


    // --- ID Handling --- <<< MODIFIED >>>
    let elementId = id;
    let isEditMode = false;
    let existingElementData = null;
    let oldIsEnabled = true; // For checking change later

    if (elementId === null) {
        elementId = generateDefaultId(elementType); // Global uniqueness check happens here
    } else {
        elementId = String(elementId);
        // Check for existing element: either in parent's children OR in global state if top-level
        if (!isTopLevelElement && parentData.children && parentData.children[elementId]) {
            // Existing child element within the specified parent
            isEditMode = true;
            existingElementData = parentData.children[elementId];
            if (existingElementData.type !== elementType) {
                 console.warn(`GUI Add Element Warning: Attempting to change elementType for child ID '${elementId}' from '${existingElementData.type}' to '${elementType}'.`);
            }
        } else if (isTopLevelElement && guiState.elements[elementId]) {
            // Existing top-level element (could be a div OR a non-div added previously without parentId)
            existingElementData = guiState.elements[elementId];
            // Prevent controlling divs with guiAddElement, guide user to guiAdd/guiControl
            if (existingElementData.type === 'div') {
                 console.warn(`GUI Add Element Warning: Attempting to control a 'div' element '${elementId}' using guiAddElement. Use guiAdd or guiControl instead.`);
                 return; // Stop execution to prevent incorrect control
            }
             if (existingElementData.type !== elementType) {
                 console.warn(`GUI Add Element Warning: Attempting to change elementType for top-level element ID '${elementId}' from '${existingElementData.type}' to '${elementType}'.`);
             }
            isEditMode = true; // It exists globally and is not a div
        } else {
             // New element ID, ensure it's globally unique before adding
             if (guiState.idsInUse.has(elementId)) {
                 // Warn about collision, specifying context
                 const locationMsg = isTopLevelElement ? "globally" : `for parent ${parentIdStr}`;
                 console.warn(`GUI Add Element: Provided ID ${elementId} ${locationMsg} collides with a previously generated or used ID.`);
             }
             // Add to the global set regardless of where it will be stored in the state tree
             guiState.idsInUse.add(elementId);
        }

        // Capture old state if editing an existing element
        if(isEditMode && existingElementData) {
             oldIsEnabled = existingElementData.properties.isEnabled;
             // No automatic type change handling here beyond the warning above
        }
    }

     // --- Deleting --- <<< MODIFIED >>>
    if (isDeleting) {
        // We only proceed with deletion if we found the element in edit mode
        if (isEditMode && existingElementData) {
            const elRef = existingElementData.elementRef;
            if (elRef && elRef.parentNode) {
                elRef.parentNode.removeChild(elRef); // Remove from DOM
            }
            // Remove from state: either parent's children or global state
            if (!isTopLevelElement) {
                delete parentData.children[elementId]; // Remove from parent's children map
            } else {
                delete guiState.elements[elementId]; // Remove from global elements map
                 // Recalculate global last auto-pos element if the deleted one was the last
                if (guiState.lastAutoPosElement.id === elementId) {
                    // Simple reset - a more complex recalculation might be needed for perfect layout
                    guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
                }
            }
            guiState.idsInUse.delete(elementId); // Free up the ID
            const locationMsg = isTopLevelElement ? "globally" : `from parent ${parentIdStr}`;
            console.log(`GUI Add Element: Deleted element ID: ${elementId} ${locationMsg}`);
        } else {
            // Only warn if an explicit ID was given for deletion but not found
            if (id !== null) {
                 console.warn(`GUI Add Element: Attempted to delete non-existent element ID: ${elementId}`);
            }
        }
        return; // Stop execution after deletion attempt
    }

    // --- Element Creation / Property Setup --- <<< MODIFIED to use existingElementData for edit mode >>>
    let element;
    let properties = {};

    if (isEditMode) {
        element = existingElementData.elementRef;
        properties = { ...existingElementData.properties }; // Clone existing properties for modification
    } else {
        // Create the actual DOM element based on type
        // ... (switch statement for element creation, exactly as before, assigns to 'element') ...
        switch (elementType) {
             case 'button': element = document.createElement('button'); element.style.textAlign = 'center'; element.style.padding = '5px'; break;
             case 'text': element = document.createElement('p'); element.style.margin = '0'; element.style.padding = '0'; element.style.userSelect = 'none'; break;
             case 'edit': element = document.createElement('textarea'); element.style.resize = 'none'; element.style.padding = '5px'; element.style.fontFamily = 'inherit'; element.style.fontSize = 'inherit'; break;
             case 'picture': element = document.createElement('img'); element.style.objectFit = 'contain'; element.style.display = 'block'; element.style.userSelect = 'none'; element.style.maxWidth = '100%'; element.style.maxHeight = '100%'; break;
             case 'toggle': element = document.createElement('div'); element.classList.add('gui-toggle'); element.style.position = 'relative'; element.style.overflow = 'hidden'; element.style.transition = 'background-color 0.3s'; element.style.userSelect = 'none'; const slider = document.createElement('div'); slider.classList.add('gui-toggle-slider'); slider.style.position = 'absolute'; slider.style.backgroundColor = 'white'; slider.style.borderRadius = '50%'; slider.style.transition = 'transform 0.3s ease'; element.appendChild(slider); break;
             case 'rectangle': element = document.createElement('div'); element.style.userSelect = 'none'; break;
             case 'circle': element = document.createElement('div'); element.style.userSelect = 'none'; break;
             case 'video': element = document.createElement('iframe'); element.setAttribute('frameborder', '0'); element.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share'); element.setAttribute('allowfullscreen', ''); element.setAttribute('referrerpolicy','strict-origin-when-cross-origin'); break;
             case 'dropdown': element = document.createElement('select'); element.style.padding = '5px'; element.style.fontFamily = 'inherit'; element.style.fontSize = 'inherit'; break;
             case 'iframe': element = document.createElement('iframe'); element.setAttribute('frameborder', '0'); element.setAttribute('referrerpolicy','strict-origin-when-cross-origin'); break;
             default: console.warn("GUI Add Element: Unknown element type fallback:", elementType); element = document.createElement('div'); break;
        }
        element.id = elementId;
        element.style.position = 'absolute'; // All elements are absolutely positioned
        element.style.boxSizing = 'border-box';
        properties = {}; // Start fresh properties for new element
    }


    // --- Element Type Specific Defaults --- <<< MOVED definition up, logic remains similar >>>
    let defaultWidth, defaultHeight, defaultBgColor, defaultColor, defaultRounding, defaultBorder, defaultValue, defaultPlaceholder, defaultFontSize, defaultZIndex = 'auto'; // default zIndex for children
    // Assign defaults based on elementType (same switch as before, just getting values)
     switch (elementType) {
         case 'button': defaultWidth = '100px'; defaultHeight = '30px'; defaultBgColor = '#4CAF50'; defaultColor = 'white'; defaultRounding = 5; defaultValue = `Button`; defaultBorder = null; defaultFontSize = 14; break;
         case 'text': defaultWidth = 'auto'; defaultHeight = 'auto'; defaultColor = 'white'; defaultBgColor = 'transparent'; defaultRounding = 0; defaultValue = `Text`; defaultBorder = null; defaultFontSize = 16; break;
         case 'edit': defaultWidth = '150px'; defaultHeight = '30px'; defaultBgColor = 'white'; defaultColor = 'black'; defaultRounding = 3; defaultValue = ''; defaultPlaceholder = ''; defaultBorder = '1px solid #ccc'; defaultFontSize = 14; break;
         case 'picture': defaultWidth = 'auto'; defaultHeight = 'auto'; defaultBgColor = 'transparent'; defaultRounding = 0; defaultValue = null; defaultBorder = null; break;
         case 'toggle': defaultWidth = '60px'; defaultHeight = '30px'; defaultBgColor = '#ccc'; defaultRounding = 15; defaultValue = false; defaultBorder = null; break;
         case 'rectangle': defaultWidth = '100px'; defaultHeight = '50px'; defaultBgColor = '#555'; defaultRounding = 0; defaultBorder = null; break;
         case 'circle': defaultWidth = '50px'; defaultHeight = '50px'; defaultBgColor = '#555'; defaultRounding = '50%'; defaultBorder = null; break;
         case 'video': defaultWidth = '320px'; defaultHeight = '180px'; defaultRounding = 0; defaultBorder = null; defaultValue = ''; break;
         case 'dropdown': defaultWidth = '150px'; defaultHeight = '30px'; defaultRounding = 3; defaultBorder = '1px solid #ccc'; defaultColor = 'black'; defaultBgColor = 'white'; defaultValue = ''; defaultFontSize = 14; break;
         case 'iframe': defaultWidth = '300px'; defaultHeight = '200px'; defaultRounding = 0; defaultBorder = '1px solid #ccc'; defaultValue = ''; break;
         default: defaultWidth = 'auto'; defaultHeight = 'auto'; defaultBgColor = 'transparent'; defaultColor = 'white'; defaultRounding = 0; defaultBorder = null; defaultValue = ''; defaultFontSize = 14; break; // Generic fallback defaults
    }


    // --- Apply Common Properties (Merging Options, Defaults, Existing) ---

    // 1. Visibility (Apply early for measurement)
    const finalIsVisible = isVisible !== null ? isVisible : (isEditMode ? properties.isVisible : true);
    properties.isVisible = finalIsVisible; // Store intent

    // 2. Size (Width, Height)
    const finalWidth = width !== null ? String(width) : (isEditMode ? properties.width : defaultWidth);
    const finalHeight = height !== null ? String(height) : (isEditMode ? properties.height : defaultHeight);
    element.style.width = finalWidth !== null ? finalWidth : '';
    element.style.height = finalHeight !== null ? finalHeight : '';
    properties.width = finalWidth;
    properties.height = finalHeight;

    // 3. Position (X, Y) - Handles different auto-layout contexts <<< MODIFIED >>>
    let finalX = x !== null ? String(x) : (isEditMode ? properties.x : null);
    let finalY = y !== null ? String(y) : (isEditMode ? properties.y : null);
    let isAutoLayout = false;
    let needsCenteringTransform = false; // Flag for applying translate(-50%, -50%)

    if (finalX === null && finalY === null && !isEditMode) { // Only apply auto-layout on creation
        isAutoLayout = true;
        // Temporarily add to parent (could be background or a div) to measure
        let currentW_px = 0, currentH_px = 0, wasAddedTemporarily = false;
        // Ensure element is displayable for measurement, even if finalIsVisible is false
        const originalDisplay = element.style.display;
        if (!parentElement.contains(element)) {
             element.style.visibility = 'hidden'; element.style.display = ''; // Ensure display for offsetWidth/Height
             element.style.position = 'absolute'; element.style.left = '-9999px';
             parentElement.appendChild(element); wasAddedTemporarily = true;
        }
        currentW_px = element.offsetWidth;
        currentH_px = element.offsetHeight;
        if (wasAddedTemporarily) { parentElement.removeChild(element); element.style.visibility = ''; element.style.left = ''; }
        element.style.display = originalDisplay; // Restore original intended display

        // Fallback size calculation if measurement failed (e.g., parent not visible yet)
        if (currentW_px <= 0) { const parsedW = parseCssValue(finalWidth); const parentWidthPx = parentElement.clientWidth || window.innerWidth; currentW_px = parsedW ? ((parsedW.unit === '%') ? (parentWidthPx * parsedW.value / 100) : parsedW.value) : (parseCssValue(defaultWidth)?.value || 100); }
        if (currentH_px <= 0) { const parsedH = parseCssValue(finalHeight); const parentHeightPx = parentElement.clientHeight || window.innerHeight; currentH_px = parsedH ? ((parsedH.unit === '%') ? (parentHeightPx * parsedH.value / 100) : parsedH.value) : (parseCssValue(defaultHeight)?.value || 30); }


        if (isTopLevelElement) {
            // *** Use GLOBAL auto-layout ***
            const last = guiState.lastAutoPosElement; // Use global tracker
            const screenWidth = window.innerWidth;
            if (last.id !== null && guiState.elements[last.id]) { // Check if there WAS a previous element
                let nextX = last.x + last.width + guiState.autoPosGap;
                let nextY = last.y;
                 // Wrap condition based on screen width
                 if (nextX + currentW_px > screenWidth - guiState.autoPosGap) {
                    nextX = guiState.autoPosGap;
                    nextY = last.y + last.height + guiState.autoPosGap; // Simple wrap Y based on last element height
                }
                finalX = nextX + 'px';
                finalY = nextY + 'px';
            } else { // First top-level auto-positioned element
                finalX = guiState.autoPosGap + 'px';
                finalY = guiState.autoPosGap + 'px';
            }
            // Update GLOBAL tracker
            guiState.lastAutoPosElement = { id: elementId, x: parseFloat(finalX), y: parseFloat(finalY), width: currentW_px, height: currentH_px };
        } else {
            // *** Use PARENT's auto-layout ***
             if (!parentData.lastAutoPosChildElement) { parentData.lastAutoPosChildElement = { x: 0, y: 0, width: 0, height: 0 }; } // Initialize if needed
            const last = parentData.lastAutoPosChildElement;
            const parentWidthPx = parentElement.clientWidth; // Use actual parent width for wrapping
            let nextX = 0; let nextY = 0;
            if (last && last.width > 0 ) { // Check if there WAS a previous auto-pos child in this parent
                nextX = last.x + last.width + guiState.autoPosGap; nextY = last.y;
                // Wrap condition within the PARENT
                if (parentWidthPx > 0 && (nextX + currentW_px > parentWidthPx - guiState.autoPosGap)) {
                    nextX = guiState.autoPosGap; nextY = last.y + last.height + guiState.autoPosGap;
                }
            } else { // First auto-pos child in this parent
                 nextX = guiState.autoPosGap; nextY = guiState.autoPosGap;
            }
            finalX = nextX + 'px'; finalY = nextY + 'px';
            // Update PARENT'S tracker
            parentData.lastAutoPosChildElement = { x: nextX, y: nextY, width: currentW_px, height: currentH_px };
        }
    } else if (!isAutoLayout && (finalX === null || finalY === null || String(finalX).includes('%') || String(finalY).includes('%'))) {
         // Centering logic (applies whether top-level or child if % or null used, unless explicit px given for both)
         finalX = finalX ?? (isEditMode ? properties.x : '50%'); // Default to 50% for centering if null
         finalY = finalY ?? (isEditMode ? properties.y : '50%'); // Default to 50% for centering if null
         needsCenteringTransform = true; // Assume centering needed
         // Avoid transform if specific pixel values are given for BOTH x and y
         if(parseCssValue(finalX)?.unit !== '%' && parseCssValue(finalY)?.unit !== '%'){
             needsCenteringTransform = false;
         }
    }

    element.style.left = finalX !== null ? String(finalX) : '';
    element.style.top = finalY !== null ? String(finalY) : '';
    properties.x = finalX;
    properties.y = finalY;
    element.style.transform = needsCenteringTransform ? `translate(-50%, -50%)` : ''; // Apply centering transform if needed

    // 4. Apply final display state now positioning is done
    element.style.display = finalIsVisible ? '' : 'none';

    // 5. Z-Index <<< MODIFIED >>>
    let finalZIndex = zIndex !== null ? String(zIndex) : (isEditMode ? properties.zIndex : null);
    if (finalZIndex === null && !isEditMode) {
         // Assign z-index from global counter ONLY for new top-level elements
         if (isTopLevelElement) {
             finalZIndex = String(guiState.currentZIndex++);
         } else {
             finalZIndex = defaultZIndex; // Use element's default ('auto') for children
         }
    } else if (finalZIndex === null && isEditMode) {
         // Keep existing z-index if null is passed during an update
         finalZIndex = properties.zIndex;
    }
    element.style.zIndex = finalZIndex ?? 'auto'; // Fallback to auto
    properties.zIndex = finalZIndex;


    // 6. Value / Content / Source / Placeholder (Logic mostly unchanged)
    const finalValue = value !== null ? value : (isEditMode ? properties.value : defaultValue);
    properties.value = finalValue; // Always store the final value intent
    const finalPlaceholder = placeholder !== null ? placeholder : (isEditMode ? properties.placeholder : defaultPlaceholder);
    properties.placeholder = finalPlaceholder; // Store placeholder intent

    // Apply value based on type (logic largely unchanged, added checks for element existence)
    if (elementType === 'edit' && element) {
        element.value = finalValue !== null ? String(finalValue) : '';
        element.placeholder = finalPlaceholder !== null ? String(finalPlaceholder) : '';
    } else if ((elementType === 'button' || elementType === 'text') && element) {
        element.textContent = finalValue !== null ? String(finalValue) : '';
    } else if (elementType === 'picture' && element) {
        const newSrc = finalValue !== null ? String(finalValue) : '';
        if (element.src !== newSrc) element.src = newSrc;
        element.alt = elementId; // Use ID as alt text
        element.onerror = () => { console.warn(`GUI Picture Error: Failed to load image for ID '${elementId}' from src: ${element.src}`); element.style.border = '1px dashed red'; };
    } else if ((elementType === 'video' || elementType === 'iframe') && element) {
        let srcUrl = finalValue !== null ? String(finalValue) : '';
        // YouTube embed conversion (only for video type)
        if(elementType === 'video') {
             const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
             const match = srcUrl.match(youtubeRegex);
             if (match && match[1]) {
                 srcUrl = `https://www.youtube.com/embed/${match[1]}`;
             }
        }
        // Set src only if changed
        if (element.src !== srcUrl) {
             element.src = srcUrl;
        }
    } else if (elementType === 'dropdown' && element) {
        const optionsString = finalValue !== null ? String(finalValue) : '';
        const options = optionsString.split('|').map(opt => opt.trim()).filter(opt => opt !== '');
        // Determine selected value - prioritize current element.value if options change slightly, then stored, then first option
         let targetSelectedValue = null;
         const currentElementValue = element.value; // Value currently selected in the DOM element
         const storedSelectedValue = properties.selectedValue; // Value we intended last time

         if (options.includes(currentElementValue)) { // If current DOM value is still valid
              targetSelectedValue = currentElementValue;
         } else if (options.includes(storedSelectedValue)) { // If previous stored value is still valid
              targetSelectedValue = storedSelectedValue;
         } else if (options.length > 0) { // Otherwise, default to first new option
              targetSelectedValue = options[0];
         }

         // Rebuild options only if they have actually changed
         let optionsChanged = false;
         if (element.options.length !== options.length) {
              optionsChanged = true;
         } else {
              for (let i = 0; i < options.length; i++) {
                   if (!element.options[i] || element.options[i].value !== options[i]) {
                        optionsChanged = true;
                        break;
                   }
              }
         }

         if (optionsChanged) {
              element.innerHTML = ''; // Clear existing options
              options.forEach(optText => {
                   const option = document.createElement('option');
                   option.value = optText;
                   option.textContent = optText;
                   element.appendChild(option);
              });
         }

         properties.selectedValue = targetSelectedValue; // Store the intended selection
         if (targetSelectedValue !== null) {
              element.value = targetSelectedValue; // Apply selection to the DOM element
         } else if (element.options.length > 0) {
             element.selectedIndex = -1; // Deselect if target is null
         }
    } else if (elementType === 'toggle' && element) {
         // Ensure stored value is strictly boolean
         properties.value = finalValue === true || String(finalValue).toLowerCase() === 'true';
         element.dataset.value = properties.value; // Use data attribute for state visualization if needed
    }


    // 7. Background Color
    const finalBgColor = backgroundColor !== null ? backgroundColor : (isEditMode ? properties.backgroundColor : defaultBgColor);
     if (elementType !== 'toggle') { // Toggle background is handled based on state later
        element.style.backgroundColor = finalBgColor || ''; // Use default or transparent if null/empty
     }
    properties.backgroundColor = finalBgColor; // Store base color (used by toggle for off state)

    // 8. Text Color
    const finalColor = color !== null ? color : (isEditMode ? properties.color : defaultColor);
    element.style.color = finalColor || '';
    properties.color = finalColor;

    // 9. Font Size
    const finalFontSize = size !== null ? size : (isEditMode ? properties.size : defaultFontSize);
    if (['text', 'button', 'edit', 'dropdown'].includes(elementType) && finalFontSize !== null) {
        element.style.fontSize = `${parseFloat(finalFontSize)}px`;
        properties.size = finalFontSize;
    } else {
         // Clear font size if explicitly set back to null during edit
         if (isEditMode && properties.size !== null && size === null) { element.style.fontSize = ''; }
         properties.size = finalFontSize; // Store null if cleared
    }

    // 10. Rounding
    const finalRounding = rounding !== null ? rounding : (isEditMode ? properties.rounding : defaultRounding);
     if (finalRounding !== null) {
          if (elementType === 'circle') { element.style.borderRadius = '50%'; } // Force circle
          else if (typeof finalRounding === 'string' && finalRounding.includes('%')) { element.style.borderRadius = finalRounding; }
          else if (!isNaN(parseFloat(finalRounding)) && parseFloat(finalRounding) >= 0) { element.style.borderRadius = `${parseFloat(finalRounding)}px`; }
          else { element.style.borderRadius = '0px'; } // Default to 0 if invalid
     } else { element.style.borderRadius = '0px'; } // Default to 0 if null
    properties.rounding = finalRounding;

    // 11. Border
    const finalBorder = border !== null ? border : (isEditMode ? properties.border : defaultBorder);
    const parsedBorder = parseBorder(finalBorder);
    element.style.border = parsedBorder ? `${parsedBorder.size} ${parsedBorder.style} ${parsedBorder.color}` : 'none';
    properties.border = finalBorder;

    // 12. Raw CSS (Apply last before enabled state/visual updates)
    const finalRawCss = rawCss !== null ? rawCss : (isEditMode ? properties.rawCss : null);
    applyRawCss(element, finalRawCss); // Applies the new styles
    properties.rawCss = finalRawCss;

    // 13. Enabled State (Store intent, calculate effective state) <<< MODIFIED >>>
    const finalIsEnabled = isEnabled !== null ? isEnabled : (isEditMode ? properties.isEnabled : true);
    properties.isEnabled = finalIsEnabled; // Store the element's own intended state

    // Calculate effective state based on self AND parent (if exists)
    // Assume background (parent if isTopLevelElement) is always enabled
    const parentIsEnabled = !isTopLevelElement ? parentData.properties.isEnabled : true;
    const effectiveIsEnabled = finalIsEnabled && parentIsEnabled;

    // Apply styles based on the EFFECTIVE state
    // This happens *before* toggle visual update, as toggle needs correct dimensions/opacity
    _applyEnabledStyles(element, elementType, effectiveIsEnabled, properties);


    // --- Special Visual Updates (Toggle - after styles applied) ---
    if (elementType === 'toggle') {
         const slider = element.querySelector('.gui-toggle-slider');
         if (slider) {
             const isOn = properties.value; // Use the processed boolean value
             const offBg = properties.backgroundColor || defaultBgColor || '#ccc'; // Use stored base color for off state
             const onBg = '#4CAF50'; // Hardcoded 'on' color
             element.style.backgroundColor = isOn ? onBg : offBg; // Set background based on state

             // Measure and position slider (only if visible and dimensions are valid)
             // Use effective visibility for this check
             const computedStyle = window.getComputedStyle(element);
             if(computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
                 let needsMeasure = !parentElement.contains(element); // Check if attached for measurement
                 if (needsMeasure) { element.style.visibility = 'hidden'; parentElement.appendChild(element); }

                 const elementHeightPx = element.clientHeight; const elementWidthPx = element.clientWidth;
                 if (elementHeightPx > 0 && elementWidthPx > 0) {
                      const padding = 4; const sliderSize = Math.max(1, elementHeightPx - padding); // Ensure size is at least 1px
                      slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                      slider.style.left = `${padding / 2}px`; slider.style.bottom = `${padding / 2}px`;
                      // Calculate max translation distance correctly
                      const maxTranslate = Math.max(0, elementWidthPx - sliderSize - padding);
                      const sliderTranslateX = isOn ? maxTranslate : 0;
                      slider.style.transform = `translateX(${sliderTranslateX}px)`;
                 } else {
                      console.warn(`GUI Toggle Warning: Cannot accurately size slider for toggle '${elementId}' (measured height/width is zero).`);
                      // Apply fallback size based on defaults if measurement fails
                      const fallbackH = parseCssValue(finalHeight)?.value || parseCssValue(defaultHeight)?.value || 30; const sliderSize = Math.max(1, fallbackH - 4); slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                 }

                 if (needsMeasure) { parentElement.removeChild(element); element.style.visibility = ''; }
             } else {
                 // If not visible, set a fallback size without positioning
                 const fallbackH = parseCssValue(finalHeight)?.value || parseCssValue(defaultHeight)?.value || 30; const sliderSize = Math.max(1, fallbackH - 4); slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                 slider.style.transform = 'translateX(0px)'; // Reset position
             }
         } else if(!isEditMode && element) { // Check element exists for new toggles
              console.error(`GUI Toggle Error: Could not find .gui-toggle-slider for new toggle '${elementId}'.`);
         }
    }

    // 14. Callback / Event Listener <<< MODIFIED >>>
    const finalCallback = callback !== null ? callback : (isEditMode ? properties.callback : null);
    properties.callback = finalCallback; // Store the callback reference/name

    // Remove previous listener before adding a new one (important for updates)
    const listenerInfo = element.__guiListenerInfo;
    if (listenerInfo) { element.removeEventListener(listenerInfo.type, listenerInfo.handler); element.__guiListenerInfo = null; }

    let eventType = null; let eventListener = null;

    if (finalCallback) {
        // Resolve callback function (either direct reference or name string)
        const callbackFunction = (typeof finalCallback === 'function') ? finalCallback : window[finalCallback];

        if (typeof callbackFunction === 'function') {
            const currentElementId = elementId; // Capture ID for the closure
            const currentParentIdStr = parentIdStr; // <<< Capture parent ID status for the closure >>>

            const eventHandlerWrapper = (event) => {
                 // <<< Get current element and parent data AT EVENT TIME >>>
                 let elementDataNow = null;
                 let parentDataNow = null; // Will be null if top-level
                 if (currentParentIdStr !== null && guiState.elements[currentParentIdStr]) {
                      // It's a child element, get parent and then child data
                      parentDataNow = guiState.elements[currentParentIdStr];
                      elementDataNow = parentDataNow?.children?.[currentElementId];
                 } else {
                      // It's a top-level element, get directly from global state
                      elementDataNow = guiState.elements[currentElementId];
                 }

                 // If element data was somehow removed between adding listener and event firing
                 if (!elementDataNow) {
                     console.warn(`Callback for ${currentElementId} triggered, but element data not found in state.`);
                     return;
                 }

                 // Check the effective enabled state AT THE TIME OF THE EVENT
                 const currentParentIsEnabled = parentDataNow ? (parentDataNow.properties?.isEnabled ?? true) : true; // Assume background enabled
                 const elementIsEnabled = elementDataNow.properties?.isEnabled ?? true; // Default to true if property missing

                 if (elementIsEnabled && currentParentIsEnabled) { // Check BOTH states
                     try {
                         // Logic to update state and call user function based on type
                         if (elementType === 'edit') {
                             const newValue = event.target.value;
                             elementDataNow.properties.value = newValue; // Update state
                             callbackFunction(currentElementId, event, newValue);
                         } else if (elementType === 'dropdown') {
                             const newValue = event.target.value;
                              elementDataNow.properties.selectedValue = newValue; // Update selected state
                             callbackFunction(currentElementId, event, newValue);
                         } else if (elementType === 'toggle') {
                             const newState = !elementDataNow.properties.value; // Calculate new state
                             elementDataNow.properties.value = newState; // Update state first
                             element.dataset.value = newState; // Update data attribute

                             // Update toggle visuals immediately within the handler for responsiveness
                             const slider = element.querySelector('.gui-toggle-slider');
                             const offBg = elementDataNow.properties.backgroundColor || defaultBgColor || '#ccc';
                             const onBg = '#4CAF50';
                             element.style.backgroundColor = newState ? onBg : offBg;
                             if (slider) {
                                 const elementHeightPx = element.clientHeight; const elementWidthPx = element.clientWidth; const padding = 4; const sliderSize = Math.max(1, elementHeightPx - padding);
                                 const maxTranslate = Math.max(0, elementWidthPx - sliderSize - padding);
                                 const sliderTranslateX = newState ? maxTranslate : 0;
                                 slider.style.transform = `translateX(${sliderTranslateX}px)`;
                              }
                             callbackFunction(currentElementId, event, newState); // Call user callback AFTER state/visuals updated
                         } else { // Button, Picture, Rectangle, Circle
                              callbackFunction(currentElementId, event, "null");
                         }
                     } catch (e) {
                         console.error(`Error executing callback for element ${currentElementId}:`, e);
                     }
                 } else {
                      // Interaction blocked due to disabled state
                      // console.log(`Interaction blocked for ${currentElementId} (elementEnabled: ${elementIsEnabled}, parentEnabled: ${currentParentIsEnabled})`);
                      event.preventDefault(); // Prevent default actions if needed (like form submission if inside form)
                      event.stopPropagation(); // Stop event bubbling
                 }
            };

            // Determine event type based on element
            if (['button', 'picture', 'rectangle', 'circle', 'toggle'].includes(elementType)) { eventType = 'click'; }
            else if (elementType === 'edit') { eventType = 'input'; }
            else if (elementType === 'dropdown') { eventType = 'change'; }

            // Add the listener if an event type was determined
            if (eventType) {
                 eventListener = eventHandlerWrapper;
                 element.addEventListener(eventType, eventListener);
                 // Store listener info on the element itself for easy removal later
                 element.__guiListenerInfo = { type: eventType, handler: eventListener };
            }
        } else if (typeof finalCallback === 'string' && finalCallback.trim() !== ''){
            // Warn if callback name provided but function not found globally
            console.warn(`GUI Add Element Warning: Callback function name '${finalCallback}' for ID '${elementId}' was not found globally.`);
        }
    }

    // --- Add to Parent DOM and State (if new) --- <<< MODIFIED >>>
    if (!isEditMode) {
        // Append to the correct parent element (background or container div)
        parentElement.appendChild(element);

        // Store state in the correct location with correct parentId reference
        const elementStateData = {
            elementRef: element,
            type: elementType,
            parentId: parentIdStr, // <<< Store null if top-level, actual parentId if child >>>
            properties: properties,
            // Note: Non-container elements don't have .children or .lastAutoPosChildElement props added here
        };

        if (isTopLevelElement) {
            // Add to global elements map if it has no parent container
            guiState.elements[elementId] = elementStateData;
        } else {
            // Add to parent's children map if it has a parent container
            if (!parentData.children) parentData.children = {}; // Ensure children map exists on parent data
            parentData.children[elementId] = elementStateData;
        }
    } else {
         // Update properties in the existing state data reference (already done by cloning earlier)
         // Ensure the reference in the state tree points to the updated properties object
         existingElementData.properties = properties;
    }
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: guiControl
libs: null
description: null


// ==========================================================================
// GUI CONTROL FUNCTION (Strict Object Syntax with parentId)
// ==========================================================================

/**
 * Controls (updates) an existing GUI element using a single options object
 * that MUST include both `id` and `parentId`.
 * - For children of a guiAdd container, `parentId` is the container's ID.
 * - For elements added directly to the background (guiAddElement with no parentId),
 *   `parentId` MUST be `null`.
 * - For controlling top-level containers (created by guiAdd), `parentId` MUST be `null`.
 *
 * Merges existing properties with new options. Handles cascading isEnabled state.
 *
 * @param {object} controlOptions - An object containing the properties to update.
 * @param {string | number} controlOptions.id - The ID of the element to control. REQUIRED.
 * @param {string | number | null} controlOptions.parentId - The ID of the parent container, or `null` if controlling a top-level div or a background element. REQUIRED.
 * @param {boolean} [controlOptions.isDeleting=false] - Set to true to delete the element.
 * @param {any} [controlOptions.property_name] - Other properties to update (e.g., value, isVisible, isEnabled, etc.).
 */
function guiControl(controlOptions) {

    // --- Input Validation ---
    if (typeof controlOptions !== 'object' || controlOptions === null) {
        console.error("GUI Control Error: Input must be an object.");
        return;
    }
    if (!controlOptions.hasOwnProperty('id') || (controlOptions.id === null || controlOptions.id === undefined)) {
        console.error("GUI Control Error: Input object must have an 'id' property.");
        return;
    }
    if (!controlOptions.hasOwnProperty('parentId')) {
        // Allow parentId to be explicitly null, but it must be present
        console.error("GUI Control Error: Input object must have a 'parentId' property (use null for top-level/background elements).");
        return;
    }

    const elementId = String(controlOptions.id);
    const parentId = controlOptions.parentId === null ? null : String(controlOptions.parentId); // Normalize null or string
    const options = { ...controlOptions }; // Clone for modification

    // Remove structural properties from the options object passed to adders
    delete options.id;
    delete options.parentId;

    // --- Initialization Check ---
    if (!guiState.initialized) { console.error("GUI Control Error: guiInit() must be called first."); return; }

    // --- Warn about changing immutable properties ---
    if (options.hasOwnProperty('elementType')) { console.warn(`GUI Control Warning (${elementId}): Property 'elementType' cannot be changed via guiControl. Ignoring.`); delete options.elementType; }


    // --- Element Lookup & Validation ---
    let targetElementData = null;
    let foundContextCorrect = false; // Flag to ensure lookup matches provided parentId context

    if (parentId === null) {
        // Expecting a top-level element (div OR background element)
        if (guiState.elements[elementId]) {
            targetElementData = guiState.elements[elementId];
            // Check if the found element's actual parentId matches the expected null context
            if (targetElementData.parentId === null) {
                 foundContextCorrect = true;
            } else {
                 console.error(`GUI Control Error: Element '${elementId}' found, but it belongs to parent '${targetElementData.parentId}', not the top-level/background (parentId: null was provided).`);
                 return;
            }
        }
    } else {
        // Expecting a child element within a specific parent div
        if (guiState.elements[parentId] && guiState.elements[parentId].type === 'div') {
            const parentData = guiState.elements[parentId];
            if (parentData.children && parentData.children[elementId]) {
                targetElementData = parentData.children[elementId];
                // Check if the found element's recorded parentId matches the provided parentId
                if (targetElementData.parentId === parentId) {
                     foundContextCorrect = true;
                } else {
                     // This case should be rare if state is consistent, but good to check
                     console.error(`GUI Control Error: Element '${elementId}' found under parent '${parentId}', but its stored parentId is inconsistent ('${targetElementData.parentId}').`);
                     return; // Indicates a state management issue
                }
            }
        } else if (guiState.elements[parentId]) {
             console.error(`GUI Control Error: Provided parentId '${parentId}' exists but is not a 'div' container.`);
             return;
        }
    }

    // --- Handle Element Not Found (in the specified context) ---
    if (!targetElementData || !foundContextCorrect) {
        // Allow deletion attempt even if not found (maybe already deleted)
        if (!(options.isDeleting === true && Object.keys(options).length === 1)) {
            const contextMsg = parentId === null ? "in the top-level/background context" : `under parent '${parentId}'`;
             console.error(`GUI Control Error: Element with ID '${elementId}' not found ${contextMsg}.`);
        } else {
             // If just deleting, ensure ID is removed from use tracking if it exists there
             if (guiState.idsInUse.has(elementId)) {
                  guiState.idsInUse.delete(elementId);
             }
             console.log(`GUI Control: Attempted to delete element '${elementId}' (context: parentId=${parentId}). If it existed, it's gone.`);
        }
        return; // Stop execution if element not found (and not just deleting)
    }

    // --- Element Found: Merge Options ---
    const updateOptions = {
         ...targetElementData.properties, // Start with existing properties
         ...options                      // Overwrite with new properties from input (excluding id, parentId)
    };

    // --- Call Appropriate Adder Function ---
    if (targetElementData.type === 'div') {
        // Must be a top-level div (found with parentId: null)
        // Call guiAdd, passing the merged options PLUS the elementId back in.
        guiAdd({ ...updateOptions, id: elementId });
    } else {
        // Any other element type (found either with parentId: null OR a specific parentId)
        // Call guiAddElement, passing merged options, PLUS id, elementType, and the original parentId context.
        guiAddElement({
            ...updateOptions,
            id: elementId,
            elementType: targetElementData.type,
            parentId: parentId // Pass the validated parentId context (null or string)
        });
    }
}


funcEND======================funcEND==============
func======================func==============
lang: js
name: MakeHotKey
libs: null
description: other~~~(JavaScript Only - Browser) Registers a global hotkey (keyboard shortcut). When the specified `hotkey` combination (e.g., "ctrl+s", "alt+shift+h", "f5") is pressed, the provided `callback` function is executed. The callback usually receives information about the hotkey that was pressed.~~~Here is how to use it:~~~```htvm~~~; Initial player position~~~int playerX := 10~~~int playerY := 10~~~; -------------------------------------~~~; Function to handle arrow key presses and move the player~~~func onArrowKeyPress(key) {~~~    print("You pressed: " . key)~~~    if (key = "arrowup") {~~~        playerY := playerY - 5~~~    }~~~    else if (key = "arrowdown") {~~~        playerY := playerY + 5~~~    }~~~    else if (key = "arrowleft") {~~~        playerX := playerX - 5~~~    }~~~    else if (key = "arrowright") {~~~        playerX := playerX + 5~~~    }~~~    guiControl p"gui1" id:"player" xplayerX+"px" yplayerY+"px"~~~}~~~; -------------------------------------~~~; Function to reset player position to default~~~func resetPos() {~~~    playerX := 10~~~    playerY := 10~~~    guiControl p"gui1" id:"player" xplayerX+"px" yplayerY+"px"~~~}~~~; -------------------------------------~~~; Button0 click action~~~Button0:~~~MsgBox, HI~~~subout~~~; -------------------------------------~~~; GUI setup with player button~~~main~~~gui p"gui1" x50% y50% w500 h500~~~gui p"gui1" id:"player" button xplayerX+"px" yplayerY+"px" w50 h50~~~; -------------------------------------~~~; Arrow key hotkeys to move player~~~MakeHotKey("arrowup", onArrowKeyPress)~~~MakeHotKey("arrowdown", onArrowKeyPress)~~~MakeHotKey("arrowleft", onArrowKeyPress)~~~MakeHotKey("arrowright", onArrowKeyPress)~~~; -------------------------------------~~~; Hotkey to reset position~~~MakeHotKey("Alt+R", resetPos)~~~```~~~
// Define the MakeHotKey function separately
function MakeHotKey(hotkey, callback) {
    document.addEventListener("keydown", function (event) {
        const keys = hotkey.split("+").map((key) => key.trim().toLowerCase());
        const modifiers = {
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
        };
        let hotkeyPressed = true;
        keys.forEach((key) => {
            if (key === "ctrl" || key === "shift" || key === "alt") {
                if (!modifiers[key]) {
                    hotkeyPressed = false;
                }
            } else if (key === "backspace") {
                if (event.key !== "Backspace") {
                    hotkeyPressed = false;
                }
            } else if (key === "esc" || key === "escape") {
                if (event.key !== "Escape") {
                    hotkeyPressed = false;
                }
            } else if (key.startsWith("arrow")) {
                const arrowDirection = key.replace("arrow", "");
                if (arrowDirection === "up" && event.key !== "ArrowUp") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "down" && event.key !== "ArrowDown") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "left" && event.key !== "ArrowLeft") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "right" && event.key !== "ArrowRight") {
                    hotkeyPressed = false;
                }
            } else if (key === "enter") {
                if (event.key !== "Enter") {
                    hotkeyPressed = false;
                }
            } else if (!event.key.match(/^[0-9a-zA-Z]$/) && event.key !== key) {
                hotkeyPressed = false;
            } else if (event.key.toLowerCase() !== key && event.key.match(/^[a-zA-Z]$/)) {
                hotkeyPressed = false;
            }
        });
        if (hotkeyPressed) {
            if (modifiers["shift"]) {
                callback(hotkey.toUpperCase());
            } else {
                callback(hotkey.toLowerCase());
            }
        }
    });
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: sortArr
libs: #include <iostream>|#include <vector>|#include <string>|#include <set>|#include <algorithm>
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
// Function to sort and remove duplicates
std::vector<std::string> sortArr(const std::vector<std::string>& input) {
    std::set<std::string> uniqueSorted(input.begin(), input.end());
    return std::vector<std::string>(uniqueSorted.begin(), uniqueSorted.end());
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
// Function to sort and remove duplicates
function sortArr(inputArray) {
    // Remove duplicates using Set and sort the array
    return [...new Set(inputArray)].sort();
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
# Function to sort and remove duplicates
def sortArr(input_list):
    """
    Function to sort a list of strings and remove duplicates.
    """
    return sorted(set(input_list))
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: sortArrByLenOnly
libs: #include <iostream>|#include <vector>|#include <string>|#include <algorithm>
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
// Function to sort an array of strings by length in descending order
std::vector<std::string> sortArrByLenOnly(const std::vector<std::string>& array) {
    std::vector<std::string> sorted = array;
    std::sort(sorted.begin(), sorted.end(), [](const std::string& a, const std::string& b) {
        return a.length() > b.length();
    });
    return sorted;
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
// Function to sort an array of strings by length in descending order
function sortArrByLenOnly(array) {
    return array.sort((a, b) => b.length - a.length);
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
# Function to sort an array of strings by length in descending order
def sortArrByLenOnly(array):
    array.sort(key=len, reverse=True)
    return array
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: countChars
libs: #include <iostream>|#include <string>
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
// Overload for counting a single character
int countChars(const std::string& str, char theChar) {
    int count = 0;
    for (char c : str) {
        if (c == theChar) {
            count++;
        }
    }
    return count;
}
// Overload for counting a substring
int countChars(const std::string& str, const std::string& substring) {
    if (substring.empty()) return 0; // Avoid infinite loop
    int count = 0;
    size_t pos = 0;
    // Find occurrences of the substring
    while ((pos = str.find(substring, pos)) != std::string::npos) {
        count++;
        pos += substring.length(); // Move past the found substring
    }
    return count;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
def countChars(string, theChar):
    return string.count(theChar)
funcEND======================funcEND==============
func======================func==============
lang: js
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
function countChars(string, theChar) {
    let count = 0;
    for (let char of string) {
        if (char === theChar) {
            count++;
        }
    }
    return count;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrTitleCase
libs: #include <iostream>|#include <sstream>|#include <cctype>|#include <string>
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
std::string StrTitleCase(const std::string& input) {
    std::string result;
    bool newWord = true;
    for (char ch : input) {
        if (std::isspace(ch)) {
            newWord = true; // next character starts a new word
            result += ch;
        } else if (newWord) {
            result += std::toupper(ch); // capitalize the first letter of the word
            newWord = false;
        } else {
            result += std::tolower(ch); // make other letters lowercase
        }
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
function StrTitleCase(inputString) {
    return inputString.split(' ')  // Split the string into words
        .map(word => {
            if (word) {  // Avoid empty words (multiple spaces)
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();  // Capitalize first letter
            }
            return word;  // If it's an empty string (spaces), keep it as is
        })
        .join(' ');  // Join the words back together with spaces
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
def StrTitleCase(input_string):
    words = input_string.split(' ')  # Split the input string into words
    result = []
    for word in words:
        if word:  # Ignore empty strings (in case of multiple spaces)
            result.append(word[0].upper() + word[1:].lower())  # Capitalize first letter, lowercase others
        else:
            result.append(word)  # Preserve spaces as is
    return ' '.join(result)  # Join the list of words back into a string
funcEND======================funcEND==============


func======================func==============
lang: py
name: HTVM_custom_port
libs: from flask import Flask, request, send_file, Response|import os|import traceback
description: null


app = Flask(__name__)

# --- Global Variables ---
# Port Configuration
HTVM_server_port_HTVM = 8000
# Default File Configuration - This will store the name of the file to serve for '/'
HTVM_DEFAULT_FILE_HTVM = "index.html" # Default to index.html initially

# --- Port Function ---
def HTVM_custom_port(port=None):
    global HTVM_server_port_HTVM
    if port is not None:
        HTVM_server_port_HTVM = port



funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_register
libs: from flask import Flask, request, send_file, Response|import os|import traceback
description: null

# --- Dynamic Route Registration (Plain Text In/Out) ---
def HTVM_register(endpoint, function_name, method="POST"):
    # (Code for HTVM_register remains the same)
    endpoint = endpoint.strip()
    actual_function_name = function_name.strip()
    flask_endpoint_name = actual_function_name
    if endpoint.startswith("/"): endpoint = endpoint[1:]
    if flask_endpoint_name.startswith("/"): flask_endpoint_name = flask_endpoint_name[1:]
    flask_endpoint_name = flask_endpoint_name.replace("/", "_")

    def create_handler(func_name_to_call):
        def HTVM_handler():
            A_Input = ""
            error_response = None
            if request.method in ['POST', 'PUT', 'PATCH']:
                try: A_Input = request.get_data(as_text=True)
                except Exception as e: print(f"Err reading req data for {func_name_to_call}: {e}"); error_response = Response(f"Failed read req data: {e}", status=400, mimetype='text/plain; charset=utf-8')
                if error_response: return error_response
            target_func = globals().get(func_name_to_call)
            if target_func and callable(target_func):
                 try:
                     result = target_func(A_Input=A_Input)
                     if isinstance(result, str): return Response(result, mimetype='text/plain; charset=utf-8')
                     else: print(f"Err: Func '{func_name_to_call}' no return str. Type: {type(result)}"); return Response(f"Server err: Func '{func_name_to_call}' invalid output.", status=500, mimetype='text/plain; charset=utf-8')
                 except TypeError as te: print(f"TypeError {func_name_to_call} (check A_Input): {te}\n{traceback.format_exc()}"); return Response(f"Server conf err: Func '{func_name_to_call}' cannot process input.", status=500, mimetype='text/plain; charset=utf-8')
                 except Exception as e: print(f"Err executing {func_name_to_call}: {e}\n{traceback.format_exc()}"); return Response(f"Err in func {func_name_to_call}: {e}", status=500, mimetype='text/plain; charset=utf-8')
            else: print(f"Err: Func '{func_name_to_call}' not found/callable."); return Response(f"Server Err: Func '{func_name_to_call}' not found.", status=404, mimetype='text/plain; charset=utf-8')
        HTVM_handler.__name__ = f"handler_{flask_endpoint_name}_{method.lower()}"
        return HTVM_handler
    handler_func = create_handler(actual_function_name)
    app.add_url_rule(f"/{endpoint}", flask_endpoint_name, handler_func, methods=[method.upper()])

funcEND======================funcEND==============


func======================func==============
lang: py
name: HTVM_init
libs: from flask import Flask, request, send_file, Response|import os|import traceback
description: null

# --- HTVM_init - Modified to use and set the global default ---
def HTVM_init(endpoint=None):
    """
    Handles serving files. Updates/uses global HTVM_DEFAULT_FILE_HTVM.
    - If endpoint is None: Serves the file specified by HTVM_DEFAULT_FILE_HTVM.
    - If endpoint is not None: Serves that endpoint AND sets it as the new default.
    Looks only in the base directory. Returns plain text errors.
    """
    global HTVM_DEFAULT_FILE_HTVM # Needed to modify the global
    base_dir = os.path.dirname(os.path.abspath(__file__))
    filename_to_serve = ""

    if endpoint is None:
        # DEFAULT BEHAVIOR: Use the currently set default file
        filename_to_serve = HTVM_DEFAULT_FILE_HTVM
        # Optional: Keep this print if you want to see when the default handler runs
        # print(f"HTVM_init: Handling default request (serving './{filename_to_serve}' as set globally)")
    else:
        # EXPLICIT REQUEST: Serve this file AND set it as the new default
        filename_to_serve = endpoint
        # Keep this print as it confirms the configuration step
        print(f"HTVM_init: Handling explicit request for './{filename_to_serve}' AND setting as new default.")
        HTVM_DEFAULT_FILE_HTVM = filename_to_serve # Update the global default

    # --- Logic to serve filename_to_serve ---
    file_path = os.path.join(base_dir, filename_to_serve)

    if not os.path.exists(file_path):
         context = "Default" if endpoint is None else "Requested"
         error_msg = f"Server Error: {context} file './{filename_to_serve}' not found."
         print(error_msg + f" Searched in: '{base_dir}'")
         return Response(error_msg, status=404, mimetype='text/plain; charset=utf-8')

    if filename_to_serve.endswith(".js"):
        # Keep this print as it confirms the type handling for configuration
        print(f"HTVM_init: './{filename_to_serve}' is JS. Wrapping in HTML.")
        try:
            with open(file_path, "r", encoding="utf-8") as js_file:
                js_content = js_file.read()
            html_content = f"""<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HTVM</title>
        <style>
            body {{
                background-color: #202020;
                color: #f0f0f0; /* Added text color for visibility */
                font-family:
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    Oxygen-Sans,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Helvetica,
                    Arial,
                    sans-serif;
            }}
        </style>
        <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    </head>
    <body>
        <script>
            {js_content}
        </script>
    </body>
</html>"""

            return Response(html_content, mimetype='text/html; charset=utf-8')
        except Exception as e:
             print(f"Error reading JS file './{file_path}': {e}\n{traceback.format_exc()}")
             return Response(f"Server Error: Could not read JS file '{filename_to_serve}'.\n{e}", status=500, mimetype='text/plain; charset=utf-8')

    else:
        # Optional: Keep this print if you want confirmation for non-JS files
        # print(f"HTVM_init: './{filename_to_serve}' is not JS. Serving directly.")
        try:
            return send_file(file_path)
        except Exception as e:
            print(f"Error sending file './{file_path}': {e}\n{traceback.format_exc()}")
            return Response(f"Server Error: Could not send file '{filename_to_serve}'.\n{e}", status=500, mimetype='text/plain; charset=utf-8')


# --- Root route uses HTVM_init (will read global HTVM_DEFAULT_FILE_HTVM) ---
@app.route('/')
def index():
  return HTVM_init() # Call without args uses the global default file name


funcEND======================funcEND==============


func======================func==============
lang: js
name: callBackend
libs: null
description: backend~~~(JavaScript Only) Asynchronously sends a request to a backend `endpoint` (string, e.g., "/api/data").~~~`textData` (string): The data to send in the request body (plain text).~~~`method` (optional string, default "POST"): The HTTP method (e.g., "GET", "POST", "PUT").~~~Returns a Promise that resolves with the plain text response from the backend. Used for frontend-backend communication.~~~Here is how to use it:~~~```htvm~~~; This function is JavaScript-specific for frontend-backend communication.~~~; It requires a running backend server that responds to the specified endpoints.~~~; -----------------------~~~; --- OSP Struct for state (Recommended) ---~~~struct InputState {~~~    prop str currentText := ""~~~}~~~; --- Callbacks ---~~~; -----------------------~~~; Default for edit~~~Edit0:~~~; No 'global' needed for JS target~~~InputState.currentText := A_Value~~~subout~~~; -----------------------~~~; Callback for first button~~~ButtonHello:~~~str respHello := await callBackend("/hello", InputState.currentText)~~~; Use SPACE separation for guicontrol~~~guicontrol id:"responseText" value:respHello~~~subout~~~; -----------------------~~~; Callback for second button~~~ButtonProcess:~~~str respProcess := await callBackend("/processData", InputState.currentText)~~~; Use SPACE separation for guicontrol~~~guicontrol id:"responseText" value:respProcess~~~subout~~~; -----------------------~~~; --- GUI Setup ---~~~main~~~; Prepare string vars only where needed, hardcode simple ones~~~str placeholderText := "Enter data..."~~~str btn1Text := "Call Hello"~~~str btn2Text := "Call Process"~~~str initialResponse := "Response..."~~~str editId := "inputEdit"~~~str helloBtnId := "helloBtn"~~~str processBtnId := "processBtn"~~~str responseTextId := "responseText"~~~str whiteColor := "white"~~~; Use SPACE separation for GUI options~~~; Uses Edit0~~~gui edit id:editId x10 y10 w200 h30 placeholder:placeholderText~~~gui button id:helloBtnId x10 y50 w95 h30 value:btn1Text callback:ButtonHello~~~gui button id:processBtnId x115 y50 w95 h30 value:btn2Text callback:ButtonProcess~~~gui text id:responseTextId x10 y90 w200 h30 value:initialResponse color:whiteColor~~~```~~~

/**
 * Calls a backend endpoint (on the same origin) expecting plain text input
 * and returning plain text output.
 *
 * @param {string} endpoint - The path of the endpoint (e.g., '/hello', '/goodbye').
 *                           Must start with '/'.
 * @param {string} textData - The plain text string to send in the request body.
 * @param {string} [method='POST'] - The HTTP method to use (defaults to 'POST').
 * @returns {Promise<string>} A Promise that resolves with the plain text response from the backend.
 * @throws {Error} If the network request fails or the server returns an error status (not 2xx).
 */
async function callBackend(endpoint, textData, method = 'POST') {
    // Calls are relative to the current origin (where the script is hosted)
    const url = endpoint;

    console.log(`Calling backend: ${method} ${url}`); // Optional: for debugging

    try {
        const response = await fetch(url, {
            method: method.toUpperCase(), // Ensure method is uppercase
            headers: {
                // Crucial header for sending plain text
                'Content-Type': 'text/plain; charset=utf-8',
                 // Indicate we accept plain text back (optional but good practice)
                'Accept': 'text/plain',
            },
            // The body is simply the text string
            body: textData
        });

        // Check if the HTTP status code indicates success (e.g., 200 OK)
        if (!response.ok) {
            // Try to get error message text from the response body, otherwise use status text
            let errorText = response.statusText; // Default error text
            try {
                 // Since the backend might send plain text errors for 4xx/5xx too
                errorText = await response.text();
            } catch (e) {
                // Ignore if reading text fails, stick with statusText
                console.warn("Could not read error response body as text.");
            }
            // Throw an error to be caught by the caller
            throw new Error(`HTTP error! Status: ${response.status} - ${errorText}`);
        }

        // If response is OK, get the body content as plain text
        const responseText = await response.text();
        return responseText; // Resolve the promise with the text

    } catch (error) {
        // Catch network errors (e.g., server unreachable) or the error thrown above
        console.error('Error calling backend:', error);
        // Re-throw the error so the calling code can handle it
        throw error;
    }
}


funcEND======================funcEND==============
func======================func==============
lang: cpp
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
std::string HTVM_getLang_HTVM() {
    return "cpp";
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
def HTVM_getLang_HTVM():
    return "py"
funcEND======================funcEND==============
func======================func==============
lang: js
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
function HTVM_getLang_HTVM() {
    return "js";
}
funcEND======================funcEND==============


func======================func==============
lang: cpp
name: HTclang_HTclang_HTclang
libs: #include <algorithm>|#include <any>|#include <cstdint>|#include <filesystem>|#include <iostream>|#include <optional>|#include <regex>|#include <sstream>|#include <string>|#include <type_traits>|#include <vector>
description: null
bool noParams = false;
std::string allArgs = "";
// in allArgs will look like:
// full/path/code/
// HTVM-Instruction.txt file
// lang to convert to
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE and more

#ifdef _WIN32
    #define ARGC __argc
    #define ARGV __argv
#else
    extern char **environ;
    int ARGC;
    char** ARGV;
    __attribute__((constructor)) void init_args(int argc, char* argv[], char* envp[]) {
        ARGC = argc;
        ARGV = argv;
    }
#endif
std::string GetParams() {
    std::vector<std::string> params;
    for (int i = 1; i < ARGC; ++i) {
        std::string arg = ARGV[i];
        if (std::filesystem::exists(arg)) {
            arg = std::filesystem::absolute(arg).string();
        }
        params.push_back(arg);
    }
    std::string result;
    for (const auto& param : params) {
        result += param + "\n";
    }
    return result;
}


void HTclang_HTclang_HTclang() {
    std::string params = Trim(GetParams());
    if (params == "") {
	noParams = true;
        print("Usage: HTclang <yourCodeFileName.htclang> <HTclang-instructions.txt>\n\nExample:\n HTclang main.htclang HTclang-instructions.txt\n");
        return;
    }
    std::vector<std::string> items1 = LoopParseFunc(params, "\n", "\r");
    for (size_t A_Index1 = 0; A_Index1 < items1.size() + 0; A_Index1++) {
        std::string A_LoopField1 = items1[A_Index1 - 0];
        allArgs += Trim(A_LoopField1) + "\n";
    }
    allArgs = StringTrimRight(allArgs, 1);
}

funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_v2_HTVM
libs: #include <algorithm>|#include <any>|#include <cstdint>|#include <filesystem>|#include <iostream>|#include <optional>|#include <regex>|#include <sstream>|#include <string>|#include <type_traits>|#include <vector>
description: null
bool noParams = false;
std::string allArgs = "";
// in allArgs will look like:
// full/path/code/
// HTVM-Instruction.txt file
// lang to convert to
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE and more

#ifdef _WIN32
    #define ARGC __argc
    #define ARGV __argv
#else
    extern char **environ;
    int ARGC;
    char** ARGV;
    __attribute__((constructor)) void init_args(int argc, char* argv[], char* envp[]) {
        ARGC = argc;
        ARGV = argv;
    }
#endif
std::string GetParams() {
    std::vector<std::string> params;
    for (int i = 1; i < ARGC; ++i) {
        std::string arg = ARGV[i];
        if (std::filesystem::exists(arg)) {
            arg = std::filesystem::absolute(arg).string();
        }
        params.push_back(arg);
    }
    std::string result;
    for (const auto& param : params) {
        result += param + "\n";
    }
    return result;
}


void HTVM_v2_HTVM() {
    std::string params = Trim(GetParams());
    if (params == "") {
	noParams = true;
        print("Usage: HTVM <yourCodeFileName.yourExtension> <HTVM-instructions.txt> [optional LangToTranspileTo]\n\nOptions:\n  <yourCodeFileName.yourExtension>  The source code file to transpile.\n  <HTVM-instructions.txt>              The instructions file for transpilation.\n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js, go, lua, cs, java, kt, rb, nim, ahk, swift, dart, ts, groovy, htvm or <yourExtension>).\n\nExample:\n  HTVM main.htvm HTVM-instructions.txt cpp\n");
        return;
    }
    std::vector<std::string> items1 = LoopParseFunc(params, "\n", "\r");
    for (size_t A_Index1 = 0; A_Index1 < items1.size() + 0; A_Index1++) {
        std::string A_LoopField1 = items1[A_Index1 - 0];
        allArgs += Trim(A_LoopField1) + "\n";
    }
    allArgs = StringTrimRight(allArgs, 1);
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: HTVM_v2_HTVM
libs: import os|import re|import sys
description: null

noParams = False
allArgs = ""
# in allArgs will look like:
# full/path/code/
# HTVM-Instruction.txt file
# lang to convert to
# HTVM-Instruction.txt file MORE
# HTVM-Instruction.txt file MORE
# HTVM-Instruction.txt file MORE and more

def GetParams():
    # Check if any command line arguments are provided
    if len(sys.argv) < 2:
        return ""
    # Store the provided command line arguments
    params = []
    for arg in sys.argv[1:]:
        if os.path.exists(arg):
            arg = os.path.abspath(arg)
        params.append(arg)
    return "\n".join(params)

def HTVM_v2_HTVM():
    global noParams, allArgs
    params = Trim(GetParams())
    if (params == ""):
        noParams = True
       	print("Usage: HTVM <yourCodeFileName.yourExtension> <HTVM-instructions.txt> [optional LangToTranspileTo]\n\nOptions:\n  <yourCodeFileName.yourExtension>  The source code file to transpile.\n  <HTVM-instructions.txt>              The instructions file for transpilation.\n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js, go, lua, cs, java, kt, rb, nim, ahk, swift, dart, ts, groovy, htvm or <yourExtension>).\n\nExample:\n  HTVM main.htvm HTVM-instructions.txt cpp\n")
        return
    items1 = LoopParseFunc(params, "\n", "\r")
    for A_Index1 , A_LoopField1 in enumerate(items1, start=0):
        allArgs += Trim(A_LoopField1) + "\n"
    allArgs = StringTrimRight(allArgs, 1)

funcEND======================funcEND==============
func======================func==============
lang: js
name: HTVM_v2_HTVM
libs: null
description: null

// HTVM_v2_HTVM()

let allArgs = "";
let noParams = false;

function HTVM_v2_HTVM() {
return
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTclang_HTclang_HTclang
libs: null
description: null

// HTclang_HTclang_HTclang()

let allArgs = "";
let noParams = false;

function HTclang_HTclang_HTclang() {
return
}

funcEND======================funcEND==============


func======================func==============
lang: cpp
name: HTVM_Append
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Append(std::vector<std::string>& arr, const std::string& value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<std::string>& arr, const char* value) {
    arr.push_back(std::string(value));
}

void HTVM_Append(std::vector<int>& arr, int value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<float>& arr, float value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<bool>& arr, bool value) {
    arr.push_back(value);
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Pop
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Pop(std::vector<std::string>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<int>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<float>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<bool>& arr) {
    if (!arr.empty()) arr.pop_back();
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Size
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null


size_t HTVM_Size(const std::vector<std::string>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<int>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<float>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<bool>& arr) {
    return arr.size();
}

funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Insert
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Insert(std::vector<std::string>& arr, size_t index, const std::string& value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<std::string>& arr, size_t index, const char* value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, std::string(value));
}

void HTVM_Insert(std::vector<int>& arr, size_t index, int value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<float>& arr, size_t index, float value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<bool>& arr, size_t index, bool value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Remove
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

// Remove by index for std::vector<std::string>
void HTVM_Remove(std::vector<std::string>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<int>
void HTVM_Remove(std::vector<int>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<float>
void HTVM_Remove(std::vector<float>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<bool>
void HTVM_Remove(std::vector<bool>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_IndexOf
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

// IndexOf for std::vector<std::string>
int HTVM_IndexOf(const std::vector<std::string>& arr, const std::string& value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// Overload for string literals
int HTVM_IndexOf(const std::vector<std::string>& arr, const char* value) {
    return HTVM_IndexOf(arr, std::string(value));
}

// IndexOf for std::vector<int>
int HTVM_IndexOf(const std::vector<int>& arr, int value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// IndexOf for std::vector<float>
int HTVM_IndexOf(const std::vector<float>& arr, float value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// IndexOf for std::vector<bool>
int HTVM_IndexOf(const std::vector<bool>& arr, bool value) {
    for (size_t i = 0; i < arr.size(); ++i) {
        if (arr[i] == value) {
            return static_cast<int>(i);
        }
    }
    return -1;
}

funcEND======================funcEND==============


func======================func==============
lang: py
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value):
    arr.append(value)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr):
    if arr:
        arr.pop()

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr):
    return len(arr)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value):
    arr.insert(index, value)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(arr, index):
    if 0 <= index < len(arr):
        del arr[index]

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value):
    return arr.index(value) if value in arr else -1

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Append
libs: null
description: null

function HTVM_Append(arr, value) {
    arr.push(value);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop(arr) {
    arr.pop();
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Size
libs: null
description: null

function HTVM_Size(arr) {
    return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert(arr, index, value) {
    arr.splice(index, 0, value);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr, index) {
    if (index >= 0 && index < arr.length) arr.splice(index, 1);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf(arr, value) {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Append
libs: null
description: null

// Append to a slice
func HTVM_Append[T any](arr *[]T, value T) {
    *arr = append(*arr, value)
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Pop
libs: null
description: null

// Pop the last element from a slice
func HTVM_Pop[T any](arr *[]T) {
    if len(*arr) > 0 {
        *arr = (*arr)[:len(*arr)-1]
    }
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Size
libs: null
description: null

// Get the size of a slice
func HTVM_Size[T any](arr []T) int {
    return len(arr)
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Insert
libs: null
description: null

// Insert a value at a specific index in a slice
func HTVM_Insert[T any](arr *[]T, index int, value T) {
    if index >= 0 && index <= len(*arr) {
        *arr = append((*arr)[:index], append([]T{value}, (*arr)[index:]...)...)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Remove
libs: null
description: null


// Remove an element at a specific index in a slice
func HTVM_Remove[T any](arr *[]T, index int) {
    if index >= 0 && index < len(*arr) {
        *arr = append((*arr)[:index], (*arr)[index+1:]...)
    }
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_IndexOf
libs: null
description: null

// Find the index of a value in a slice
func HTVM_IndexOf[T comparable](arr []T, value T) int {
    for i, v := range arr {
        if v == value {
            return i
        }
    }
    return -1
}


funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Append
libs: null
description: null

function HTVM_Append(arr, value)
    table.insert(arr, value)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop(arr)
    table.remove(arr)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Size
libs: null
description: null

function HTVM_Size(arr)
    return #arr
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert(arr, index, value)
    table.insert(arr, index, value)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr, index)
    if index >= 1 and index <= #arr then
        table.remove(arr, index)
    end
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf(arr, value)
    for i, v in ipairs(arr) do
        if v == value then
            return i
        end
    end
    return -1
end

funcEND======================funcEND==============


func======================func==============
lang: cs
name: HTVM_Append
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Append<T>(List<T> arr, T value) {
    arr.Add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Pop
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Pop<T>(List<T> arr) {
    if (arr.Count > 0) arr.RemoveAt(arr.Count - 1);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Size
libs: using System;|using System.Collections.Generic;
description: null

public static int HTVM_Size<T>(List<T> arr) {
    return arr.Count;
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Insert
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Insert<T>(List<T> arr, int index, T value) {
    arr.Insert(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Remove
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Remove<T>(List<T> arr, int index)
{
    if (index >= 0 && index < arr.Count)
    {
        arr.RemoveAt(index);
    }
}
funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_IndexOf
libs: using System;|using System.Collections.Generic;
description: null

public static int HTVM_IndexOf<T>(List<T> arr, T value) {
    return arr.IndexOf(value);
}

funcEND======================funcEND==============


func======================func==============
lang: java
name: HTVM_Append
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Append(ArrayList<T> arr, T value) {
    arr.add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Pop
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Pop(ArrayList<T> arr) {
    if (!arr.isEmpty()) arr.remove(arr.size() - 1);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Size
libs: import java.util.ArrayList;
description: null

public static <T> int HTVM_Size(ArrayList<T> arr) {
    return arr.size();
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Insert
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Insert(ArrayList<T> arr, int index, T value) {
    arr.add(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Remove
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Remove(ArrayList<T> arr, int index) {
    if (index >= 0 && index < arr.size()) {
        arr.remove(index);
    }
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_IndexOf
libs: import java.util.ArrayList;
description: null

public static <T> int HTVM_IndexOf(ArrayList<T> arr, T value) {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Append
libs: null
description: null

fun <T> HTVM_Append(arr: MutableList<T>, value: T) {
    arr.add(value)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Pop
libs: null
description: null

fun <T> HTVM_Pop(arr: MutableList<T>) {
    if (arr.isNotEmpty()) arr.removeAt(arr.lastIndex)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Size
libs: null
description: null

fun <T> HTVM_Size(arr: List<T>): Int {
    return arr.size
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Insert
libs: null
description: null

fun <T> HTVM_Insert(arr: MutableList<T>, index: Int, value: T) {
    arr.add(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Remove
libs: null
description: null

fun <T> HTVM_Remove(arr: MutableList<T>, index: Int) {
    if (index in arr.indices) {
        arr.removeAt(index)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_IndexOf
libs: null
description: null

fun <T> HTVM_IndexOf(arr: List<T>, value: T): Int {
    return arr.indexOf(value)
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value)
  arr << value
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr)
  arr.pop
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr)
  arr.size
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value)
  arr.insert(index, value)
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(arr, index)
  arr.delete_at(index) if index >= 0 && index < arr.length
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value)
  arr.index(value) || -1
end

funcEND======================funcEND==============


func======================func==============
lang: nim
name: HTVM_Append
libs: null
description: null

proc HTVM_Append[T](arr: var seq[T], value: T) =
  arr.add(value)



funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Pop
libs: null
description: null

proc HTVM_Pop[T](arr: var seq[T]) =
  if arr.len > 0: arr.setLen(arr.len - 1)

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Size
libs: null
description: null

proc HTVM_Size[T](arr: seq[T]): int =
  return arr.len

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Insert
libs: null
description: null

proc HTVM_Insert[T](arr: var seq[T], index: int, value: T) =
  if index >= 0 and index <= arr.len:
    arr.insert(value, index)  # Correct order


funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Remove
libs: null
description: null

proc HTVM_Remove[T](arr: var seq[T], index: int) =
  if index >= 0 and index < arr.len:
    arr.delete(index)

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_IndexOf
libs: null
description: null

proc HTVM_IndexOf[T](arr: seq[T], value: T): int =
  for i, v in arr:
    if v == value:
      return i
  return -1

funcEND======================funcEND==============


func======================func==============
lang: ahk
name: HTVM_Append
libs: null
description: null

HTVM_Append(arr, value) {
    arr.Push(value)
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Pop
libs: null
description: null

HTVM_Pop(arr) {
    arr.RemoveAt(arr.MaxIndex())
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Size
libs: null
description: null

HTVM_Size(arr) {
    return arr.Length()
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Insert
libs: null
description: null

HTVM_Insert(arr, index, value) {
    arr.InsertAt(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Remove
libs: null
description: null

HTVM_Remove(arr, index) {
    if (index >= 1 && index <= arr.Length())
        arr.RemoveAt(index)
    return arr
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_IndexOf
libs: null
description: null

HTVM_IndexOf(arr, value) {
    for k, v in arr {
        if (v = value)
            return k
    }
    return -1
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Append
libs: null
description: null

func HTVM_Append<T>(_ arr: inout [T], _ value: T) {
    arr.append(value)
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Pop
libs: null
description: null

func HTVM_Pop<T>(_ arr: inout [T]) {
    if !arr.isEmpty {
        arr.removeLast()
    }
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Size
libs: null
description: null

func HTVM_Size<T>(_ arr: [T]) -> Int {
    return arr.count
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Insert
libs: null
description: null

func HTVM_Insert<T>(_ arr: inout [T], _ index: Int, _ value: T) {
    arr.insert(value, at: index)
}

funcEND======================funcEND==============


func======================func==============
lang: swift
name: HTVM_Remove
libs: null
description: null

func HTVM_Remove<T>(_ arr: inout [T], _ index: Int) {
    if index >= 0 && index < arr.count {
        arr.remove(at: index)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_IndexOf
libs: null
description: null


func HTVM_IndexOf<T: Equatable>(_ arr: [T], _ value: T) -> Int {
    if let index = arr.firstIndex(of: value) {
        return index
    } else {
        return -1 // Return a default value if not found
    }
}


funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Append
libs: null
description: null

void HTVM_Append<T>(List<T> arr, T value) {
  arr.add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Pop
libs: null
description: null

void HTVM_Pop<T>(List<T> arr) {
  if (arr.isNotEmpty) arr.removeLast();
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Size
libs: null
description: null

int HTVM_Size<T>(List<T> arr) {
  return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Insert
libs: null
description: null

void HTVM_Insert<T>(List<T> arr, int index, T value) {
  arr.insert(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Remove
libs: null
description: null

void HTVM_Remove<T>(List<T> arr, int index) {
    if (index >= 0 && index < arr.length) {
        arr.removeAt(index);
    }
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_IndexOf
libs: null
description: null

int HTVM_IndexOf<T>(List<T> arr, T value) {
  return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Append
libs: null
description: null

function HTVM_Append<T>(arr: T[], value: T): void {
    arr.push(value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop<T>(arr: T[]): void {
    arr.pop();
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Size
libs: null
description: null

function HTVM_Size<T>(arr: T[]): number {
    return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert<T>(arr: T[], index: number, value: T): void {
    arr.splice(index, 0, value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr: any[], value: any): void {
    const index = arr.indexOf(value);
    if (index !== -1) arr.splice(index, 1);
}


funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf<T>(arr: T[], value: T): number {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value) {
    arr.add(value)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr) {
    if (!arr.isEmpty()) arr.remove(arr.size() - 1)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr) {
    return arr.size()
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value) {
    arr.add(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(list, index) {
    if (index >= 0 && index < list.size()) {
        list.remove(index)
    }
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value) {
    return arr.indexOf(value)
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: ErrorMsg
libs: null
description: null

// Function that throws an error with a string message
func ErrorMsg(_ message: String) throws {
    throw NSError(domain: "", code: 0, userInfo: [NSLocalizedDescriptionKey: message])
}
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: fstr
libs: null
description: null

template<typename T>
std::string fstr(const T& val) {
    std::ostringstream oss;
    oss << val;
    return oss.str();
}

funcEND======================funcEND==============

func======================func==============
lang: py
name: fstr
libs: null
description: null

def fstr(val):
    return str(val)

funcEND======================funcEND==============

func======================func==============
lang: js
name: fstr
libs: null
description: null

function fstr(val) {
    return String(val);
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: fstr
libs: null
description: null

func fstr(val interface{}) string {
    return fmt.Sprintf("%v", val)
}

funcEND======================funcEND==============

func======================func==============
lang: lua
name: fstr
libs: null
description: null

function fstr(val)
    return tostring(val)
end

funcEND======================funcEND==============

func======================func==============
lang: cs
name: fstr
libs: null
description: null

static string fstr(object val) {
    return val?.ToString() ?? "null";
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: fstr
libs: null
description: null

public static String fstr(Object val) {
    return String.valueOf(val);
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: fstr
libs: null
description: null

fun fstr(value: Any?): String {
    return value?.toString() ?: "null"
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: fstr
libs: null
description: null

def fstr(val)
  val.to_s
end

funcEND======================funcEND==============

func======================func==============
lang: nim
name: fstr
libs: null
description: null

proc fstr(val: auto): string =
  $val

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: fstr
libs: null
description: null

fstr(val) {
    return val . ""
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: fstr
libs: null
description: null

func fstr(_ val: Any) -> String {
    return String(describing: val)
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: fstr
libs: null
description: null

String fstr(dynamic val) {
  return val.toString();
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: fstr
libs: null
description: null

function fstr(val: any): string {
    return String(val);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: fstr
libs: null
description: null

def fstr(val) {
    return val.toString()
}

funcEND======================funcEND==============


func======================func==============
lang: go
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
func Abs[T int | float64](value T) T {
    if value < 0 {
        return -value
    }
    return value
}

funcEND======================funcEND==============
func======================func==============
lang: lua
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
function Abs(value)
    return math.abs(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Abs
libs: using System;
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
public static float Abs(float value) {
    return Math.Abs(value);
}

public static int Abs(int value) {
    return Math.Abs(value);
}

public static double Abs(double value) {
    return Math.Abs(value);
}

funcEND======================funcEND==============
func======================func==============
lang: java
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
public static double Abs(double value) {
    return Math.abs(value);
}

public static float Abs(float value) {
    return Math.abs(value);
}

public static int Abs(int value) {
    return Math.abs(value);
}

funcEND======================funcEND==============
func======================func==============
lang: kt
name: Abs
libs: import kotlin.math.abs
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
fun Abs(value: Float): Float = kotlin.math.abs(value)
fun Abs(value: Int): Int = kotlin.math.abs(value)
fun Abs(value: Double): Double = kotlin.math.abs(value)
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
def Abs(value)
  value.abs
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
proc Abs(value: float): float =
  result = abs(value)

proc Abs(value: int): int =
  result = abs(value)

funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
; used Abs
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Abs
libs: import Foundation
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
func Abs(_ value: Float) -> Float {
    return abs(value)
}

func Abs(_ value: Int) -> Int {
    return abs(value)
}

func Abs(_ value: Double) -> Double {
    return abs(value)
}

funcEND======================funcEND==============
func======================func==============
lang: dart
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~

dynamic Abs(dynamic value) {
  if (value is int) {
    return value.abs();
  } else if (value is double) {
    return value.abs();
  } else {
    throw ArgumentError('Unsupported type for Abs');
  }
}

funcEND======================funcEND==============
func======================func==============
lang: ts
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
function Abs(value: number): number {
    return Math.abs(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Abs
libs: null
description: math~~~Returns the absolute (non-negative) value of a number. For example, Abs(-5) is 5, and Abs(5) is 5.~~~Here is how to use it:~~~```htvm~~~float num1 := -10.5~~~float abs1 := Abs(num1)~~~; Expected: 10.5~~~print("Abs(-10.5) = " . STR(abs1))~~~if (abs1 != 10.5) {~~~    print("Abs test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int num2 := 7~~~int abs2 := Abs(num2)~~~; Expected: 7~~~print("Abs(7) = " . STR(abs2))~~~if (abs2 != 7) {~~~    print("Abs test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float abs3 := Abs(num3)~~~; Expected: 0.0~~~print("Abs(0.0) = " . STR(abs3))~~~if (abs3 != 0.0) {~~~    print("Abs test 3 FAILED!")~~~}~~~```~~~
double Abs(double value) {
    return Math.abs(value);
}
funcEND======================funcEND==============


func======================func==============
lang: go
name: ACos
libs: )|"math"
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func ACos[T int | float32 | float64](value T) float64 {
    return math.Acos(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
function ACos(value)
    return math.acos(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: ACos
libs: using System;
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
public static double ACos(double value) {
    return Math.Acos(value);
}

public static float ACos(float value) {
    return (float)Math.Acos(value);  // Explicit cast to float
}

public static float ACos(int value) {
    return (float)Math.Acos(value);  // Explicit cast to float
}

funcEND======================funcEND==============
func======================func==============
lang: java
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
public static double ACos(double value) {
    return Math.acos(value);
}

public static float ACos(float value) {
    return (float)Math.acos(value);  // Cast to float explicitly
}

public static float ACos(int value) {
    return (float)Math.acos(value);  // Cast to float explicitly
}

funcEND======================funcEND==============
func======================func==============
lang: kt
name: ACos
libs: import kotlin.math.acos
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
fun ACos(value: Double): Double = kotlin.math.acos(value)
fun ACos(value: Float): Float = kotlin.math.acos(value)
fun ACos(value: Int): Double = kotlin.math.acos(value.toDouble())
funcEND======================funcEND==============
func======================func==============
lang: rb
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
def ACos(value)
  if value < -1.0 || value > 1.0
    Float::NAN
  else
    Math.acos(value)
  end
end

funcEND======================funcEND==============
func======================func==============
lang: nim
name: ACos
libs: import math
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
proc ACos(value: float): float =
  result = math.arccos(value)

proc ACos(value: int): float =
  result = math.arccos(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
; built-in ACos() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: ACos
libs: import Foundation
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
func ACos(_ value: Double) -> Double {
    return acos(value)
}

func ACos(_ value: Float) -> Float {
    return acos(value)
}

func ACos(_ value: Int) -> Double {
    return acos(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: ACos
libs: import 'dart:math';
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
// The built-in acos function from 'dart:math' accepts a 'num' type.
double ACos(dynamic value) {
  if (value is num) {
    return acos(value);
  } else {
    throw ArgumentError('Unsupported type for ACos. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
function ACos(value: number): number {
    return Math.acos(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: ACos
libs: null
description: math~~~Calculates the arc cosine (inverse cosine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ACos(val1)~~~; Expected: approx 1.04719755~~~print("ACos(0.5) = " . STR(result1))~~~if (Abs(result1 - 1.04719755) > 0.00001) { ~~~    print("ACos test 1 FAILED!") ~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ACos(val2)~~~; Expected: approx 3.14159265 (pi)~~~print("ACos(-1.0) = " . STR(result2)) ~~~if (Abs(result2 - 3.14159265) > 0.00001) {~~~    print("ACos test 2 FAILED!") ~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary by target language: error or NaN)~~~float val3 := 2.0~~~; This would typically result in NaN or an error~~~float result3 := ACos(val3)~~~print("ACos(2.0) = " . STR(result3))~~~```~~~
// Groovy can leverage Java's Math.acos which takes a double.
def ACos(value) {
    return Math.acos(value as double)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: ASin
libs: )|"math"
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func ASin[T int | float32 | float64](value T) float64 {
    return math.Asin(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
function ASin(value)
    return math.asin(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: ASin
libs: using System;
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
public static double ASin(double value) {
    return Math.Asin(value);
}

public static float ASin(float value) {
    return (float)Math.Asin(value);
}

public static float ASin(int value) {
    return (float)Math.Asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
public static double ASin(double value) {
    return Math.asin(value);
}

public static float ASin(float value) {
    return (float)Math.asin(value);
}

public static float ASin(int value) {
    return (float)Math.asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: ASin
libs: import kotlin.math.asin
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
fun ASin(value: Double): Double = kotlin.math.asin(value)
fun ASin(value: Float): Float = kotlin.math.asin(value)
fun ASin(value: Int): Double = kotlin.math.asin(value.toDouble())
funcEND======================funcEND==============
func======================func==============
lang: rb
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
def ASin(value)
  if value < -1.0 || value > 1.0
    Float::NAN
  else
    Math.asin(value)
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: ASin
libs: import math
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
proc ASin(value: float): float =
  result = math.arcsin(value)

proc ASin(value: int): float =
  result = math.arcsin(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
; built-in ASin() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: ASin
libs: import Foundation
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
func ASin(_ value: Double) -> Double {
    return asin(value)
}

func ASin(_ value: Float) -> Float {
    return asin(value)
}

func ASin(_ value: Int) -> Double {
    return asin(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: ASin
libs: import 'dart:math';
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
double ASin(dynamic value) {
  if (value is num) {
    return asin(value);
  } else {
    throw ArgumentError('Unsupported type for ASin. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
function ASin(value: number): number {
    return Math.asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: ASin
libs: null
description: math~~~Calculates the arc sine (inverse sine) of a number. The input must be between -1 and 1, inclusive. The result is in radians.~~~Here is how to use it:~~~```htvm~~~float val1 := 0.5~~~float result1 := ASin(val1)~~~; Expected: approx 0.52359877~~~print("ASin(0.5) = " . STR(result1))~~~if (Abs(result1 - 0.52359877) > 0.00001) {~~~    print("ASin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := -1.0~~~float result2 := ASin(val2)~~~; Expected: approx -1.57079632 ( -pi / 2)~~~print("ASin(-1.0) = " . STR(result2))~~~if (Abs(result2 - (-1.57079632)) > 0.00001) {~~~    print("ASin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid input (behavior might vary: error or NaN)~~~float val3 := 1.5~~~float result3 := ASin(val3)~~~print("ASin(1.5) = " . STR(result3))~~~```~~~
def ASin(value) {
    return Math.asin(value as double)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: ATan
libs: )|"math"
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func ATan[T int | float32 | float64](value T) float64 {
    return math.Atan(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
function ATan(value)
    return math.atan(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: ATan
libs: using System;
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
public static double ATan(double value) {
    return Math.Atan(value);
}

public static float ATan(float value) {
    return (float)Math.Atan(value);
}

public static float ATan(int value) {
    return (float)Math.Atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
public static double ATan(double value) {
    return Math.atan(value);
}

public static float ATan(float value) {
    return (float)Math.atan(value);
}

public static float ATan(int value) {
    return (float)Math.atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: ATan
libs: import kotlin.math.atan
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
fun ATan(value: Double): Double = kotlin.math.atan(value)
fun ATan(value: Float): Float = kotlin.math.atan(value)
fun ATan(value: Int): Double = kotlin.math.atan(value.toDouble())
funcEND======================funcEND==============
func======================func==============
lang: rb
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
def ATan(value)
  Math.atan(value)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: ATan
libs: import math
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
proc ATan(value: float): float =
  result = math.arctan(value)

proc ATan(value: int): float =
  result = math.arctan(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
; built-in ATan() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: ATan
libs: import Foundation
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
func ATan(_ value: Double) -> Double {
    return atan(value)
}

func ATan(_ value: Float) -> Float {
    return atan(value)
}

func ATan(_ value: Int) -> Double {
    return atan(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: ATan
libs: import 'dart:math';
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
double ATan(dynamic value) {
  if (value is num) {
    return atan(value);
  } else {
    throw ArgumentError('Unsupported type for ATan. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
function ATan(value: number): number {
    return Math.atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: ATan
libs: null
description: math~~~Calculates the arc tangent (inverse tangent) of a number. The result is in radians, ranging from -PI/2 to PI/2.~~~Here is how to use it:~~~```htvm~~~float val1 := 1.0~~~float result1 := ATan(val1)~~~; Expected: approx 0.78539816 (pi / 4)~~~print("ATan(1.0) = " . STR(result1))~~~if (Abs(result1 - 0.78539816) > 0.00001) {~~~    print("ATan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 0.0~~~float result2 := ATan(val2)~~~; Expected: 0.0~~~print("ATan(0.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("ATan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := -1.0~~~float result3 := ATan(val3)~~~; Expected: approx -0.78539816 (-pi / 4)~~~print("ATan(-1.0) = " . STR(result3))~~~if (Abs(result3 - (-0.78539816)) > 0.00001) {~~~    print("ATan test 3 FAILED!")~~~}~~~```~~~
def ATan(value) {
    return Math.atan(value as double)
}
funcEND======================funcEND==============




func======================func==============
lang: go
name: Ceil
libs: )|"math"
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Ceil[T int | float32 | float64](value T) float64 {
    return math.Ceil(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
function Ceil(value)
    return math.ceil(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Ceil
libs: using System;
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
public static double Ceil(double value) {
    return Math.Ceiling(value);
}

public static float Ceil(float value) {
    return (float)Math.Ceiling(value);
}

public static int Ceil(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
public static double Ceil(double value) {
    return Math.ceil(value);
}

public static float Ceil(float value) {
    return (float)Math.ceil(value);
}

public static int Ceil(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Ceil
libs: import kotlin.math.ceil
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
fun Ceil(value: Double): Double = kotlin.math.ceil(value)
fun Ceil(value: Float): Float = kotlin.math.ceil(value)
fun Ceil(value: Int): Int = value
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
def Ceil(value)
  value.ceil
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Ceil
libs: import math
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
proc Ceil(value: float): float =
  result = math.ceil(value)

proc Ceil(value: int): int =
  result = value
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
; built-in Ceil() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Ceil
libs: import Foundation
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
func Ceil(_ value: Double) -> Double {
    return ceil(value)
}

func Ceil(_ value: Float) -> Float {
    return ceil(value)
}

func Ceil(_ value: Int) -> Int {
    return value
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
// Generic ceil function
double Ceil<T extends num>(T value) {
  if (value is int) {
    return value.toDouble(); // no change needed, already an integer
  } else if (value is double) {
    return value.ceilToDouble(); // apply actual ceiling logic
  } else {
    throw ArgumentError("Unsupported numeric type");
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
function Ceil(value: number): number {
    return Math.ceil(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Ceil
libs: null
description: math~~~Returns the smallest integer greater than or equal to the given number (rounds up to the nearest integer). For example, Ceil(4.2) is 5, and Ceil(-4.8) is -4.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float ceil1 := Ceil(num1)~~~; Expected: 5.0 (or 5 depending on language float/int conversion)~~~print("Ceil(4.2) = " . STR(ceil1))~~~if (ceil1 != 5.0) {~~~    print("Ceil test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.8~~~float ceil2 := Ceil(num2)~~~; Expected: -4.0~~~print("Ceil(-4.8) = " . STR(ceil2))~~~if (ceil2 != -4.0) {~~~    print("Ceil test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float ceil3 := Ceil(num3)~~~; Expected: 7.0~~~print("Ceil(7.0) = " . STR(ceil3))~~~if (ceil3 != 7.0) {~~~    print("Ceil test 3 FAILED!")~~~}~~~```~~~
def Ceil(value) {
    return Math.ceil(value)
}
funcEND======================funcEND==============


func======================func==============
lang: go
name: Cos
libs: )|"math"
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Cos[T int | float32 | float64](angle T) float64 {
    return math.Cos(float64(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
function Cos(angle)
    return math.cos(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Cos
libs: using System;
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
public static double Cos(double angle) {
    return Math.Cos(angle);
}

public static float Cos(float angle) {
    return (float)Math.Cos(angle);
}

public static float Cos(int angle) {
    return (float)Math.Cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
public static double Cos(double angle) {
    return Math.cos(angle);
}

public static float Cos(float angle) {
    return (float)Math.cos(angle);
}

public static float Cos(int angle) {
    return (float)Math.cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Cos
libs: import kotlin.math.cos
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
fun Cos(angle: Double): Double = kotlin.math.cos(angle)
fun Cos(angle: Float): Float = kotlin.math.cos(angle)
fun Cos(angle: Int): Double = kotlin.math.cos(angle.toDouble())
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
def Cos(angle)
  Math.cos(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Cos
libs: import math
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
proc Cos(angle: float): float =
  result = math.cos(angle)

proc Cos(angle: int): float =
  result = math.cos(float(angle))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
; built-in Cos() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Cos
libs: import Foundation
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
func Cos(_ angle: Double) -> Double {
    return cos(angle)
}

func Cos(_ angle: Float) -> Float {
    return cos(angle)
}

func Cos(_ angle: Int) -> Double {
    return cos(Double(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Cos
libs: import 'dart:math';
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
double Cos(dynamic value) {
  if (value is num) {
    return cos(value);
  } else {
    throw ArgumentError('Unsupported type for Cos. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
function Cos(angle: number): number {
    return Math.cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Cos
libs: null
description: math~~~Calculates the cosine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Cos(angle1)~~~; Expected: 1.0~~~print("Cos(0.0) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Cos test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Cos(angle2)~~~; Expected: approx 0.0~~~print("Cos(pi/2) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Cos test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Cos(angle3)~~~; Expected: -1.0~~~print("Cos(pi) = " . STR(result3))~~~if (Abs(result3 - (-1.0)) > 0.00001) {~~~    print("Cos test 3 FAILED!")~~~}~~~```~~~
def Cos(value) {
    return Math.cos(value as double)
}
funcEND======================funcEND==============


func======================func==============
lang: go
name: Exp
libs: )|"math"
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Exp[T int | float32 | float64](value T) float64 {
    return math.Exp(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
function Exp(value)
    return math.exp(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Exp
libs: using System;
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
public static double Exp(double value) {
    return Math.Exp(value);
}

public static float Exp(float value) {
    return (float)Math.Exp(value);
}

public static float Exp(int value) {
    return (float)Math.Exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
public static double Exp(double value) {
    return Math.exp(value);
}

public static float Exp(float value) {
    return (float)Math.exp(value);
}

public static float Exp(int value) {
    return (float)Math.exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Exp
libs: import kotlin.math.exp
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
fun Exp(value: Double): Float = kotlin.math.exp(value).toFloat()
fun Exp(value: Float): Float = kotlin.math.exp(value.toDouble()).toFloat()
fun Exp(value: Int): Float = kotlin.math.exp(value.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
def Exp(value)
  Math.exp(value)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Exp
libs: import math
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
proc Exp(value: float): float =
  result = math.exp(value)

proc Exp(value: int): float =
  result = math.exp(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
; built-in Exp() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Exp
libs: import Foundation
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
func Exp(_ value: Double) -> Double {
    return exp(value)
}

func Exp(_ value: Float) -> Float {
    return exp(value)
}

func Exp(_ value: Int) -> Double {
    return exp(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Exp
libs: import 'dart:math';
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
double Exp(dynamic value) {
  if (value is num) {
    return exp(value);
  } else {
    throw ArgumentError('Unsupported type for Exp. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
function Exp(value: number): number {
    return Math.exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Exp
libs: null
description: math~~~Calculates Euler's number 'e' (approx. 2.71828) raised to the power of the given number. Exp(1) is 'e', Exp(0) is 1.~~~Here is how to use it:~~~```htvm~~~float num1 := 1.0~~~float result1 := Exp(num1)~~~; Expected: approx 2.71828~~~print("Exp(1.0) = " . STR(result1))~~~if (Abs(result1 - 2.71828) > 0.00001) {~~~    print("Exp test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 0.0~~~float result2 := Exp(num2)~~~; Expected: 1.0~~~print("Exp(0.0) = " . STR(result2))~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Exp test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 2.0~~~float result3 := Exp(num3)~~~; Expected: approx 7.38905 (e*e)~~~print("Exp(2.0) = " . STR(result3))~~~if (Abs(result3 - 7.389056) > 0.00001) {~~~    print("Exp test 3 FAILED!")~~~}~~~```~~~
def Exp(value) {
    return Math.exp(value as double)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: Ln
libs: )|"math"
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Ln[T int | float32 | float64](value T) float64 {
    return math.Log(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
function Ln(value)
    return math.log(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Ln
libs: using System;
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
public static double Ln(double value) {
    return Math.Log(value);
}

public static float Ln(float value) {
    return (float)Math.Log(value);
}

public static float Ln(int value) {
    return (float)Math.Log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
public static double Ln(double value) {
    return Math.log(value);
}

public static float Ln(float value) {
    return (float)Math.log(value);
}

public static float Ln(int value) {
    return (float)Math.log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Ln
libs: import kotlin.math.ln
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
fun Ln(value: Double): Float = kotlin.math.ln(value).toFloat()
fun Ln(value: Float): Float = kotlin.math.ln(value)
fun Ln(value: Int): Float = kotlin.math.ln(value.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
def Ln(value)
  if value <= 0
    Float::NAN
  else
    Math.log(value)
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Ln
libs: import math
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
proc Ln(value: float): float =
  result = math.ln(value)

proc Ln(value: int): float =
  result = math.ln(float(value))

funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
; built-in Ln() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Ln
libs: import Foundation
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
func Ln(_ value: Double) -> Double {
    return log(value)
}

func Ln(_ value: Float) -> Float {
    return log(value)
}

func Ln(_ value: Int) -> Double {
    return log(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Ln
libs: import 'dart:math';
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
double Ln(dynamic value) {
  if (value is num) {
    return log(value);
  } else {
    throw ArgumentError('Unsupported type for Ln. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
function Ln(value: number): number {
    return Math.log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Ln
libs: null
description: math~~~Calculates the natural logarithm (logarithm base 'e') of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float e_approx := 2.718281828~~~float val1 := e_approx~~~float result1 := Ln(val1)~~~; Expected: approx 1.0~~~print("Ln(e) = " . STR(result1))~~~if (Abs(result1 - 1.0) > 0.00001) {~~~    print("Ln test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Ln(val2)~~~; Expected: 0.0~~~print("Ln(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Ln test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10.0~~~float result3 := Ln(val3)~~~; Expected: approx 2.302585~~~print("Ln(10.0) = " . STR(result3))~~~if (Abs(result3 - 2.302585) > 0.00001) {~~~    print("Ln test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Ln(0.0) = " . STR(Ln(val4)))~~~```~~~
def Ln(value) {
    return Math.log(value as double)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: Log
libs: )|"math"
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Log[T int | float32 | float64](value T) float64 {
    return math.Log10(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
function Log(value)
    return math.log10(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Log
libs: using System;
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
public static double Log(double value) {
    return Math.Log10(value);
}

public static float Log(float value) {
    return (float)Math.Log10(value);
}

public static float Log(int value) {
    return (float)Math.Log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
public static double Log(double value) {
    return Math.log10(value);
}

public static float Log(float value) {
    return (float)Math.log10(value);
}

public static float Log(int value) {
    return (float)Math.log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Log
libs: import kotlin.math.log10
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
fun Log(value: Double): Float = kotlin.math.log10(value).toFloat()
fun Log(value: Float): Float = kotlin.math.log10(value)
fun Log(value: Int): Float = kotlin.math.log10(value.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
def Log(value)
  if value <= 0
    Float::NAN
  else
    Math.log10(value)
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Log
libs: import math
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
proc Log(value: float): float =
  result = math.log10(value)

proc Log(value: int): float =
  result = math.log10(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
; built-in Log() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Log
libs: import Foundation
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
func Log(_ value: Double) -> Double {
    return log10(value)
}

func Log(_ value: Float) -> Float {
    return log10(value)
}

func Log(_ value: Int) -> Double {
    return log10(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Log
libs: import 'dart:math';
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
double Log(dynamic value) {
  if (value is num) {
    return log(value) / ln10;
  } else {
    throw ArgumentError('Unsupported type for Log. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
function Log(value: number): number {
    return Math.log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Log
libs: null
description: math~~~Calculates the base-10 logarithm of a number. The input must be a positive number.~~~Here is how to use it:~~~```htvm~~~float val1 := 100.0~~~float result1 := Log(val1)~~~; Expected: 2.0~~~print("Log(100.0) = " . STR(result1))~~~if (Abs(result1 - 2.0) > 0.00001) {~~~    print("Log test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val2 := 1.0~~~float result2 := Log(val2)~~~; Expected: 0.0~~~print("Log(1.0) = " . STR(result2))~~~if (Abs(result2 - 0.0) > 0.00001) {~~~    print("Log test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float val3 := 10000.0~~~float result3 := Log(val3)~~~; Expected: 4.0~~~print("Log(10000.0) = " . STR(result3))~~~if (Abs(result3 - 4.0) > 0.00001) {~~~    print("Log test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Invalid input (0 or negative) would typically cause an error or return NaN/Infinity~~~float val4 := 0.0~~~print("Log(0.0) = " . STR(Log(val4)))~~~```~~~
def Log(value) {
    return Math.log10(value as double)
}
funcEND======================funcEND==============






func======================func==============
lang: go
name: Round
libs: )|"math"
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
// Generic function to round away from zero to match common expectations.
func Round[T int | float32 | float64](value T) float64 {
	val64 := float64(value)
	if val64 < 0 {
		return math.Ceil(val64 - 0.5)
	}
	return math.Floor(val64 + 0.5)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
function Round(value)
    if value >= 0 then
        return math.floor(value + 0.5)
    else
        return math.ceil(value - 0.5)
    end
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Round
libs: using System;
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
public static double Round(double value) {
    return Math.Round(value, MidpointRounding.AwayFromZero);
}

public static float Round(float value) {
    return (float)Math.Round(value, MidpointRounding.AwayFromZero);
}

public static int Round(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
public static double Round(double value) {
    return Math.round(value);
}

public static float Round(float value) {
    return Math.round(value);
}

public static int Round(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Round
libs: import kotlin.math.round
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
fun Round(value: Double): Double = kotlin.math.round(value)
fun Round(value: Float): Float = kotlin.math.round(value)
fun Round(value: Int): Int = value
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
def Round(value)
  value.round
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Round
libs: import math
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
# Nim's math.round is round-to-even, so we implement round-away-from-zero
proc Round(value: float): float =
  if value >= 0.0:
    result = floor(value + 0.5)
  else:
    result = ceil(value - 0.5)

proc Round(value: int): int =
  result = value
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
; built-in Round() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Round
libs: import Foundation
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
func Round(_ value: Double) -> Double {
    return value.rounded(.toNearestOrAwayFromZero)
}

func Round(_ value: Float) -> Float {
    return value.rounded(.toNearestOrAwayFromZero)
}

func Round(_ value: Int) -> Int {
    return value // already an integer, no rounding needed
}

funcEND======================funcEND==============
func======================func==============
lang: dart
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
double Round(dynamic value) {
  if (value is num) {
    return value.roundToDouble();
  } else {
    throw ArgumentError('Unsupported type for Round. Must be a number.');
  }
}

funcEND======================funcEND==============
func======================func==============
lang: ts
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
function Round(value: number): number {
    return Math.round(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Round
libs: null
description: math~~~Rounds a number to the nearest integer. Numbers ending in .5 are typically rounded up (away from zero).~~~Here is how to use it:~~~```htvm~~~float num1 := 4.2~~~float round1 := Round(num1)~~~; Expected: 4.0 (or 4)~~~print("Round(4.2) = " . STR(round1))~~~if (round1 != 4.0) {~~~    print("Round test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 4.8~~~float round2 := Round(num2)~~~; Expected: 5.0~~~print("Round(4.8) = " . STR(round2))~~~if (round2 != 5.0) {~~~    print("Round test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 4.5~~~float round3 := Round(num3)~~~; Expected: 5.0 (common rounding rule)~~~print("Round(4.5) = " . STR(round3))~~~if (round3 != 5.0) {~~~    print("Round test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num4 := -4.5~~~float round4 := Round(num4)~~~; Expected: -5.0 (common rounding away from zero for .5) or -4.0 (round half to even)~~~; This behavior can vary, so the test is lenient.~~~print("Round(-4.5) result: " . STR(round4))~~~if (round4 != -4.0 and round4 != -5.0) {~~~    print("Round test 4 FAILED!")~~~}~~~```~~~
def Round(value) {
    return value.round()
}
funcEND======================funcEND==============









func======================func==============
lang: go
name: Sin
libs: )|"math"
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Sin[T int | float32 | float64](angle T) float64 {
    return math.Sin(float64(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
function Sin(angle)
    return math.sin(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Sin
libs: using System;
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
public static double Sin(double angle) {
    return Math.Sin(angle);
}

public static float Sin(float angle) {
    return (float)Math.Sin(angle);
}

public static float Sin(int angle) {
    return (float)Math.Sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
public static double Sin(double angle) {
    return Math.sin(angle);
}

public static float Sin(float angle) {
    return (float)Math.sin(angle);
}

public static float Sin(int angle) {
    return (float)Math.sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Sin
libs: import kotlin.math.sin
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
fun Sin(angle: Double): Float = kotlin.math.sin(angle).toFloat()
fun Sin(angle: Float): Float = kotlin.math.sin(angle)
fun Sin(angle: Int): Float = kotlin.math.sin(angle.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
def Sin(angle)
  Math.sin(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Sin
libs: import math
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
proc Sin(angle: float): float =
  result = math.sin(angle)

proc Sin(angle: int): float =
  result = math.sin(float(angle))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
; built-in Sin() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Sin
libs: import Foundation
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
func Sin(_ angle: Double) -> Double {
    return sin(angle)
}

func Sin(_ angle: Float) -> Float {
    return sin(angle)
}

func Sin(_ angle: Int) -> Double {
    return sin(Double(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Sin
libs: import 'dart:math';
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
double Sin(dynamic value) {
  if (value is num) {
    return sin(value);
  } else {
    throw ArgumentError('Unsupported type for Sin. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
function Sin(angle: number): number {
    return Math.sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Sin
libs: null
description: math~~~Calculates the sine of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Sin(angle1)~~~print("Sin(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Sin test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle2 := pi / 2.0~~~; 90 degrees~~~float result2 := Sin(angle2)~~~print("Sin(pi/2) = " . STR(result2))~~~; Expected: 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Sin test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float angle3 := pi~~~; 180 degrees~~~float result3 := Sin(angle3)~~~print("Sin(pi) = " . STR(result3))~~~; Expected: approx 0.0~~~if (Abs(result3 - 0.0) > 0.00001) {~~~    print("Sin test 3 FAILED!")~~~}~~~```~~~
def Sin(value) {
    return Math.sin(value as double)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: Sqrt
libs: )|"math"
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Sqrt[T int | float32 | float64](value T) float64 {
    return math.Sqrt(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
function Sqrt(value)
    return math.sqrt(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Sqrt
libs: using System;
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
public static double Sqrt(double value) {
    return Math.Sqrt(value);
}

public static float Sqrt(float value) {
    return (float)Math.Sqrt(value);
}

public static float Sqrt(int value) {
    return (float)Math.Sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
public static double Sqrt(double value) {
    return Math.sqrt(value);
}

public static float Sqrt(float value) {
    return (float)Math.sqrt(value);
}

public static float Sqrt(int value) {
    return (float)Math.sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Sqrt
libs: import kotlin.math.sqrt
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
fun Sqrt(value: Double): Float = kotlin.math.sqrt(value).toFloat()
fun Sqrt(value: Float): Float = kotlin.math.sqrt(value)
fun Sqrt(value: Int): Float = kotlin.math.sqrt(value.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
def Sqrt(value)
  if value < 0
    Float::NAN
  else
    Math.sqrt(value)
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Sqrt
libs: import math
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
proc Sqrt(value: float): float =
  result = math.sqrt(value)

proc Sqrt(value: int): float =
  result = math.sqrt(float(value))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
; built-in Sqrt() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Sqrt
libs: import Foundation
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
func Sqrt(_ value: Double) -> Double {
    return sqrt(value)
}

func Sqrt(_ value: Float) -> Float {
    return sqrt(value)
}

func Sqrt(_ value: Int) -> Double {
    return sqrt(Double(value))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Sqrt
libs: import 'dart:math';
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
double Sqrt(dynamic value) {
  if (value is num) {
    return sqrt(value);
  } else {
    throw ArgumentError('Unsupported type for Sqrt. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
function Sqrt(value: number): number {
    return Math.sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Sqrt
libs: null
description: math~~~Calculates the square root of a non-negative number. Inputting a negative number will typically result in NaN or an error.~~~Here is how to use it:~~~```htvm~~~float num1 := 9.0~~~float sqrt1 := Sqrt(num1)~~~print("Sqrt(9.0) = " . STR(sqrt1))~~~; Expected: 3.0~~~if (Abs(sqrt1 - 3.0) > 0.00001) {~~~    print("Sqrt test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := 2.0~~~float sqrt2 := Sqrt(num2)~~~print("Sqrt(2.0) = " . STR(sqrt2))~~~; Expected: approx 1.41421356~~~if (Abs(sqrt2 - 1.41421356) > 0.00001) {~~~    print("Sqrt test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 0.0~~~float sqrt3 := Sqrt(num3)~~~print("Sqrt(0.0) = " . STR(sqrt3))~~~; Expected: 0.0~~~if (Abs(sqrt3 - 0.0) > 0.00001) {~~~    print("Sqrt test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of invalid input (behavior might vary: error or NaN)~~~float num4 := -4.0~~~float sqrt4 := Sqrt(num4)~~~print("Sqrt(-4.0) = " . STR(sqrt4))~~~```~~~
def Sqrt(value) {
    return Math.sqrt(value as double)
}
funcEND======================funcEND==============









func======================func==============
lang: go
name: Tan
libs: )|"math"
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Tan[T int | float32 | float64](angle T) float64 {
    return math.Tan(float64(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
function Tan(angle)
    return math.tan(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Tan
libs: using System;
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
public static double Tan(double angle) {
    return Math.Tan(angle);
}

public static float Tan(float angle) {
    return (float)Math.Tan(angle);
}

public static float Tan(int angle) {
    return (float)Math.Tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
public static double Tan(double angle) {
    return Math.tan(angle);
}

public static float Tan(float angle) {
    return (float)Math.tan(angle);
}

public static float Tan(int angle) {
    return (float)Math.tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Tan
libs: import kotlin.math.tan
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
fun Tan(angle: Double): Float = kotlin.math.tan(angle).toFloat()
fun Tan(angle: Float): Float = kotlin.math.tan(angle)
fun Tan(angle: Int): Float = kotlin.math.tan(angle.toDouble()).toFloat()
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
def Tan(angle)
  Math.tan(angle)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Tan
libs: import math
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
proc Tan(angle: float): float =
  result = math.tan(angle)

proc Tan(angle: int): float =
  result = math.tan(float(angle))
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
; built-in Tan() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Tan
libs: import Foundation
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
func Tan(_ angle: Double) -> Double {
    return tan(angle)
}

func Tan(_ angle: Float) -> Float {
    return tan(angle)
}

func Tan(_ angle: Int) -> Double {
    return tan(Double(angle))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Tan
libs: import 'dart:math';
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
double Tan(dynamic value) {
  if (value is num) {
    return tan(value);
  } else {
    throw ArgumentError('Unsupported type for Tan. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
function Tan(angle: number): number {
    return Math.tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Tan
libs: null
description: math~~~Calculates the tangent of an angle. The input angle must be in radians.~~~Here is how to use it:~~~```htvm~~~float pi := 3.1415926535~~~float angle1 := 0.0~~~float result1 := Tan(angle1)~~~print("Tan(0.0) = " . STR(result1))~~~; Expected: 0.0~~~if (Abs(result1 - 0.0) > 0.00001) {~~~    print("Tan test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; 45 degrees~~~float angle2 := pi / 4.0~~~float result2 := Tan(angle2)~~~print("Tan(pi/4) = " . STR(result2))~~~; Expected: approx 1.0~~~if (Abs(result2 - 1.0) > 0.00001) {~~~    print("Tan test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Tan(pi/2) is undefined (approaches infinity). Behavior might vary.~~~float angle3 := pi / 2.0~~~float result3 := Tan(angle3)~~~print("Tan(pi/2) = " . STR(result3))~~~```~~~
def Tan(value) {
    return Math.tan(value as double)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: Floor
libs: )|"math"
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
// Generic function to handle int, float32, and float64 by converting to float64
func Floor[T int | float32 | float64](value T) float64 {
    return math.Floor(float64(value))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
function Floor(value)
    return math.floor(value)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Floor
libs: using System;
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
public static double Floor(double value) {
    return Math.Floor(value);
}

public static float Floor(float value) {
    return (float)Math.Floor(value);
}

public static int Floor(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
public static double Floor(double value) {
    return Math.floor(value);
}

public static float Floor(float value) {
    return (float)Math.floor(value);
}

public static int Floor(int value) {
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Floor
libs: import kotlin.math.floor
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
fun Floor(value: Double): Double = kotlin.math.floor(value)
fun Floor(value: Float): Float = kotlin.math.floor(value)
fun Floor(value: Int): Int = value
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
def Floor(value)
  value.floor
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Floor
libs: import math
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
proc Floor(value: float): float =
  result = math.floor(value)

proc Floor(value: int): int =
  result = value
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
; built-in Floor() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Floor
libs: import Foundation
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
func Floor(_ value: Double) -> Double {
    return floor(value)
}

func Floor(_ value: Float) -> Float {
    return floor(value)
}

func Floor(_ value: Int) -> Int {
    return value
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
double Floor(dynamic value) {
  if (value is num) {
    return value.floorToDouble();
  } else {
    throw ArgumentError('Unsupported type for Floor. Must be a number.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
function Floor(value: number): number {
    return Math.floor(value);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Floor
libs: null
description: math~~~Returns the largest integer less than or equal to the given number (rounds down to the nearest integer). For example, Floor(4.8) is 4, and Floor(-4.2) is -5.~~~Here is how to use it:~~~```htvm~~~float num1 := 4.8~~~float floor1 := Floor(num1)~~~; Expected: 4.0 (or 4)~~~print("Floor(4.8) = " . STR(floor1))~~~if (floor1 != 4.0) {~~~    print("Floor test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num2 := -4.2~~~float floor2 := Floor(num2)~~~; Expected: -5.0~~~print("Floor(-4.2) = " . STR(floor2))~~~if (floor2 != -5.0) {~~~    print("Floor test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~float num3 := 7.0~~~float floor3 := Floor(num3)~~~; Expected: 7.0~~~print("Floor(7.0) = " . STR(floor3))~~~if (floor3 != 7.0) {~~~    print("Floor test 3 FAILED!")~~~}~~~```~~~
def Floor(value) {
    return Math.floor(value as double)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
func Mod(dividend, divisor int) int {
    return dividend % divisor
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
function Mod(dividend, divisor)
    return dividend % divisor
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
public static int Mod(int dividend, int divisor) {
    return dividend % divisor;
}
public static float Mod(float dividend, float divisor) {
    return dividend % divisor;
}
public static double Mod(double dividend, double divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
public static int Mod(int dividend, int divisor) {
    return dividend % divisor;
}
public static float Mod(float dividend, float divisor) {
    return dividend % divisor;
}
public static double Mod(double dividend, double divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
fun Mod(dividend: Int, divisor: Int): Int = dividend % divisor
fun Mod(dividend: Float, divisor: Float): Float = dividend % divisor
fun Mod(dividend: Double, divisor: Double): Double = dividend % divisor
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
def Mod(dividend, divisor)
  dividend % divisor
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Mod
libs: import math
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
proc Mod(dividend: int, divisor: int): int =
  result = dividend mod divisor

proc Mod(dividend: float, divisor: float): float =
  result = dividend mod divisor
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
; built-in Mod() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
func Mod(_ dividend: Int, _ divisor: Int) -> Int {
    return dividend % divisor
}
func Mod(_ dividend: Double, _ divisor: Double) -> Double {
    return dividend.truncatingRemainder(dividingBy: divisor)
}
func Mod(_ dividend: Float, _ divisor: Float) -> Float {
    return dividend.truncatingRemainder(dividingBy: divisor)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
dynamic Mod(dynamic dividend, dynamic divisor) {
  if (dividend is num && divisor is num) {
    return dividend % divisor;
  } else {
    throw ArgumentError('Unsupported types for Mod. Both must be numbers.');
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
function Mod(dividend: number, divisor: number): number {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Mod
libs: null
description: math~~~Calculates the modulus (remainder of a division) of two numbers: `dividend` Mod `divisor`. For example, `10 Mod 3` is 1. The modulus operation gives the remainder after division. Also in HTVM, you can still use the **modular operator** to calculate the remainder of a division.~~~Here is how to use it:~~~```htvm~~~; Test 1: Modulus with positive numbers~~~int dividend1 := 10~~~int divisor1 := 3~~~int result1 := Mod(dividend1, divisor1)~~~; Expected: 1~~~print("10 Mod 3 = " . STR(result1))~~~if (result1 != 1) {~~~    print("Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 2: Modulus with larger dividend~~~int dividend2 := 17~~~int divisor2 := 5~~~int result2 := Mod(dividend2, divisor2)~~~; Expected: 2~~~print("17 Mod 5 = " . STR(result2))~~~if (result2 != 2) {~~~    print("Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Test 3: Modulus with a negative dividend~~~int dividend3 := -10~~~int divisor3 := 3~~~int result3 := Mod(dividend3, divisor3)~~~; Note: Result with negative numbers can vary by language. Common result: -1 or 2~~~; For this test, let's assume a common behavior, but be aware it might differ.~~~print("Mod test 3 result for -10 Mod 3: " . STR(result3))~~~; ----------------------------------------------------~~~; Test 4: Modulus with a negative divisor~~~int dividend4 := 10~~~int divisor4 := -3~~~int result4 := Mod(dividend4, divisor4)~~~; Common result: 1 or -2~~~print("Mod test 4 result for 10 Mod -3: " . STR(result4))~~~; ----------------------------------------------------~~~; IMPORTANT: You can also use the modular operator like this:~~~int result1_percent := dividend1 % divisor1~~~; Expected: 1~~~print("10 % 3 = " . STR(result1_percent))~~~if (result1_percent != 1) {~~~    print("Percent Mod test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result2_percent := dividend2 % divisor2~~~; Expected: 2~~~print("17 % 5 = " . STR(result2_percent))~~~if (result2_percent != 2) {~~~    print("Percent Mod test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int result3_percent := dividend3 % divisor3~~~; Common result: -1 or 2~~~print("Percent Mod test 3 result for -10 % 3: " . STR(result3_percent))~~~; ----------------------------------------------------~~~int result4_percent := dividend4 % divisor4~~~; Common result: 1 or -2~~~print("Percent Mod test 4 result for 10 % -3: " . STR(result4_percent))~~~; ----------------------------------------------------~~~; ----------------------------------------------------~~~; Even or Odd Number Check in a Loop (0 to 4)~~~; This loop checks if the numbers from 0 to 4 are even or odd~~~; This can be very useful in various scenarios~~~; ----------------------------------------------------~~~; Loop from 0 to 4~~~Loop, 5 {~~~    ; Check if the current index is even or odd~~~    if (A_Index % 2 = 0) {~~~        print(STR(A_Index) . " is even")~~~    } else {~~~        print(STR(A_Index) . " is odd")~~~    }~~~}~~~```~~~
def Mod(dividend, divisor) {
    return dividend % divisor
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: Random
libs: )|"math/rand"|"time"
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
// Note: In production, the random generator should be seeded only once.
// Seeding here for demonstration purposes.
func Random(min, max int) int {
    rand.Seed(time.Now().UnixNano())
    return rand.Intn(max - min + 1) + min
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
-- Seed the random number generator, ideally once at the start of the script.
math.randomseed(os.time())
function Random(min, max)
    return math.random(min, max)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Random
libs: using System;
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
private static readonly Random _random = new Random();
public static int Random(int min, int max) {
    return _random.Next(min, max + 1);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Random
libs: import java.util.Random;
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
private static final Random random = new Random();
public static int Random(int min, int max) {
    return random.nextInt(max - min + 1) + min;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
fun Random(min: Int, max: Int): Int {
    return (min..max).random()
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
def Random(min, max)
  rand(min..max)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Random
libs: import random
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
proc Random(min, max: int): int =
  randomize()
  return rand(min..max)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
Random(min, max) {
    Random, out, %min%, %max%
    return out
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
func Random(_ min: Int, _ max: Int) -> Int {
    return Int.random(in: min...max)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Random
libs: import 'dart:math';|import 'dart:math' as math;
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
// A single Random instance should be reused
final _random = math.Random();

// You are allowed to name this Random() now because the class is math.Random
int Random(int min, int max) {
  return min + _random.nextInt(max - min + 1);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Random
libs: null
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
function Random(min: number, max: number): number {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Random
libs: import java.util.Random
description: math~~~Generates a pseudo-random integer between `min` and `max` (inclusive). Both `min` and `max` must be integers.~~~Here is how to use it:~~~```htvm~~~int minVal := 1~~~int maxVal := 10~~~Loop, 5 {~~~    int randNum := Random(minVal, maxVal)~~~    print("Random number between " . STR(minVal) . " and " . STR(maxVal) . ": " . STR(randNum))~~~    if (randNum < minVal or randNum > maxVal) {~~~        print("Random test FAILED! Number out of range: " . STR(randNum))~~~    }~~~}~~~print("--------------------")~~~; ----------------------------------------------------~~~int specificMin := 5~~~int specificMax := 5~~~int specificRand := Random(specificMin, specificMax)~~~print("Random number between 5 and 5: " . STR(specificRand))~~~; Expected: 5~~~if (specificRand != 5) {~~~    print("Random specific range test FAILED!")~~~}~~~```~~~
def random = new Random()
// Random function as a closure capturing 'random'
def Random = { int min, int max ->
    random.nextInt(max - min + 1) + min
}
funcEND======================funcEND==============






func======================func==============
lang: go
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
func Asc(s string) int {
    if len(s) == 0 {
        return -1
    }
    return int(s[0])
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
function Asc(str)
    if str and #str > 0 then
        return string.byte(str)
    else
        return -1
    end
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Asc
libs: using System;
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
public static int Asc(string str) {
    if (string.IsNullOrEmpty(str)) {
        return -1;
    }
    return (int)str[0];
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
public static int Asc(String str) {
    if (str == null || str.isEmpty()) {
        return -1;
    }
    return (int)str.charAt(0);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~

fun Asc(str: String): Int {
    if (str.isEmpty()) {
        return -1
    }
    return str.first().toInt()
}

funcEND======================funcEND==============
func======================func==============
lang: rb
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
def Asc(str)
  return -1 if str.nil? || str.empty?
  str.ord
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
proc Asc(s: string): int =
  if s.len == 0:
    return -1
  else:
    return ord(s[0])
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
; built-in Asc() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
func Asc(_ str: String) -> Int {
    guard let char = str.first, let scalar = char.unicodeScalars.first else {
        return -1
    }
    return Int(scalar.value)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
int Asc(String str) {
  if (str.isEmpty) {
    return -1;
  }
  return str.codeUnitAt(0);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
function Asc(str: string): number {
    if (!str || str.length === 0) {
        return -1;
    }
    return str.charCodeAt(0);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Asc
libs: null
description: string~~~Returns the ASCII (or Unicode) value of the first character in a string. If the string is empty, it typically returns -1 or an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str char1 := "A"~~~int ascii1 := Asc(char1)~~~print("Asc('A') = " . STR(ascii1))~~~; Expected: 65~~~if (ascii1 != 65) {~~~    print("Asc test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char2 := "a"~~~int ascii2 := Asc(char2)~~~print("Asc('a') = " . STR(ascii2))~~~; Expected: 97~~~if (ascii2 != 97) {~~~    print("Asc test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str char3 := " "~~~int ascii3 := Asc(char3)~~~print("Asc(' ') = " . STR(ascii3))~~~; Expected: 32~~~if (ascii3 != 32) {~~~    print("Asc test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str emptyStr := ""~~~int asciiEmpty := Asc(emptyStr)~~~print("Asc('') = " . STR(asciiEmpty))~~~; Expected: -1 (or error)~~~if (asciiEmpty != -1) {~~~    print("Asc empty string test might need review for specific language behavior, got: " . STR(asciiEmpty))~~~}~~~```~~~
int Asc(String str) {
    if (str == null || str.isEmpty()) {
        return -1
    }
    return (int) str.charAt(0)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
func Chr(code int) string {
	return string(rune(code))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
function Chr(code)
    return string.char(code)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Chr
libs: using System;
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
public static string Chr(int code) {
    try {
        return char.ConvertFromUtf32(code);
    } catch (ArgumentOutOfRangeException) {
        return "";
    }
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
public static String Chr(int codePoint) {
    if (Character.isValidCodePoint(codePoint)) {
        return new String(Character.toChars(codePoint));
    }
    return "";
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
fun Chr(code: Int): String {
    if (code >= 0 && code <= 0x10FFFF) {
        return code.toChar().toString()
    }
    return ""
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
def Chr(code)
  begin
    return code.chr(Encoding::UTF_8)
  rescue RangeError
    return ""
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
# Chr function using Nim's built-in 'chr'
proc Chr(code: int): string =
  result = $chr(code)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
; built-in Chr() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
func Chr(_ code: Int) -> String {
    guard let scalar = Unicode.Scalar(code) else {
        return ""
    }
    return String(scalar)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
String Chr(int code) {
  return String.fromCharCode(code);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
function Chr(code: number): string {
    return String.fromCodePoint(code);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Chr
libs: null
description: string~~~Returns the character represented by the given ASCII (or Unicode) value. Input must be an integer.~~~Here is how to use it:~~~```htvm~~~int code1 := 65~~~str char1 := Chr(code1)~~~print("Chr(65) = '" . char1 . "'")~~~; Expected: 'A'~~~if (char1 != "A") {~~~    print("Chr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code2 := 97~~~str char2 := Chr(code2)~~~print("Chr(97) = '" . char2 . "'")~~~; Expected: 'a'~~~if (char2 != "a") {~~~    print("Chr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int code3 := 32~~~str char3 := Chr(code3)~~~print("Chr(32) = '" . char3 . "'")~~~; Expected: ' ' (space)~~~if (char3 != " ") {~~~    print("Chr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example with a less common character (e.g., Euro sign if supported)~~~; Euro sign ~~~int code4 := 8364~~~str char4 := Chr(code4)~~~print("Chr(8364) = '" . char4 . "'")~~~; Expected: '' (if supported by environment/font)~~~```~~~
String Chr(int code) {
    return new String(new int[] { code }, 0, 1)
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: FLOAT
libs: )|"strconv"
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
func FLOAT(str string) float64 {
	val, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return 0.0
	}
	return val
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
function FLOAT(str)
    return tonumber(str) or 0.0
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: FLOAT
libs: using System;
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
public static float FLOAT(string str) {
    float.TryParse(str, out float result);
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
public static float FLOAT(String str) {
    try {
        return Float.parseFloat(str);
    } catch (NumberFormatException e) {
        return 0.0f;
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
fun FLOAT(str: String): Float {
    return str.toFloatOrNull() ?: 0.0f
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
def FLOAT(str)
  str.to_f
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: FLOAT
libs: import strutils
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
proc FLOAT(s: string): float =
  try:
    result = parseFloat(s)
  except ValueError:
    result = 0.0
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
FLOAT(str) {
    return str + 0.0
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
func FLOAT(_ str: String) -> Float {
    return Float(str) ?? 0.0
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
double FLOAT(String str) {
  return double.tryParse(str) ?? 0.0;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
function FLOAT(str: string): number {
    const num = parseFloat(str);
    return isNaN(num) ? 0 : num;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: FLOAT
libs: null
description: string~~~Converts a string representation of a number into a floating-point number. If the string cannot be converted, it may throw an error or return a special value like NaN, depending on the target language.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123.45"~~~float float1 := FLOAT(strNum1)~~~print("FLOAT('123.45') = " . STR(float1))~~~; Expected: 123.45~~~if (Abs(float1 - 123.45) > 0.00001) {~~~    print("FLOAT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "-0.5"~~~float float2 := FLOAT(strNum2)~~~print("FLOAT('-0.5') = " . STR(float2))~~~; Expected: -0.5~~~if (Abs(float2 - (-0.5)) > 0.00001) {~~~    print("FLOAT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "789"~~~float float3 := FLOAT(strNum3)~~~; Integer string~~~print("FLOAT('789') = " . STR(float3))~~~; Expected: 789.0~~~if (Abs(float3 - 789.0) > 0.00001) {~~~    print("FLOAT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or NaN)~~~str invalidStr := "abc"~~~float floatInvalid := FLOAT(invalidStr)~~~print("FLOAT('abc') = " . STR(floatInvalid))~~~```~~~
float FLOAT(String str) {
    try {
        return str.toFloat()
    } catch (NumberFormatException e) {
        return 0.0f
    }
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: INT
libs: )|"strconv"
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
func INT(str string) int {
	f, err := strconv.ParseFloat(str, 64)
	if err != nil {
		return 0
	}
	return int(f)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
function INT(str)
    local num = tonumber(str)
    if num then
        return math.modf(num)
    else
        return 0
    end
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: INT
libs: using System;
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
public static int INT(string str) {
    double.TryParse(str, out double temp);
    return (int)temp;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
public static int INT(String str) {
    try {
        return (int)Double.parseDouble(str);
    } catch (NumberFormatException e) {
        return 0;
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
fun INT(str: String): Int {
    return str.toDoubleOrNull()?.toInt() ?: 0
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
def INT(str)
  str.to_i
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: INT
libs: import strutils
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
proc INT(s: string): int =
  try:
    result = int(parseFloat(s))
  except ValueError:
    result = 0
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
INT(str) {
    return Floor(str)
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
func INT(_ str: String) -> Int {
    return Int(Double(str) ?? 0.0)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
int INT(String str) {
  return double.tryParse(str)?.toInt() ?? 0;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
function INT(str: string): number {
    const num = parseInt(str, 10);
    return isNaN(num) ? 0 : num;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: INT
libs: null
description: string~~~Converts a string representation of a number into an integer. If the string represents a floating-point number, the fractional part is typically truncated. If the string cannot be converted, it may throw an error or return 0/NaN.~~~Here is how to use it:~~~```htvm~~~str strNum1 := "123"~~~int int1 := INT(strNum1)~~~print("INT('123') = " . STR(int1))~~~; Expected: 123~~~if (int1 != 123) {~~~    print("INT test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum2 := "123.789"~~~; String with a float~~~int int2 := INT(strNum2)~~~print("INT('123.789') = " . STR(int2))~~~; Expected: 123 (truncation)~~~if (int2 != 123) {~~~    print("INT test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str strNum3 := "-456"~~~int int3 := INT(strNum3)~~~print("INT('-456') = " . STR(int3))~~~; Expected: -456~~~if (int3 != -456) {~~~    print("INT test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example of an invalid string (behavior might vary: error or 0/NaN)~~~str invalidStr := "xyz"~~~int intInvalid := INT(invalidStr)~~~print("INT('xyz') = " . STR(intInvalid))~~~```~~~
int INT(String str) {
    try {
        return str.toFloat().toInteger()
    } catch (NumberFormatException e) {
        return 0
    }
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: InStr
libs: )|"strings"
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
func InStr(haystack, needle string) int {
	pos := strings.Index(haystack, needle)
	if pos == -1 {
		return 0
	}
	return pos + 1
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
function InStr(haystack, needle)
    local pos = string.find(haystack, needle, 1, true)
    return pos or 0
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: InStr
libs: using System;
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
public static int InStr(string haystack, string needle) {
    int pos = haystack.IndexOf(needle);
    return pos == -1 ? 0 : pos + 1;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
public static int InStr(String haystack, String needle) {
    int pos = haystack.indexOf(needle);
    return pos == -1 ? 0 : pos + 1;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
fun InStr(haystack: String, needle: String): Int {
    val pos = haystack.indexOf(needle)
    return if (pos == -1) 0 else pos + 1
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
def InStr(haystack, needle)
  pos = haystack.index(needle)
  return pos ? pos + 1 : 0
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
proc InStr(haystack, needle: string): int =
  let pos = haystack.find(needle)
  if pos == -1:
    return 0
  else:
    return pos + 1
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
; built-in InStr() is used (note: default is case-insensitive, but can be made sensitive)
funcEND======================funcEND==============
func======================func==============
lang: swift
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
func InStr(_ haystack: String, _ needle: String) -> Int {
    if let range = haystack.range(of: needle) {
        return haystack.distance(from: haystack.startIndex, to: range.lowerBound) + 1
    }
    return 0
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
int InStr(String haystack, String needle) {
  int pos = haystack.indexOf(needle);
  return pos == -1 ? 0 : pos + 1;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
function InStr(haystack: string, needle: string): number {
    const pos = haystack.indexOf(needle);
    return pos === -1 ? 0 : pos + 1;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: InStr
libs: null
description: string~~~Searches for the first occurrence of a `needle` substring within a `haystack` string. Returns the 1-based starting position of `needle` if found, otherwise returns 0. Case-sensitivity depends on the target language's default string search behavior.~~~Here is how to use it:~~~```htvm~~~str haystack := "Hello, HTVM World! HTVM is cool."~~~str needle1 := "HTVM"~~~int pos1 := InStr(haystack, needle1)~~~print("Position of 'HTVM' in '" . haystack . "' is: " . STR(pos1))~~~; Expected: 8 (1-indexed-based)~~~if (pos1 != 8) {~~~    print("InStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle2 := "World"~~~int pos2 := haystack.InStr(needle2)~~~print("Position of 'World' is: " . STR(pos2))~~~; Expected: 13 (1-indexed-based)~~~if (pos2 != 13) {~~~    print("InStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle3 := "notfound"~~~int pos3 := InStr(haystack, needle3)~~~print("Position of 'notfound' is: " . STR(pos3))~~~; Expected: 0~~~if (pos3 != 0) {~~~    print("InStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str needle4 := "hTvm"~~~; Test case-sensitivity (may vary by language)~~~int pos4 := InStr(haystack, needle4)~~~print("Position of 'hTvm' (case test) is: " . STR(pos4))~~~; Expected might be 0 if case-sensitive, or 8 if case-insensitive~~~```~~~
int InStr(String haystack, String needle) {
    int pos = haystack.indexOf(needle)
    return pos == -1 ? 0 : pos + 1
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: RegExMatch
libs: )|"regexp"
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
func RegExMatch(haystack, pattern string) int {
	re, err := regexp.Compile(pattern)
	if err != nil {
		return 0
	}
	loc := re.FindStringIndex(haystack)
	if loc == nil {
		return 0
	}
	return loc[0] + 1
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~



-- This single function now handles both the regex-to-Lua pattern conversion
-- and the final matching.
function RegExMatch(haystack, pattern)
    -- Start of internal conversion logic
    local luaPattern = pattern

    -- Step 1: Translate specific, complex character sets first.
    luaPattern = luaPattern:gsub("%[a%-zA%-Z0%-9._%%+%-%]", "[%%w._%%+-]")
    luaPattern = luaPattern:gsub("%[a%-zA%-Z0%-9.%-%]", "[%%w.-]")

    -- Step 2: Convert standard character ranges and classes.
    luaPattern = luaPattern:gsub("%[0%-9%]", "%%d")
    luaPattern = luaPattern:gsub("%[a%-zA%-Z%]", "%%a")
    luaPattern = luaPattern:gsub("\\d", "%%d")
    luaPattern = luaPattern:gsub("\\w", "%%w")
    luaPattern = luaPattern:gsub("\\s", "%%s")

    -- Step 3: Handle quantifiers.
    luaPattern = luaPattern:gsub("(%%[adws])%{(%d+),%}", function(token, min)
        min = tonumber(min)
        if min == 0 then return token .. "*" end
        if min == 1 then return token .. "+" end
        return string.rep(token, min - 1) .. token .. "+"
    end)
    luaPattern = luaPattern:gsub("(%%[adws])%{(%d+)%}", function(token, count)
        count = tonumber(count)
        return string.rep(token, count)
    end)
    
    -- Step 4: Escape literal characters.
    luaPattern = luaPattern:gsub("\\%.", "%%.") -- Correctly finds a literal \.
    luaPattern = luaPattern:gsub("\\%$", "%%$") -- Correctly finds a literal \$
    -- End of internal conversion logic

    -- Now, perform the match using the converted pattern
    local startPos, endPos = string.find(haystack, luaPattern)
    
    return startPos or 0
end



funcEND======================funcEND==============
func======================func==============
lang: cs
name: RegExMatch
libs: using System.Text.RegularExpressions;
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
public static int RegExMatch(string haystack, string pattern) {
    try {
        Match match = Regex.Match(haystack, pattern);
        if (match.Success) {
            return match.Index + 1;
        }
    } catch (ArgumentException) {
        // Invalid regex pattern
        return 0;
    }
    return 0;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: RegExMatch
libs: import java.util.regex.Matcher;|import java.util.regex.Pattern;|import java.util.regex.PatternSyntaxException;
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
public static int RegExMatch(String haystack, String pattern) {
    try {
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(haystack);
        if (m.find()) {
            return m.start() + 1;
        }
    } catch (PatternSyntaxException e) {
        return 0;
    }
    return 0;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
fun RegExMatch(haystack: String, pattern: String): Int {
    return try {
        val regex = Regex(pattern)
        val match = regex.find(haystack)
        match?.range?.first?.plus(1) ?: 0
    } catch (e: Exception) {
        0
    }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
def RegExMatch(haystack, pattern)
  begin
    match_data = haystack.match(Regexp.new(pattern))
    return match_data ? match_data.begin(0) + 1 : 0
  rescue RegexpError
    return 0
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: RegExMatch
libs: import re
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
proc RegExMatch(haystack, pattern: string): int =
  try:
    let pos = haystack.find(re(pattern))
    if pos == -1:
      return 0
    else:
      return pos + 1
  except:
    return 0
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
; built-in RegExMatch() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: RegExMatch
libs: import Foundation
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
func RegExMatch(_ haystack: String, _ pattern: String) -> Int {
    if let range = haystack.range(of: pattern, options: .regularExpression) {
        return haystack.distance(from: haystack.startIndex, to: range.lowerBound) + 1
    }
    return 0
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
int RegExMatch(String haystack, String pattern) {
  try {
    final re = RegExp(pattern);
    final match = re.firstMatch(haystack);
    return match != null ? match.start + 1 : 0;
  } catch (e) {
    return 0;
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: RegExMatch
libs: null
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
function RegExMatch(haystack: string, pattern: string): number {
    try {
        const regex = new RegExp(pattern);
        const match = haystack.match(regex);
        if (match) {
            return (match.index ?? -1) + 1;
        }
    } catch (e) {
        return 0;
    }
    return 0;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: RegExMatch
libs: import java.util.regex.Matcher|import java.util.regex.Pattern
description: string~~~Searches a `haystack` string for the first occurrence of a regular expression `pattern`. Returns the 1-based starting position of the match if found, otherwise returns 0. The regex syntax compatibility depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "The year is 2024, and the price is $19.99."~~~; Matches four digits (year)~~~str pattern1 := "\d{4}"~~~int matchPos1 := RegExMatch(text, pattern1)~~~print("Position of year pattern: " . STR(matchPos1))~~~; Expected: 13 (for "2024")~~~if (matchPos1 != 13) {~~~    print("RegExMatch test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Matches a price like $xx.yy~~~str pattern2 := "\$[0-9]+\.[0-9]{2}"~~~int matchPos2 := text.RegExMatch(pattern2)~~~print("Position of price pattern: " . STR(matchPos2))~~~; Expected: 36 (for "$19.99")~~~if (matchPos2 != 36) {~~~    print("RegExMatch test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Pattern not in text~~~str pattern3 := "XYZ"~~~int matchPos3 := RegExMatch(text, pattern3)~~~print("Position of 'XYZ' pattern: " . STR(matchPos3))~~~; Expected: 0~~~if (matchPos3 != 0) {~~~    print("RegExMatch test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Check if a number exists in the text~~~str numText := "There are 42 apples."~~~; Matches any number~~~str numPattern := "\d+"~~~int numPos := RegExMatch(numText, numPattern)~~~print("Position of number in text: " . STR(numPos))~~~; Expected: 12 (for "42")~~~if (numPos > 0) {~~~    print("Number found in text.")~~~} else {~~~    print("No number found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a string exists~~~str stringText := "The quick brown fox jumps over the lazy dog."~~~; Matches the word "fox"~~~str stringPattern := "fox"~~~int stringPos := RegExMatch(stringText, stringPattern)~~~print("Position of 'fox' in text: " . STR(stringPos))~~~; Expected: 17~~~if (stringPos > 0) {~~~    print("'fox' found in text.")~~~} else {~~~    print("'fox' not found in text.")~~~}~~~; ----------------------------------------------------~~~; Check if a specific format (email) exists~~~str emailText := "Please contact support@domain.com for help."~~~; Matches an email format~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~int emailPos := RegExMatch(emailText, emailPattern)~~~print("Position of email pattern: " . STR(emailPos))~~~; Expected: 23 (for "support@domain.com")~~~if (emailPos > 0) {~~~    print("Email found in text.")~~~} else {~~~    print("No email found in text.")~~~}~~~```~~~
int RegExMatch(String haystack, String pattern) {
    try {
        // This function is now smarter. It will automatically "fix" the
        // dollar sign issue for the regex engine.
        // It replaces any '$' that is NOT followed by a '{' (for GString expressions)
        // with a literally escaped dollar sign '\\$'.
        String fixedPattern = pattern.replaceAll('\\$(?!\\{)', ((char)92).toString() + ((char)92).toString() + ((char)92).toString() + '$')

        Pattern p = Pattern.compile(fixedPattern)
        Matcher matcher = p.matcher(haystack)
        if (matcher.find()) {
            return matcher.start() + 1
        }
    } catch (Exception e) {
        // println("Error matching pattern: $pattern. Reason: $e.message")
        return 0
    }
    return 0
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: RegExReplace
libs: )|"regexp"
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
func RegExReplace(inputStr, regexPattern, replacement string) string {
	re, err := regexp.Compile(regexPattern)
	if err != nil {
		return inputStr // Return original string if pattern is invalid
	}
	return re.ReplaceAllString(inputStr, replacement)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~


function RegExReplace(inputStr, regexPattern, replacement)
    -- --- Start of internal pattern conversion logic ---
    local luaPattern = regexPattern
    luaPattern = luaPattern:gsub("%[a%-zA%-Z0%-9._%%+%-%]", "[%%w._%%+-]")
    luaPattern = luaPattern:gsub("%[a%-zA%-Z0%-9.%-%]", "[%%w.-]")
    luaPattern = luaPattern:gsub("%[0%-9%]", "%%d")
    luaPattern = luaPattern:gsub("%[a%-zA%-Z%]", "%%a")
    luaPattern = luaPattern:gsub("\\d", "%%d")
    luaPattern = luaPattern:gsub("\\w", "%%w")
    luaPattern = luaPattern:gsub("\\s", "%%s")
    luaPattern = luaPattern:gsub("(%%[adws])%{(%d+),%}", function(token, min)
        min = tonumber(min)
        if min == 0 then return token .. "*" end
        if min == 1 then return token .. "+" end
        return string.rep(token, min - 1) .. token .. "+"
    end)
    luaPattern = luaPattern:gsub("(%%[adws])%{(%d+)%}", function(token, count)
        count = tonumber(count)
        return string.rep(token, count)
    end)
    luaPattern = luaPattern:gsub("\\%.", "%%.")
    luaPattern = luaPattern:gsub("\\%$", "%%$")
    -- --- End of internal pattern conversion logic ---

    -- --- Start of internal replacement string sanitization ---
    -- In Lua's gsub, '%' is the escape character for captures.
    -- To insert a literal '%', we must use '%%'.
    local safeReplacement = replacement:gsub("%%", "%%%%")
    -- --- End of internal replacement string sanitization ---

    -- Perform the replacement with the safe pattern and replacement.
    local resultStr, numReplacements = string.gsub(inputStr, luaPattern, safeReplacement)
    return resultStr
end



funcEND======================funcEND==============
func======================func==============
lang: cs
name: RegExReplace
libs: using System.Text.RegularExpressions;
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
public static string RegExReplace(string inputStr, string regexPattern, string replacement) {
    try {
        return Regex.Replace(inputStr, regexPattern, replacement);
    } catch (ArgumentException) {
        return inputStr; // Return original string if pattern is invalid
    }
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: RegExReplace
libs: import java.util.regex.PatternSyntaxException;
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
public static String RegExReplace(String inputStr, String regexPattern, String replacement) {
    try {
        return inputStr.replaceAll(regexPattern, replacement);
    } catch (PatternSyntaxException e) {
        return inputStr; // Return original string if pattern is invalid
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
fun RegExReplace(inputStr: String, regexPattern: String, replacement: String): String {
    return try {
        inputStr.replace(Regex(regexPattern), replacement)
    } catch (e: Exception) {
        inputStr // Return original string if pattern is invalid
    }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
def RegExReplace(inputStr, regexPattern, replacement)
  begin
    inputStr.gsub(Regexp.new(regexPattern), replacement)
  rescue RegexpError
    inputStr
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: RegExReplace
libs: import re
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
proc RegExReplace(inputStr, regexPattern, replacement: string): string =
  try:
    return inputStr.replace(re(regexPattern), replacement)
  except:
    return inputStr
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
; built-in RegExReplace() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
func RegExReplace(_ inputStr: String, _ regexPattern: String, _ replacement: String) -> String {
    return inputStr.replacingOccurrences(of: regexPattern, with: replacement, options: .regularExpression, range: nil)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
String RegExReplace(String inputStr, String regexPattern, String replacement) {
  try {
    return inputStr.replaceAll(RegExp(regexPattern), replacement);
  } catch (e) {
    return inputStr;
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
function RegExReplace(inputStr: string, regexPattern: string, replacement: string): string {
    try {
        const regex = new RegExp(regexPattern, 'g');
        return inputStr.replace(regex, replacement);
    } catch (e) {
        return inputStr;
    }
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: RegExReplace
libs: null
description: string~~~Replaces occurrences of a regular expression `pattern` within an `inputStr` with a `replacement` string. Returns the modified string. The regex syntax and replacement capabilities depend on the target language.~~~Here is how to use it:~~~```htvm~~~str text := "Contact us at info@example.com or support@example.org for help."~~~str emailPattern := "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"~~~str replacement := "[REDACTED_EMAIL]"~~~str result1 := RegExReplace(text, emailPattern, replacement)~~~print("Original: " . text)~~~print("Redacted: " . result1)~~~; Expected: Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help.~~~str expected1 := "Contact us at [REDACTED_EMAIL] or [REDACTED_EMAIL] for help."~~~if (result1 != expected1) {~~~    print("RegExReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "The numbers are 123 and 456."~~~str digitPattern := "\d+" ~~~; Matches one or more digits~~~str replacement2 := "###"~~~str result2 := text2.RegExReplace(digitPattern, replacement2)~~~print("Original: " . text2)~~~print("Numbers replaced: " . result2)~~~; Expected: The numbers are ### and ###.~~~str expected2 := "The numbers are ### and ###."~~~if (result2 != expected2) {~~~    print("RegExReplace test 2 FAILED!")~~~}~~~```~~~
String RegExReplace(String inputStr, String regexPattern, String replacement) {
    try {
        // STEP 1: Fix the regex pattern for any literal '$' characters,
        // exactly like we did in RegExMatch.
        String fixedPattern = regexPattern.replaceAll('\\$(?!\\{)', ((char)92).toString() + ((char)92).toString() + ((char)92).toString() + '$')

        // STEP 2: Fix the replacement string. In replaceAll, '$' is used for
        // backreferences (e.g., $1). We must escape it to treat it as a literal.
        String fixedReplacement = replacement.replace('$', '\\$')

        // Now, call replaceAll with the fixed pattern and fixed replacement.
        return inputStr.replaceAll(fixedPattern, fixedReplacement)
    } catch (Exception e) {
        // In case of an error, return the original string.
        return inputStr
    }
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: Sort
libs: )|"sort"|"strings"|"strconv"
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
func Sort(input, options string) string {
	caseSensitive := strings.Contains(options, "C")
	unique := strings.Contains(options, "U")
	reverse := strings.Contains(options, "R")
	numeric := strings.Contains(options, "N")
	delimiter := "\n"
	if dIndex := strings.Index(options, "D"); dIndex != -1 && dIndex+1 < len(options) {
		delimiter = string(options[dIndex+1])
	}
	
	rawItems := strings.Split(input, delimiter)
	var items []string
	for _, item := range rawItems {
		trimmed := strings.TrimSpace(item)
		if trimmed != "" {
			items = append(items, trimmed)
		}
	}

	if unique {
		seen := make(map[string]bool)
		var uniqueItems []string
		for _, item := range items {
			key := item
			if !caseSensitive {
				key = strings.ToLower(key)
			}
			if _, exists := seen[key]; !exists {
				seen[key] = true
				uniqueItems = append(uniqueItems, item)
			}
		}
		items = uniqueItems
	}

	if numeric {
		sort.Slice(items, func(i, j int) bool {
			numA, _ := strconv.Atoi(items[i])
			numB, _ := strconv.Atoi(items[j])
			return numA < numB
		})
	} else {
		if caseSensitive {
			sort.Strings(items)
		} else {
			sort.Slice(items, func(i, j int) bool {
				return strings.ToLower(items[i]) < strings.ToLower(items[j])
			})
		}
	}

	if reverse {
		for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {
			items[i], items[j] = items[j], items[i]
		}
	}

	return strings.Join(items, delimiter)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
function Sort(input, options)
    local caseSensitive = string.find(options, "C", 1, true)
    local unique = string.find(options, "U", 1, true)
    local reverse = string.find(options, "R", 1, true)
    local numeric = string.find(options, "N", 1, true)
    local delimiter = "\n"
    local dPos = string.find(options, "D", 1, true)
    if dPos then delimiter = string.sub(options, dPos + 1, dPos + 1) end

    local items = {}
    for item in string.gmatch(input, "([^" .. delimiter .. "]+)") do
        -- A simple trim
        local trimmed = item:match("^%s*(.-)%s*$")
        if #trimmed > 0 then table.insert(items, trimmed) end
    end

    if unique then
        local seen = {}
        local uniqueItems = {}
        for _, item in ipairs(items) do
            local key = item
            if not caseSensitive then key = string.lower(key) end
            if not seen[key] then
                table.insert(uniqueItems, item)
                seen[key] = true
            end
        end
        items = uniqueItems
    end
    
    local sortFunc
    if numeric then
        sortFunc = function(a, b) return tonumber(a) < tonumber(b) end
    else
        if caseSensitive then
            sortFunc = function(a, b) return a < b end
        else
            sortFunc = function(a, b) return string.lower(a) < string.lower(b) end
        end
    end
    table.sort(items, sortFunc)
    
    if reverse then
        local reversedItems = {}
        for i = #items, 1, -1 do table.insert(reversedItems, items[i]) end
        items = reversedItems
    end

    return table.concat(items, delimiter)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Sort
libs: using System;|using System.Collections.Generic;|using System.Linq;
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
public static string Sort(string input, string options) {
    bool caseSensitive = options.Contains("C");
    bool unique = options.Contains("U");
    bool reverse = options.Contains("R");
    bool numeric = options.Contains("N");
    string delimiter = "\n";
    int dIndex = options.IndexOf("D");
    if (dIndex != -1 && dIndex + 1 < options.Length) {
        delimiter = options[dIndex + 1].ToString();
    }

    IEnumerable<string> items = input.Split(new[] { delimiter }, StringSplitOptions.None)
                                     .Select(s => s.Trim())
                                     .Where(s => !string.IsNullOrEmpty(s));
    
    if (unique) {
        var comparer = caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;
        items = items.Distinct(comparer);
    }

    if (numeric) {
        items = items.OrderBy(s => double.Parse(s));
    } else {
        var comparer = caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;
        items = items.OrderBy(s => s, comparer);
    }

    if (reverse) {
        items = items.Reverse();
    }

    return string.Join(delimiter, items);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Sort
libs: import java.util.*;|import java.util.stream.Collectors;
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
public static String Sort(String input, String options) {
    boolean caseSensitive = options.contains("C");
    boolean unique = options.contains("U");
    boolean reverse = options.contains("R");
    boolean numeric = options.contains("N");
    String delimiter = "\n";
    int dIndex = options.indexOf("D");
    if (dIndex != -1 && dIndex + 1 < options.length()) {
        delimiter = options.substring(dIndex + 1, dIndex + 2);
    }
    
    List<String> items = Arrays.stream(input.split(java.util.regex.Pattern.quote(delimiter)))
        .map(String::trim)
        .filter(s -> !s.isEmpty())
        .collect(Collectors.toList());

    if (unique) {
        Set<String> seen = new HashSet<>();
        items = items.stream().filter(item -> {
            String key = caseSensitive ? item : item.toLowerCase();
            return seen.add(key);
        }).collect(Collectors.toList());
    }

    Comparator<String> comparator;
    if (numeric) {
        comparator = Comparator.comparingDouble(Double::parseDouble);
    } else {
        comparator = caseSensitive ? Comparator.naturalOrder() : String.CASE_INSENSITIVE_ORDER;
    }
    items.sort(comparator);

    if (reverse) {
        Collections.reverse(items);
    }

    return String.join(delimiter, items);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
fun Sort(input: String, options: String): String {
    val caseSensitive = options.contains("C")
    val unique = options.contains("U")
    val reverse = options.contains("R")
    val numeric = options.contains("N")
    val delimiter = options.indexOf("D").takeIf { it != -1 }?.let { options.getOrNull(it + 1)?.toString() } ?: "\n"

    var items = input.split(delimiter)
        .map { it.trim() }
        .filter { it.isNotEmpty() }
        .let { if (unique) it.distinctBy { if (caseSensitive) it else it.toLowerCase() } else it }
    
    val sortedItems = if (numeric) {
        items.sortedBy { it.toDoubleOrNull() ?: 0.0 }
    } else {
        if (caseSensitive) items.sorted() else items.sortedWith(String.CASE_INSENSITIVE_ORDER)
    }

    val finalItems = if (reverse) sortedItems.reversed() else sortedItems
    
    return finalItems.joinToString(delimiter)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
def Sort(input, options)
  case_sensitive = options.include?('C')
  unique = options.include?('U')
  reverse = options.include?('R')
  numeric = options.include?('N')
  d_index = options.index('D')
  delimiter = d_index ? options[d_index + 1] : "\n"

  items = input.split(delimiter).map(&:strip).reject(&:empty?)

  if unique
    items = case_sensitive ? items.uniq : items.uniq { |s| s.downcase }
  end

  if numeric
    items.sort_by!(&:to_f)
  else
    if case_sensitive
      items.sort!
    else
      items.sort_by!(&:downcase)
    end
  end

  items.reverse! if reverse

  items.join(delimiter)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Sort
libs: import strutils, sequtils, algorithm|import sets
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~


proc Sort(input: string, options: string): string =
  let caseSensitive = 'C' in options
  let unique = 'U' in options
  let reverseSort = 'R' in options
  let numeric = 'N' in options

  # Improved delimiter extraction (handles any char including ',')
  var delimiter = "\n"
  let dPos = options.find("D")
  if dPos >= 0 and dPos + 1 < options.len:
    delimiter = options[dPos + 1..dPos + 1]

  var items = input.split(delimiter).mapIt(it.strip).filterIt(it.len > 0)

  if unique:
    if caseSensitive:
      items = items.deduplicate()
    else:
      var seen: HashSet[string] = initHashSet[string]()
      var uniqueItems: seq[string] = @[]
      for s in items:
        let key = s.toLower()
        if key notin seen:
          seen.incl(key)
          uniqueItems.add(s)
      items = uniqueItems

  if numeric:
    items.sort(proc(a, b: string): int = cmp(a.parseFloat, b.parseFloat))
  else:
    if caseSensitive:
      items.sort(system.cmp[string])
    else:
      items.sort(proc(a, b: string): int = cmp(a.toLower(), b.toLower()))

  if reverseSort:
    items.reverse()

  return items.join(delimiter)


funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
Sort(ByRef input, options) {
    Sort, input, %options%
    return input
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
func Sort(_ input: String, _ options: String) -> String {
    let caseSensitive = options.contains("C")
    let unique = options.contains("U")
    let reverse = options.contains("R")
    let numeric = options.contains("N")
    var delimiter: String = "\n"
    if let dRange = options.range(of: "D") {
        if let dChar = options[dRange.upperBound...].first {
            delimiter = String(dChar)
        }
    }
    
    var items = input.components(separatedBy: delimiter)
        .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
        .filter { !$0.isEmpty }

    if unique {
        var seen = Set<String>()
        items = items.filter { item in
            let key = caseSensitive ? item : item.lowercased()
            return seen.insert(key).inserted
        }
    }

    if numeric {
        items.sort { (a, b) -> Bool in
            return (Double(a) ?? 0) < (Double(b) ?? 0)
        }
    } else {
        items.sort { (a, b) -> Bool in
            return caseSensitive ? a < b : a.localizedCaseInsensitiveCompare(b) == .orderedAscending
        }
    }
    
    if reverse {
        items.reverse()
    }
    
    return items.joined(separator: delimiter)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
String Sort(String input, String options) {
  final caseSensitive = options.contains('C');
  final unique = options.contains('U');
  final reverse = options.contains('R');
  final numeric = options.contains('N');
  var delimiter = '\n';
  final dIndex = options.indexOf('D');
  if (dIndex != -1 && dIndex + 1 < options.length) {
    delimiter = options[dIndex + 1];
  }

  var items = input.split(delimiter).map((s) => s.trim()).where((s) => s.isNotEmpty).toList();

  if (unique) {
    var seen = <String>{};
    items.retainWhere((item) => seen.add(caseSensitive ? item : item.toLowerCase()));
  }

  if (numeric) {
    items.sort((a, b) => (double.tryParse(a) ?? 0).compareTo(double.tryParse(b) ?? 0));
  } else {
    items.sort((a, b) => caseSensitive ? a.compareTo(b) : a.toLowerCase().compareTo(b.toLowerCase()));
  }

  if (reverse) {
    items = items.reversed.toList();
  }

  return items.join(delimiter);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
function Sort(input: string, options: string): string {
    const caseSensitive = options.includes('C');
    const unique = options.includes('U');
    const reverse = options.includes('R');
    const numeric = options.includes('N');
    let delimiter = '\n';
    const dIndex = options.indexOf('D');
    if (dIndex !== -1 && dIndex + 1 < options.length) {
        delimiter = options[dIndex + 1];
    }
    
    let items = input.split(delimiter)
        .map(s => s.trim())
        .filter(s => s.length > 0);

    if (unique) {
        const seen = new Set<string>();
        items = items.filter(item => {
            const key = caseSensitive ? item : item.toLowerCase();
            if (seen.has(key)) {
                return false;
            } else {
                seen.add(key);
                return true;
            }
        });
    }

    if (numeric) {
        items.sort((a, b) => parseFloat(a) - parseFloat(b));
    } else {
        items.sort((a, b) => {
            const comparison = caseSensitive ? 0 : a.toLowerCase().localeCompare(b.toLowerCase());
            return comparison === 0 ? a.localeCompare(b) : comparison;
        });
    }

    if (reverse) {
        items.reverse();
    }

    return items.join(delimiter);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Sort
libs: null
description: string~~~Sorts lines or delimited items within a string. Options control sorting behavior: 'C' (case-sensitive), 'U' (unique items), 'R' (reverse order), 'N' (numeric sort), 'D`char`' (custom delimiter). Default delimiter is newline.~~~Here is how to use it:~~~```htvm~~~str list1 := "Charlie`nAlpha`nBravo"~~~str sorted1 := Sort(list1, "U")~~~print("Default sort (list1):`n" . sorted1)~~~; Expected: Alpha`nBravo`nCharlie (case-insensitive by default unless C option)~~~; Assuming case-insensitive default for test~~~; Note: Actual default might vary if underlying language sorts case-sensitively.~~~; ----------------------------------------------------~~~print("---")~~~str list2 := "10`n2`n100`n1"~~~str sorted2_alpha := Sort(list2, "U")~~~str sorted2_numeric := Sort(list2, "N")~~~print("Alpha sort (list2):`n" . sorted2_alpha)~~~; Expected: 1`n10`n100`n2~~~print("Numeric sort (list2):`n" . sorted2_numeric)~~~; Expected: 1`n2`n10`n100~~~if (sorted2_numeric != "1`n2`n10`n100") {~~~    print("Sort numeric test FAILED!")~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list3 := "apple,banana,apple,orange"~~~str sorted3_unique_comma := Sort(list3, "UD,")~~~; Unique, comma-delimited~~~print("Unique comma sort (list3):`n" . sorted3_unique_comma)~~~; Expected: apple,banana,orange (order may vary for first two)~~~; A simple check for content rather than strict order for unique test:~~~if (InStr(sorted3_unique_comma, "apple") = 0 or InStr(sorted3_unique_comma, "banana") = 0 or InStr(sorted3_unique_comma, "orange") = 0 or countChars(sorted3_unique_comma, ",") != 2) {~~~    print("Sort unique comma test FAILED! Got: " . sorted3_unique_comma)~~~}~~~; ----------------------------------------------------~~~print("---")~~~str list4 := "Zebra`napple`nCAT"~~~str sorted4_case_reverse := Sort(list4, "CR")~~~print("Case-sensitive Reverse (list4):`n" . sorted4_case_reverse)~~~; Expected: apple`nZebra`nCAT (Z > C, a > Z)~~~; This expected order depends on specific sort implementation with mixed case.~~~; For testing, let's target a more predictable case-insensitive reverse.~~~str sorted4_insensitive_reverse := Sort(list4, "R")~~~; Assuming default is case-insensitive for this test~~~print("Case-insensitive Reverse (list4):`n" . sorted4_insensitive_reverse)~~~; Expected: Zebra`nCAT`napple~~~if (sorted4_insensitive_reverse != "Zebra`nCAT`napple") {~~~    print("Sort insensitive reverse test FAILED!")~~~}~~~```~~~
String Sort(String input, String options) {
    boolean caseSensitive = options.contains("C")
    boolean unique = options.contains("U")
    boolean reverse = options.contains("R")
    boolean numeric = options.contains("N")
    String delimiter = "\n"
    int dIndex = options.indexOf("D")
    if (dIndex != -1 && dIndex + 1 < options.length()) {
        delimiter = options.charAt(dIndex + 1)
    }
    def items = input.split(delimiter).collect { it.trim() }.findAll { !it.isEmpty() }

    if (unique) {
        if (caseSensitive) {
            items = items.unique()
        } else {
            items = items.unique { it.toLowerCase() }
        }
    }

    if (numeric) {
        items = items.sort { it.toDouble() }
    } else {
        if (caseSensitive) {
            items = items.sort()
        } else {
            items = items.sort { it.toLowerCase() }
        }
    }

    if (reverse) {
        items = items.reverse()
    }

    return items.join(delimiter)
}

funcEND======================funcEND==============













func======================func==============
lang: go
name: countChars
libs: )|"strings"
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
func countChars(s, substr string) int {
	return strings.Count(s, substr)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
function countChars(str, substr)
    if not substr or #substr == 0 then return 0 end
    local _, count = string.gsub(str, substr, "")
    return count
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
public static int countChars(string str, string substring)
{
    if (string.IsNullOrEmpty(substring)) return 0;
    int count = (str.Length - str.Replace(substring, "").Length) / substring.Length;
    return count;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
public static int countChars(String str, String substring) {
    if (substring == null || substring.isEmpty()) {
        return 0;
    }
    return str.split(java.util.regex.Pattern.quote(substring), -1).length - 1;
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
fun countChars(str: String, substring: String): Int {
    if (substring.isEmpty()) return 0
    return str.windowed(substring.length).count { it == substring }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
def countChars(str, substr)
  return 0 if substr.nil? || substr.empty?
  str.scan(substr).count
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: countChars
libs: import strutils
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
proc countChars(s, sub: string): int =
  return s.count(sub)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
countChars(str, substring) {
    if (substring = "")
        return 0
    count := 0
    StringReplace, str, str, %substring%, , UseErrorLevel
    count += ErrorLevel
    return count
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
func countChars(_ str: String, _ substring: String) -> Int {
    guard !substring.isEmpty else { return 0 }
    return str.components(separatedBy: substring).count - 1
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
int countChars(String str, String substring) {
  if (substring.isEmpty) {
    return 0;
  }
  return substring.allMatches(str).length;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
function countChars(str: string, substring: string): number {
    if (!substring) return 0;
    // Use a regular expression to count all occurrences
    const escapedSubstring = substring.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(escapedSubstring, 'g');
    return (str.match(regex) || []).length;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: countChars
libs: null
description: string~~~Counts the occurrences of a specific character (`theChar`) or a substring within a given `string`. Case-sensitivity depends on the target language.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world, hello htvm"~~~str charToCount1 := "h"~~~int count1 := countChars(text1, charToCount1)~~~print("Count of '" . charToCount1 . "' in '" . text1 . "' is: " . STR(count1))~~~; Expected: 3~~~if (count1 != 3) {~~~    print("countChars test 1 (single char) FAILED! Expected 2, Got: " . STR(count1))~~~}~~~; ----------------------------------------------------~~~str text2 := "banana"~~~str charToCount2 := "a"~~~int count2 := text2.countChars(charToCount2)~~~print("Count of '" . charToCount2 . "' in '" . text2 . "' is: " . STR(count2))~~~; Expected: 3~~~if (count2 != 3) {~~~    print("countChars test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := "no_such_char_here"~~~str charToCount4 := "z"~~~int count4 := countChars(text4, charToCount4)~~~print("Count of '" . charToCount4 . "' in '" . text4 . "' is: " . STR(count4))~~~; Expected: 0~~~if (count4 != 0) {~~~    print("countChars test 4 FAILED!")~~~}~~~```~~~
int countChars(String str, String substring) {
    if (substring == null || substring.isEmpty()) {
        return 0
    }
    return str.count(substring)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: StrLen
libs: )|"unicode/utf8"
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
func StrLen(s string) int {
	return utf8.RuneCountInString(s)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
-- Assumes a 'unicode' library is available for proper character counting.
-- If not, #str would count bytes.
function StrLen(str)
    return utf8.len(str)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
public static int StrLen(string str) {
    return str.Length;
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
public static int StrLen(String str) {
    return str.codePointCount(0, str.length());
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
fun StrLen(str: String): Int {
    return str.length
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
def StrLen(str)
  str.length
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StrLen
libs: import unicode
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
proc StrLen(s: string): int =
  return s.runeLen
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
; built-in StrLen() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
func StrLen(_ str: String) -> Int {
    return str.count
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
int StrLen(String str) {
  return str.runes.length;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
function StrLen(str: string): number {
    return [...str].length;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StrLen
libs: null
description: string~~~Returns the length (number of characters) of a string.~~~Here is how to use it:~~~```htvm~~~str text1 := "Hello"~~~int len1 := StrLen(text1)~~~; Expected: 5~~~print("Length of '" . text1 . "' is: " . STR(len1))~~~if (len1 != 5) {~~~    print("StrLen test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := ""~~~; Empty string~~~int len2 := text2.StrLen()~~~; Expected: 0~~~print("Length of '' is: " . STR(len2))~~~if (len2 != 0) {~~~    print("StrLen test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "HTVM `nRocks!"~~~; Contains a newline~~~int len3 := StrLen(text3)~~~; Expected: 12 (newline is one char)~~~print("Length of 'HTVM `nRocks!' is: " . STR(len3))~~~if (len3 != 12) {~~~    print("StrLen test 3 FAILED!")~~~}~~~```~~~
int StrLen(String str) {
    return str.length()
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: StrLower
libs: )|"strings"
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
func StrLower(s string) string {
    return strings.ToLower(s)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
function StrLower(str)
    return string.lower(str)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StrLower
libs: using System;
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
public static string StrLower(string str) {
    return str.ToLower();
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
public static String StrLower(String str) {
    return str.toLowerCase();
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
fun StrLower(str: String): String {
    return str.toLowerCase()
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
def StrLower(str)
  str.downcase
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StrLower
libs: import strutils
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
proc StrLower(s: string): string =
  return s.toLower()
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
StrLower(str) {
    StringLower, output, str
    return output
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
func StrLower(_ str: String) -> String {
    return str.lowercased()
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
String StrLower(String str) {
  return str.toLowerCase();
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
function StrLower(str: string): string {
    return str.toLowerCase();
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StrLower
libs: null
description: string~~~Converts all uppercase characters in a string to lowercase. Non-alphabetic characters are unaffected.~~~Here is how to use it:~~~```htvm~~~str text1 := "HeLlO, WoRlD!"~~~str lower1 := StrLower(text1)~~~; Expected: 'hello, world!'~~~print("StrLower('" . text1 . "') = '" . lower1 . "'")~~~if (lower1 != "hello, world!") {~~~    print("StrLower test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM ROCKS 123!"~~~str lower2 := text2.StrLower~~~; Expected: 'htvm rocks 123!'~~~print("StrLower('" . text2 . "') = '" . lower2 . "'")~~~if (lower2 != "htvm rocks 123!") {~~~    print("StrLower test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "already lowercase"~~~str lower3 := StrLower(text3)~~~; Expected: 'already lowercase'~~~print("StrLower('" . text3 . "') = '" . lower3 . "'")~~~if (lower3 != "already lowercase") {~~~    print("StrLower test 3 FAILED!")~~~}~~~```~~~
String StrLower(String str) {
    return str.toLowerCase()
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: StrReplace
libs: )|"strings"
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
func StrReplace(originalString, find, replaceWith string) string {
    return strings.ReplaceAll(originalString, find, replaceWith)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
function StrReplace(originalString, find, replaceWith)
    local newStr, _ = string.gsub(originalString, find, replaceWith)
    return newStr
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StrReplace
libs: using System;
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
public static string StrReplace(string originalString, string find, string replaceWith) {
    return originalString.Replace(find, replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
public static String StrReplace(String originalString, String find, String replaceWith) {
    return originalString.replace(find, replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
fun StrReplace(originalString: String, find: String, replaceWith: String): String {
    return originalString.replace(find, replaceWith)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
def StrReplace(originalString, find, replaceWith)
  originalString.gsub(find, replaceWith)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StrReplace
libs: import strutils
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
proc StrReplace(originalString, find, replaceWith: string): string =
  return originalString.replace(find, replaceWith)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
; built-in StrReplace() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
func StrReplace(_ originalString: String, _ find: String, _ replaceWith: String) -> String {
    return originalString.replacingOccurrences(of: find, with: replaceWith)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
String StrReplace(String originalString, String find, String replaceWith) {
  return originalString.replaceAll(find, replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
function StrReplace(originalString: string, find: string, replaceWith: string): string {
    return originalString.replaceAll(find, replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StrReplace
libs: null
description: string~~~Replaces all occurrences of a `find` substring within an `originalString` with a `replaceWith` string. Returns the modified string.~~~Here is how to use it:~~~```htvm~~~str original1 := "Hello World, Hello HTVM!"~~~str find1 := "Hello"~~~str replace1 := "Greetings"~~~str result1 := StrReplace(original1, find1, replace1)~~~print("Replacing '" . find1 . "' in '" . original1 . "' with '" . replace1 . "': '" . result1 . "'")~~~; Expected: 'Greetings World, Greetings HTVM!'~~~if (result1 != "Greetings World, Greetings HTVM!") {~~~    print("StrReplace test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original2 := "one two three two one"~~~str find2 := "two"~~~str replace2 := "2"~~~str result2 := original2.StrReplace(find2, replace2)~~~print("Replacing '" . find2 . "' in '" . original2 . "' with '" . replace2 . "': '" . result2 . "'")~~~; Expected: 'one 2 three 2 one'~~~if (result2 != "one 2 three 2 one") {~~~    print("StrReplace test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original3 := "No change needed"~~~str find3 := "XYZ"~~~str replace3 := "ABC"~~~str result3 := StrReplace(original3, find3, replace3)~~~print("Replacing '" . find3 . "' in '" . original3 . "' (not found): '" . result3 . "'")~~~; Expected: 'No change needed'~~~if (result3 != "No change needed") {~~~    print("StrReplace test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str original4 := "Remove this"~~~str find4 := " this"~~~str replace4 := ""~~~; Replace with empty string to delete~~~str result4 := StrReplace(original4, find4, replace4)~~~print("Deleting '" . find4 . "' from '" . original4 . "': '" . result4 . "'")~~~; Expected: 'Remove'~~~if (result4 != "Remove") {~~~    print("StrReplace test 4 (deletion) FAILED!")~~~}~~~```~~~
String StrReplace(String originalString, String find, String replaceWith) {
    return originalString.replace(find, replaceWith)
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: StrSplit
libs: )|"strings"
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
func StrSplit(inputStr, delimiter string, num int) string {
    if num <= 0 {
        return ""
    }
    parts := strings.Split(inputStr, delimiter)
    if num > len(parts) {
        return ""
    }
    return parts[num-1]
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
function StrSplit(inputStr, delimiter, num)
    if num <= 0 then return "" end
    local parts = {}
    local start = 1
    local delim_len = #delimiter
    local split_start, split_end = string.find(inputStr, delimiter, start, true)
    while split_start do
        table.insert(parts, inputStr:sub(start, split_start - 1))
        start = split_end + 1
        split_start, split_end = string.find(inputStr, delimiter, start, true)
    end
    table.insert(parts, inputStr:sub(start))
    return parts[num] or ""
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StrSplit
libs: using System;
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
public static string StrSplit(string inputStr, string delimiter, int num) {
    if (num <= 0) return "";
    string[] parts = inputStr.Split(new[] { delimiter }, StringSplitOptions.None);
    if (num > parts.Length) return "";
    return parts[num - 1];
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StrSplit
libs: import java.util.regex.Pattern;
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
public static String StrSplit(String inputStr, String delimiter, int num) {
    if (num <= 0) return "";
    String[] parts = inputStr.split(Pattern.quote(delimiter));
    if (num > parts.length) return "";
    return parts[num - 1];
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
fun StrSplit(inputStr: String, delimiter: String, num: Int): String {
    if (num <= 0) return ""
    val parts = inputStr.split(delimiter)
    return parts.getOrNull(num - 1) ?: ""
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
def StrSplit(inputStr, delimiter, num)
  return "" if num <= 0
  parts = inputStr.split(delimiter)
  return parts[num - 1] || ""
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StrSplit
libs: import strutils
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
proc StrSplit(inputStr, delimiter: string, num: int): string =
  if num <= 0:
    return ""
  let parts = inputStr.split(delimiter)
  if num > parts.len:
    return ""
  return parts[num - 1]
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
AHK_StrSplit_AHK(str, delim, index) {
    arr := StrSplit(str, delim)
    return arr.HasKey(index) ? arr[index] : ""
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
func StrSplit(_ inputStr: String, _ delimiter: String, _ num: Int) -> String {
    guard num > 0 else { return "" }
    let parts = inputStr.components(separatedBy: delimiter)
    guard num <= parts.count else { return "" }
    return parts[num - 1]
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
String StrSplit(String inputStr, String delimiter, int num) {
  if (num <= 0) return "";
  var parts = inputStr.split(delimiter);
  if (num > parts.length) return "";
  return parts[num - 1];
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
function StrSplit(inputStr: string, delimiter: string, num: number): string {
    if (num <= 0) return "";
    const parts = inputStr.split(delimiter);
    if (num > parts.length) return "";
    return parts[num - 1];
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StrSplit
libs: null
description: string~~~Splits an `inputStr` by a `delimiter` and returns the Nth part (1-based index `num`). If `num` is out of range, or the delimiter is not found appropriately, it may return an empty string or cause an error depending on the language.~~~Here is how to use it:~~~```htvm~~~str data1 := "apple,banana,cherry,date"~~~str delimiter1 := ","~~~int partNum1 := 2~~~str fruit1 := StrSplit(data1, delimiter1, partNum1)~~~; Expected: 'banana'~~~print("Part " . STR(partNum1) . " of '" . data1 . "' with delimiter '" . delimiter1 . "' is: '" . fruit1 . "'")~~~if (fruit1 != "banana") {~~~    print("StrSplit test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum2 := 4~~~str fruit2 := data1.StrSplit(delimiter1, partNum2)~~~; Expected: 'date'~~~print("Part " . STR(partNum2) . " is: '" . fruit2 . "'")~~~if (fruit2 != "date") {~~~    print("StrSplit test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~int partNum3 := 1~~~str fruit3 := StrSplit(data1, delimiter1, partNum3)~~~; Expected: 'apple'~~~print("Part " . STR(partNum3) . " is: '" . fruit3 . "'")~~~if (fruit3 != "apple") {~~~    print("StrSplit test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Out of bounds~~~int partNum4 := 5~~~str fruit4 := StrSplit(data1, delimiter1, partNum4)~~~; Expected: '' (empty string)~~~print("Part " . STR(partNum4) . " (out of bounds) is: '" . fruit4 . "'")~~~if (fruit4 != "") {~~~    print("StrSplit test 4 (out of bounds) FAILED! Got: " . fruit4)~~~}~~~; ----------------------------------------------------~~~str data2 := "one;-;two;-;three"~~~str delimiter2 := ";-;"~~~int partNum5 := 3~~~str item5 := StrSplit(data2, delimiter2, partNum5)~~~; Expected: 'three'~~~print("Part " . STR(partNum5) . " of '" . data2 . "' with delimiter '" . delimiter2 . "' is: '" . item5 . "'")~~~if (item5 != "three") {~~~    print("StrSplit test 5 FAILED!")~~~}~~~```~~~
String StrSplit(String inputStr, String delimiter, int num) {
    if (num <= 0) return ""
    String[] parts = inputStr.split(java.util.regex.Pattern.quote(delimiter))
    if (num > parts.length) return ""
    return parts[num - 1]
}
funcEND======================funcEND==============



func======================func==============
lang: go
name: StrTitleCase
libs: )|"strings"
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
func StrTitleCase(s string) string {
	return strings.Title(strings.ToLower(s))
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
function StrTitleCase(str)
    local s = string.lower(str)
    s = string.gsub(s, "(%w)(%w*)", function(first, rest)
        return string.upper(first) .. rest
    end)
    return s
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StrTitleCase
libs: using System.Globalization;
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
private static readonly TextInfo textInfo = new CultureInfo("en-US", false).TextInfo;
public static string StrTitleCase(string str) {
    return textInfo.ToTitleCase(str.ToLower());
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
public static String StrTitleCase(String input) {
    if (input == null || input.isEmpty()) {
        return "";
    }
    StringBuilder titleCase = new StringBuilder(input.length());
    boolean nextTitleCase = true;
    for (char c : input.toLowerCase().toCharArray()) {
        if (Character.isSpaceChar(c)) {
            nextTitleCase = true;
        } else if (nextTitleCase) {
            c = Character.toTitleCase(c);
            nextTitleCase = false;
        }
        titleCase.append(c);
    }
    return titleCase.toString();
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~

fun StrTitleCase(str: String): String {
    return str.split(' ').joinToString(" ") { word ->
        if (word.isEmpty()) return@joinToString word
        val firstChar = word[0].toUpperCase()
        val rest = if (word.length > 1) word.substring(1).toLowerCase() else ""
        firstChar + rest
    }
}

funcEND======================funcEND==============
func======================func==============
lang: rb
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
def StrTitleCase(str)
  str.split.map(&:capitalize).join(' ')
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StrTitleCase
libs: import strutils, sequtils
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~

proc StrTitleCase(s: string): string =
  result = s.split(' ').map(proc(word: string): string =
    if word.len > 0:
      word[0].toUpperAscii() & word[1..^1].toLowerAscii()
    else:
      word
  ).join(" ")

funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
StrTitleCase(str) {
    StringLower, str, str, T
    return str
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
func StrTitleCase(_ str: String) -> String {
    return str.capitalized
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
String StrTitleCase(String str) {
  if (str.isEmpty) return "";
  return str.split(' ').map((word) {
    if (word.isEmpty) return "";
    return word[0].toUpperCase() + word.substring(1).toLowerCase();
  }).join(' ');
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~
function StrTitleCase(str: string): string {
    return str.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StrTitleCase
libs: null
description: string~~~Converts a string to title case, where the first letter of each word is capitalized and all other letters are lowercase. Words are generally delimited by spaces.~~~Here is how to use it:~~~```htvm~~~str text1 := "hello world example"~~~str title1 := StrTitleCase(text1)~~~; Expected: 'Hello World Example'~~~print("Title case of '" . text1 . "': '" . title1 . "'")~~~if (title1 != "Hello World Example") {~~~    print("StrTitleCase test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "HTVM is AWESOME"~~~str title2 := text2.StrTitleCase~~~; Expected: 'Htvm Is Awesome'~~~print("Title case of '" . text2 . "': '" . title2 . "'")~~~if (title2 != "Htvm Is Awesome") {~~~    print("StrTitleCase test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Already Title Case"~~~str title3 := StrTitleCase(text3)~~~; Expected: 'Already Title Case'~~~print("Title case of '" . text3 . "': '" . title3 . "'")~~~if (title3 != "Already Title Case") {~~~    print("StrTitleCase test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text4 := " leading space"~~~str title4 := StrTitleCase(text4)~~~; Expected: ' Leading Space'~~~print("Title case of '" . text4 . "': '" . title4 . "'")~~~if (title4 != " Leading Space") {~~~    print("StrTitleCase test 4 FAILED!")~~~}~~~```~~~

String StrTitleCase(String str) {
    return (String)(str.split(' ').collect {
        if (it.length() > 0)
            it[0].toUpperCase() + it.substring(1).toLowerCase()
        else
            it
    }.join(' '))
}

funcEND======================funcEND==============




func======================func==============
lang: go
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
func StringTrimLeft(input string, numChars int) string {
    if numChars <= 0 {
        return input
    }
    runes := []rune(input)
    if numChars >= len(runes) {
        return ""
    }
    return string(runes[numChars:])
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimLeft(input, numChars)
    if numChars <= 0 then return input end
    return string.sub(input, numChars + 1)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
public static string StringTrimLeft(string input, int numChars) {
    if (input == null || numChars <= 0) return input;
    if (numChars >= input.Length) return "";
    return input.Substring(numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
public static String StringTrimLeft(String input, int numChars) {
    if (input == null || numChars <= 0) return input;
    if (numChars >= input.length()) return "";
    return input.substring(numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
fun StringTrimLeft(input: String, numChars: Int): String {
    if (numChars <= 0) return input
    return input.drop(numChars)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
def StringTrimLeft(input, numChars)
    return input if numChars <= 0
    return input[numChars..-1] || ""
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StringTrimLeft
libs: import strutils
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
proc StringTrimLeft(s: string, numChars: int): string =
  if numChars <= 0:
    return s
  if numChars >= s.len:
    return ""
  return s.substr(numChars)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
StringTrimLeft(str, count) {
    if (count > StrLen(str))
        return ""  ; Or decide how you want to handle too large count
    return SubStr(str, count + 1)
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
func StringTrimLeft(_ input: String, _ numChars: Int) -> String {
    guard numChars > 0 else { return input }
    return String(input.dropFirst(numChars))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
String StringTrimLeft(String input, int numChars) {
  if (numChars <= 0) return input;
  if (numChars >= input.length) return "";
  return input.substring(numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimLeft(input: string, numChars: number): string {
    if (numChars <= 0) return input;
    return input.substring(numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StringTrimLeft
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the beginning (left side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string depending on implementation.~~~Here is how to use it:~~~```htvm~~~str text1 := "HelloHTVM"~~~int charsToTrim1 := 5~~~str result1 := StringTrimLeft(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from left of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimLeft test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Goodbye"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimLeft(charsToTrim2)~~~; Expected: 'dbye'~~~print("Trimming " . STR(charsToTrim2) . " chars from left of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "dbye") {~~~    print("StringTrimLeft test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Short"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimLeft(text3, charsToTrim3)~~~; Expected: '' (or "Short", behavior might vary)~~~; For HTVM, typically it results in the same string if trim count exceeds length but it depends on the implementation.~~~print("Trimming " . STR(charsToTrim3) . " chars from left of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimLeft(text1, charsToTrim4)~~~; Expected: 'HelloHTVM'~~~print("Trimming " . STR(charsToTrim4) . " chars from left of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HelloHTVM") {~~~    print("StringTrimLeft test 4 (zero trim) FAILED!")~~~}~~~```~~~
String StringTrimLeft(String input, int numChars) {
    if (input == null || numChars <= 0) return input
    if (numChars >= input.length()) return ""
    return input.substring(numChars)
}
funcEND======================funcEND==============



func======================func==============
lang: go
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
func StringTrimRight(input string, numChars int) string {
    if numChars <= 0 {
        return input
    }
    runes := []rune(input)
    if numChars >= len(runes) {
        return ""
    }
    return string(runes[:len(runes)-numChars])
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimRight(input, numChars)
    if numChars <= 0 then return input end
    if numChars >= #input then return "" end
    return string.sub(input, 1, #input - numChars)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
public static string StringTrimRight(string input, int numChars) {
    if (input == null || numChars <= 0) return input;
    if (numChars >= input.Length) return "";
    return input.Substring(0, input.Length - numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
public static String StringTrimRight(String input, int numChars) {
    if (input == null || numChars <= 0) return input;
    if (numChars >= input.length()) return "";
    return input.substring(0, input.length() - numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
fun StringTrimRight(input: String, numChars: Int): String {
    if (numChars <= 0) return input
    return input.dropLast(numChars)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
def StringTrimRight(input, numChars)
    return input if numChars <= 0
    return "" if numChars >= input.length
    return input[0, input.length - numChars]
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: StringTrimRight
libs: import strutils
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
proc StringTrimRight(s: string, numChars: int): string =
  if numChars <= 0:
    return s
  if numChars >= s.len:
    return ""
  return s.substr(0, s.len - numChars - 1)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
StringTrimRight(str, count) {
    len := StrLen(str)
    if (count > len)
        return str  ; or return "" if you prefer trimming all
    return SubStr(str, 1, len - count)
}

funcEND======================funcEND==============
func======================func==============
lang: swift
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
func StringTrimRight(_ input: String, _ numChars: Int) -> String {
    guard numChars > 0 else { return input }
    return String(input.dropLast(numChars))
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
String StringTrimRight(String input, int numChars) {
  if (numChars <= 0) return input;
  if (numChars >= input.length) return "";
  return input.substring(0, input.length - numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
function StringTrimRight(input: string, numChars: number): string {
    if (numChars <= 0) return input;
    return input.slice(0, -numChars);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: StringTrimRight
libs: null
description: string~~~Removes a specified number of characters (`numChars`) from the end (right side) of a string. If `numChars` is greater than the string length, the result might be an empty string or the original string.~~~Here is how to use it:~~~```htvm~~~str text1 := "HTVMHello"~~~int charsToTrim1 := 5~~~str result1 := StringTrimRight(text1, charsToTrim1)~~~; Expected: 'HTVM'~~~print("Trimming " . STR(charsToTrim1) . " chars from right of '" . text1 . "': '" . result1 . "'")~~~if (result1 != "HTVM") {~~~    print("StringTrimRight test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text2 := "Welcome"~~~int charsToTrim2 := 3~~~str result2 := text2.StringTrimRight(charsToTrim2)~~~; Expected: 'Welc'~~~print("Trimming " . STR(charsToTrim2) . " chars from right of '" . text2 . "': '" . result2 . "'")~~~if (result2 != "Welc") {~~~    print("StringTrimRight test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~str text3 := "Tiny"~~~int charsToTrim3 := 10~~~; More than length~~~str result3 := StringTrimRight(text3, charsToTrim3)~~~; Expected: "Tiny" it will not Trim since it exceeds the character limit. But it depends on the language.~~~print("Trimming " . STR(charsToTrim3) . " chars from right of '" . text3 . "': '" . result3 . "'")~~~; ----------------------------------------------------~~~int charsToTrim4 := 0~~~str result4 := StringTrimRight(text1, charsToTrim4)~~~; Expected: 'HTVMHello'~~~print("Trimming " . STR(charsToTrim4) . " chars from right of '" . text1 . "': '" . result4 . "'")~~~if (result4 != "HTVMHello") {~~~    print("StringTrimRight test 4 (zero trim) FAILED!")~~~}~~~```~~~
String StringTrimRight(String input, int numChars) {
    if (input == null || numChars <= 0) return input
    if (numChars >= input.length()) return ""
    return input.substring(0, input.length() - numChars)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
func SubStr(s string, startPos int, length ...int) string {
	runes := []rune(s)
	strLen := len(runes)

	var startIndex int
	if startPos > 0 {
		startIndex = startPos - 1
	} else {
		startIndex = strLen + startPos
	}

	if startIndex < 0 || startIndex >= strLen {
		return ""
	}

	if len(length) == 0 {
		return string(runes[startIndex:])
	}

	lenVal := length[0]
	if lenVal < 0 {
		return ""
	}

	endIndex := startIndex + lenVal
	if endIndex > strLen {
		endIndex = strLen
	}

	return string(runes[startIndex:endIndex])
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
function SubStr(str, startPos, length)
    if length == nil then
        return string.sub(str, startPos)
    end
    if startPos < 0 then
        startPos = #str + startPos + 1
    end
    return string.sub(str, startPos, startPos + length - 1)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: SubStr
libs: using System;
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
public static string SubStr(string str, int startPos, int length = -1) {
    if (string.IsNullOrEmpty(str)) return "";
    
    int strLen = str.Length;
    int startIndex = (startPos > 0) ? startPos - 1 : strLen + startPos;

    if (startIndex < 0 || startIndex >= strLen) return "";

    if (length < 0) {
        return str.Substring(startIndex);
    }
    
    if (startIndex + length > strLen) {
        length = strLen - startIndex;
    }
    
    return str.Substring(startIndex, length);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
public static String SubStr(String str, int startPos, int length) {
    if (str == null || str.isEmpty()) return "";
    int strLen = str.length();
    int startIndex = (startPos > 0) ? startPos - 1 : strLen + startPos;

    if (startIndex < 0 || startIndex >= strLen) return "";

    if (length < 0) {
        return str.substring(startIndex);
    }

    int endIndex = startIndex + length;
    if (endIndex > strLen) {
        endIndex = strLen;
    }
    return str.substring(startIndex, endIndex);
}
public static String SubStr(String str, int startPos) {
    return SubStr(str, startPos, -1);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
fun SubStr(str: String, startPos: Int, length: Int = -1): String {
    if (str.isEmpty()) return ""
    val strLen = str.length
    var startIndex = if (startPos > 0) startPos - 1 else strLen + startPos
    
    if (startIndex !in 0 until strLen) return ""

    if (length < 0) {
        return str.substring(startIndex)
    }

    var endIndex = startIndex + length
    if (endIndex > strLen) {
        endIndex = strLen
    }
    
    return str.substring(startIndex, endIndex)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
def SubStr(str, startPos, length = nil)
  startIndex = startPos > 0 ? startPos - 1 : startPos
  if length.nil?
    str[startIndex..-1] || ""
  else
    str[startIndex, length] || ""
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
proc SubStr(s: string, startPos: int, length: int = -1): string =
  let sLen = s.len
  var startIndex = if startPos > 0: startPos - 1 else: sLen + startPos
  if startIndex < 0 or startIndex >= sLen: return ""
  
  if length < 0:
    return s.substr(startIndex)
  else:
    var endIndex = startIndex + length - 1
    if endIndex >= sLen: endIndex = sLen - 1
    return s[startIndex..endIndex]
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
; built-in SubStr() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
func SubStr(_ str: String, _ startPos: Int, _ length: Int = -1) -> String {
    let strCount = str.count
    var startIndexOffset = (startPos > 0) ? startPos - 1 : strCount + startPos
    
    guard startIndexOffset >= 0, startIndexOffset < strCount else { return "" }

    let startIndex = str.index(str.startIndex, offsetBy: startIndexOffset)

    if length < 0 {
        return String(str[startIndex...])
    }

    let endIndexOffset = min(startIndexOffset + length, strCount)
    let endIndex = str.index(str.startIndex, offsetBy: endIndexOffset)
    
    return String(str[startIndex..<endIndex])
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
String SubStr(String str, int startPos, [int length = -1]) {
  if (str.isEmpty) return "";
  var runes = str.runes.toList();
  int strLen = runes.length;
  
  int startIndex = (startPos > 0) ? startPos - 1 : strLen + startPos;
  
  if (startIndex < 0 || startIndex >= strLen) return "";

  if (length < 0) {
    return String.fromCharCodes(runes.sublist(startIndex));
  }

  int endIndex = startIndex + length;
  if (endIndex > strLen) {
    endIndex = strLen;
  }
  
  return String.fromCharCodes(runes.sublist(startIndex, endIndex));
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
function SubStr(str: string, startPos: number, length: number = -1): string {
    // Handle true characters (runes) instead of just code units
    const runes = [...str];
    const strLen = runes.length;
    let startIndex = (startPos > 0) ? startPos - 1 : strLen + startPos;

    if (startIndex < 0 || startIndex >= strLen) {
        return "";
    }
    
    if (length < 0) {
        return runes.slice(startIndex).join('');
    }

    return runes.slice(startIndex, startIndex + length).join('');
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: SubStr
libs: null
description: string~~~Extracts a substring from a string. `startPos` is the 1-based starting position. `length` is optional; if omitted, it extracts to the end of the string. Negative `startPos` counts from the end of the string.~~~Here is how to use it:~~~```htvm~~~str text := "Hello, HTVM World!"~~~; ----------------------------------------------------~~~; Example 1: Basic substring~~~int start1 := 8~~~int len1 := 4~~~str sub1 := SubStr(text, start1, len1)~~~print("SubStr('" . text . "', " . STR(start1) . ", " . STR(len1) . ") = '" . sub1 . "'")~~~; Expected: 'HTVM'~~~if (sub1 != "HTVM") {~~~    print("SubStr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 2: Substring to end~~~int start2 := 13~~~str sub2 := text.SubStr(start2)~~~print("SubStr('" . text . "', " . STR(start2) . ") = '" . sub2 . "'")~~~; Expected: 'World!'~~~if (sub2 != "World!") {~~~    print("SubStr test 2 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 3: Negative start position~~~int start3 := -6~~~str sub3 := SubStr(text, start3)~~~print("SubStr('" . text . "', " . STR(start3) . ") = '" . sub3 . "'")~~~; Expected: 'World!'~~~if (sub3 != "World!") {~~~    print("SubStr test 3 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 4: Negative start and specific length~~~int start4 := -6~~~int len4 := 5~~~str sub4 := SubStr(text, start4, len4)~~~print("SubStr('" . text . "', " . STR(start4) . ", " . STR(len4) . ") = '" . sub4 . "'")~~~; Expected: 'World'~~~if (sub4 != "World") {~~~    print("SubStr test 4 FAILED!")~~~}~~~; ----------------------------------------------------~~~; Example 5: Start position 1~~~int start5 := 1~~~int len5 := 5~~~str sub5 := SubStr(text, start5, len5)~~~print("SubStr('" . text . "', " . STR(start5) . ", " . STR(len5) . ") = '" . sub5 . "'")~~~; Expected: 'Hello'~~~if (sub5 != "Hello") {~~~    print("SubStr test 5 FAILED!")~~~}~~~```~~~
String SubStr(String str, int startPos, int length = -1) {
    if (str == null || str.isEmpty()) return ""
    int strLen = str.length()
    int startIndex = (startPos > 0) ? startPos - 1 : strLen + startPos

    if (startIndex < 0 || startIndex >= strLen) return ""

    if (length < 0) {
        return str.substring(startIndex)
    }
    
    int endIndex = startIndex + length
    if (endIndex > strLen) {
        endIndex = strLen
    }
    
    return str.substring(startIndex, endIndex)
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: Trim
libs: )|"strings"
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
func Trim(inputString string) string {
    return strings.TrimSpace(inputString)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
function Trim(inputString)
    return string.match(inputString, "^%s*(.-)%s*$")
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
public static string Trim(string inputString) {
    return inputString.Trim();
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
public static String Trim(String inputString) {
    return inputString.trim();
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
fun Trim(inputString: String): String {
    return inputString.trim()
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
def Trim(inputString)
  inputString.strip
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Trim
libs: import strutils
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
proc Trim(inputString: string): string =
  return inputString.strip()
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
; built-in Trim() is used
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
func Trim(_ inputString: String) -> String {
    return inputString.trimmingCharacters(in: .whitespacesAndNewlines)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
String Trim(String inputString) {
  return inputString.trim();
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
function Trim(inputString: string): string {
    return inputString.trim();
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Trim
libs: null
description: string~~~Removes all leading and trailing whitespace (spaces, tabs, newlines, etc.) from the input string. If the input string is empty or contains only whitespace, it returns an empty string. It's useful for cleaning up user input or data read from files before processing.~~~Here is how to use it:~~~```htvm~~~str text1 := "   Hello, HTVM!   "~~~str trimmed1 := Trim(text1)~~~print("Original 1: '" . text1 . "'")~~~print("Trimmed 1 : '" . trimmed1 . "'")~~~; Expected: 'Hello, HTVM!'~~~if (trimmed1 != "Hello, HTVM!") {~~~    print("Trim test 1 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text2 := "`t`n  HTVM Rocks! `n`r"~~~str trimmed2 := text2.Trim()~~~print("Original 2: '" . text2 . "' (has tabs/newlines)")~~~print("Trimmed 2 : '" . trimmed2 . "'")~~~; Expected: 'HTVM Rocks!'~~~if (trimmed2 != "HTVM Rocks!") {~~~    print("Trim test 2 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text3 := "   "~~~str trimmed3 := text3.Trim~~~print("Original 3: '" . text3 . "' (only spaces)")~~~print("Trimmed 3 : '" . trimmed3 . "'")~~~; Expected: ''~~~if (trimmed3 != "") {~~~    print("Trim test 3 FAILED! Oh noes!")~~~}~~~; ----------------------------------------------------~~~str text4 := "NoSpaces"~~~str trimmed4 := Trim(text4)~~~print("Original 4: '" . text4 . "'")~~~print("Trimmed 4 : '" . trimmed4 . "'")~~~; Expected: 'NoSpaces'~~~if (trimmed4 != "NoSpaces") {~~~    print("Trim test 4 FAILED! Oh noes!")~~~}~~~```~~~
String Trim(String inputString) {
    return inputString.trim();
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: sortArr
libs: )|"sort"
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
func sortArr(input []string) []string {
    if len(input) == 0 {
        return []string{}
    }
    seen := make(map[string]bool)
    unique := []string{}
    for _, item := range input {
        if !seen[item] {
            seen[item] = true
            unique = append(unique, item)
        }
    }
    sort.Strings(unique)
    return unique
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
function sortArr(input)
    local seen = {}
    local unique = {}
    for i, v in ipairs(input) do
        if not seen[v] then
            table.insert(unique, v)
            seen[v] = true
        end
    end
    table.sort(unique)
    return unique
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: sortArr
libs: using System.Collections.Generic;|using System.Linq;
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
public static List<string> sortArr(List<string> input) {
    return input.Distinct(System.StringComparer.Ordinal).OrderBy(s => s, System.StringComparer.Ordinal).ToList();
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: sortArr
libs: import java.util.*;
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
public static ArrayList<String> sortArr(List<String> input) {
    return new ArrayList<>(new TreeSet<>(input));
}

funcEND======================funcEND==============
func======================func==============
lang: kt
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
fun sortArr(input: List<String>): ArrayList<String> {
    return ArrayList(input.distinct().sorted())
}

funcEND======================funcEND==============
func======================func==============
lang: rb
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
def sortArr(input)
  input.uniq.sort
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: sortArr
libs: import sets, sequtils, algorithm
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
proc sortArr(input: seq[string]): seq[string] =
  var uniqueSorted = toSeq(input.toHashSet())
  uniqueSorted.sort(system.cmp[string])
  return uniqueSorted
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
; Custom string comparison function for lexicographical ordering
sortArr_HELP_StringCompare(str1, str2) {
    ; Compare strings character by character
    len1 := StrLen(str1)
    len2 := StrLen(str2)
    minLen := len1 < len2 ? len1 : len2
    
    Loop, %minLen% {
        char1 := Asc(SubStr(str1, A_Index, 1))
        char2 := Asc(SubStr(str2, A_Index, 1))
        if (char1 < char2)
            return -1
        if (char1 > char2)
            return 1
    }
    
    ; If all compared characters are equal, shorter string comes first
    if (len1 < len2)
        return -1
    if (len1 > len2)
        return 1
    return 0
}

sortArr(input) {
    unique := []
    for index, value in input {
        ; Case-sensitive duplicate checking by comparing with existing elements
        isDuplicate := false
        for i, existing in unique {
            if (value == existing) {
                isDuplicate := true
                break
            }
        }
        if (!isDuplicate) {
            unique.Push(value)
        }
    }
    size := unique.Length()
    
    ; Bubble sort implementation (lexicographical/string comparison)
    Loop, % size - 1 {
        outerLoop := A_Index
        Loop, % size - outerLoop {
            currentIndex := A_Index
            ; Use custom string comparison for proper lexicographical comparison
            if (sortArr_HELP_StringCompare(unique[currentIndex], unique[currentIndex + 1]) > 0) {
                temp := unique[currentIndex]
                unique[currentIndex] := unique[currentIndex + 1]
                unique[currentIndex + 1] := temp
            }
        }
    }
    return unique
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
func sortArr(_ input: [String]) -> [String] {
    var uniqueItems = [String]()
    var seen = Set<String>()
    for item in input {
        if !seen.contains(item) {
            uniqueItems.append(item)
            seen.insert(item)
        }
    }
    return uniqueItems.sorted()
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
List<String> sortArr(List<String> input) {
  var unique = input.toSet().toList();
  unique.sort();
  return unique;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
function sortArr(input: string[]): string[] {
    return [...new Set(input)].sort();
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: sortArr
libs: null
description: string~~~Sorts an array of strings in ascending order. It typically removes duplicate values before sorting, resulting in an array of unique, sorted strings. The sorting is usually case-insensitive by default, but this can vary by language.~~~Here is how to use it:~~~```htvm~~~arr str unsortedArr1 := ["Charlie", "Alpha", "Bravo", "alpha"]~~~arr str sortedArr1~~~sortedArr1 := sortArr(unsortedArr1)~~~print("Original Array 1: ")~~~Loop, % unsortedArr1.size() {~~~    print("  " . unsortedArr1[A_Index])~~~}~~~print("Sorted Unique Array 1: ")~~~Loop, % sortedArr1.size() {~~~    print("  " . sortedArr1[A_Index])~~~}~~~; Expected (case-sensitive): ["Alpha", "Bravo", "Charlie", "alpha"]~~~if (sortedArr1.size() != 4 or sortedArr1[0] != "Alpha" or sortedArr1[1] != "Bravo" or sortedArr1[2] != "Charlie" or sortedArr1[3] != "alpha") {~~~    print("sortArr test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str unsortedArr2 := ["10", "2", "100", "1", "2"]~~~arr str sortedArr2~~~sortedArr2 := unsortedArr2.sortArr()~~~; Alternative call~~~print("Original Array 2: ")~~~Loop, % unsortedArr2.size() {~~~    print("  " . unsortedArr2[A_Index])~~~}~~~print("Sorted Unique Array 2 (lexicographical): ")~~~Loop, % sortedArr2.size() {~~~    print("  " . sortedArr2[A_Index])~~~}~~~; Expected (lexicographical, unique): ["1", "10", "100", "2"]~~~if (sortedArr2.size() != 4 or sortedArr2[0] != "1" or sortedArr2[1] != "10" or sortedArr2[2] != "100" or sortedArr2[3] != "2") {~~~    print("sortArr test 2 FAILED!")~~~}~~~```~~~
List<String> sortArr(List<String> input) {
    return input.unique(false).sort(false)
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: sortArrByLenOnly
libs: )|"sort"
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
func sortArrByLenOnly(input []string) []string {
	sorted := make([]string, len(input))
	copy(sorted, input)
	sort.SliceStable(sorted, func(i, j int) bool {
		return len(sorted[i]) > len(sorted[j])
	})
	return sorted
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
function sortArrByLenOnly(input)
    local sorted = {}
    for i, v in ipairs(input) do sorted[i] = v end
    table.sort(sorted, function(a, b)
        return #a > #b
    end)
    return sorted
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: sortArrByLenOnly
libs: using System.Collections.Generic;|using System.Linq;
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
public static List<string> sortArrByLenOnly(List<string> input) {
    return input.OrderByDescending(s => s.Length).ToList();
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: sortArrByLenOnly
libs: import java.util.*;
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~

public static ArrayList<String> sortArrByLenOnly(ArrayList<String> input) {
    ArrayList<String> sorted = new ArrayList<>(input);
    sorted.sort((a, b) -> Integer.compare(b.length(), a.length()));
    return sorted;
}

funcEND======================funcEND==============
func======================func==============
lang: kt
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
fun sortArrByLenOnly(input: ArrayList<String>): ArrayList<String> {
    val sorted = ArrayList(input)
    sorted.sortWith(compareByDescending { it.length })
    return sorted
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
def sortArrByLenOnly(input)
  input.sort_by { |s| -s.length }
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: sortArrByLenOnly
libs: import algorithm
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
proc sortArrByLenOnly(input: seq[string]): seq[string] =
  var sorted = input
  sorted.sort(proc(a, b: string): int = cmp(b.len, a.len))
  return sorted
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
; Compare strings by length descending
sortArrByLenOnly_HELP_CompareLenDesc(a, b) {
    return StrLen(b) - StrLen(a)
}

sortArrByLenOnly(input) {
    sorted := input.Clone()
    size := sorted.Length()
    Loop, % size - 1 {
        outerLoop := A_Index
        Loop, % size - outerLoop {
            i := A_Index
            if (sortArrByLenOnly_HELP_CompareLenDesc(sorted[i], sorted[i+1]) > 0) {
                temp := sorted[i]
                sorted[i] := sorted[i+1]
                sorted[i+1] := temp
            }
        }
    }
    return sorted
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
func sortArrByLenOnly(_ input: [String]) -> [String] {
    return input.sorted { $0.count > $1.count }
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
List<String> sortArrByLenOnly(List<String> input) {
  var sorted = List<String>.from(input);
  sorted.sort((a, b) => b.length.compareTo(a.length));
  return sorted;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
function sortArrByLenOnly(input: string[]): string[] {
    return [...input].sort((a, b) => b.length - a.length);
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: sortArrByLenOnly
libs: null
description: string~~~Sorts an array of strings primarily by their length in descending order (longest strings first). If strings have the same length, their relative order might be preserved or sorted alphabetically, depending on the underlying sort stability and implementation.~~~Here is how to use it:~~~```htvm~~~arr str arr1 := ["a", "bb", "ccc", "dddd", "eeeee"]~~~; Should already be sorted by length descending~~~arr str sorted1~~~sorted1 := sortArrByLenOnly(arr1)~~~print("Original Array 1: eeeee, dddd, ccc, bb, a")~~~print("Sorted by Length Desc 1: ")~~~Loop, % sorted1.size() {~~~    print("  " . sorted1[A_Index])~~~}~~~if (sorted1[0] != "eeeee" or sorted1[4] != "a") {~~~    print("sortArrByLenOnly test 1 FAILED!")~~~}~~~; ----------------------------------------------------~~~print("--------------------")~~~arr str arr2 := ["short", "longer_word", "tiny", "very_long_length"]~~~arr str sorted2~~~sorted2 := arr2.sortArrByLenOnly()~~~print("Original Array 2: short, longer_word, tiny, very_long_length")~~~print("Sorted by Length Desc 2: ")~~~Loop, % sorted2.size() {~~~    print("  " . sorted2[A_Index])~~~}~~~; Expected: very_long_length, longer_word, short, tiny (order of same-length items may vary but probably alphabetically)~~~str expectedOrderStart := "very_long_length"~~~str expectedOrderEnd := "tiny"~~~if (sorted2[0] != expectedOrderStart or sorted2[3] != expectedOrderEnd) {~~~    print("sortArrByLenOnly test 2 FAILED! Check start/end elements.")~~~}~~~```~~~
List<String> sortArrByLenOnly(List<String> input) {
    return input.sort(false) { a, b -> b.length() <=> a.length() }
}
funcEND======================funcEND==============









func======================func==============
lang: go
name: BuildInVars
libs: )|"time"|"fmt"
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
var programStartTime = time.Now()
func BuildInVars(varName string) string {
    now := time.Now()
    switch varName {
    case "A_TickCount":
        return fmt.Sprintf("%d", now.Sub(programStartTime).Milliseconds())
    case "A_Now":
        return now.Format("2006-01-02 15:04:05")
    case "A_YYYY":
        return now.Format("2006")
    case "A_MM":
        return now.Format("01")
    case "A_DD":
        return now.Format("02")
    case "A_MMMM":
        return now.Format("January")
    case "A_MMM":
        return now.Format("Jan")
    case "A_DDDD":
        return now.Format("Monday")
    case "A_DDD":
        return now.Format("Mon")
    case "A_Hour":
        return now.Format("15")
    case "A_Min":
        return now.Format("04")
    case "A_Sec":
        return now.Format("05")
    case "A_Space":
        return " "
    case "A_Tab":
        return "\t"
    default:
        return ""
    }
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
local programStartTime = os.clock()
function BuildInVars(varName)
    if varName == "A_TickCount" then
        return tostring(math.floor((os.clock() - programStartTime) * 1000))
    elseif varName == "A_Now" then
        return os.date("%Y-%m-%d %H:%M:%S")
    elseif varName == "A_YYYY" then
        return os.date("%Y")
    elseif varName == "A_MM" then
        return os.date("%m")
    elseif varName == "A_DD" then
        return os.date("%d")
    elseif varName == "A_MMMM" then
        return os.date("%B")
    elseif varName == "A_MMM" then
        return os.date("%b")
    elseif varName == "A_DDDD" then
        return os.date("%A")
    elseif varName == "A_DDD" then
        return os.date("%a")
    elseif varName == "A_Hour" then
        return os.date("%H")
    elseif varName == "A_Min" then
        return os.date("%M")
    elseif varName == "A_Sec" then
        return os.date("%S")
    elseif varName == "A_Space" then
        return " "
    elseif varName == "A_Tab" then
        return "\t"
    else
        return ""
    end
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: BuildInVars
libs: using System;|using System.Diagnostics;
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
private static readonly Stopwatch stopWatch = Stopwatch.StartNew();
public static string BuildInVars(string varName)
{
    DateTime now = DateTime.Now;
    switch (varName)
    {
        case "A_TickCount": return stopWatch.ElapsedMilliseconds.ToString();
        case "A_Now": return now.ToString("yyyy-MM-dd HH:mm:ss");
        case "A_YYYY": return now.ToString("yyyy");
        case "A_MM": return now.ToString("MM");
        case "A_DD": return now.ToString("dd");
        case "A_MMMM": return now.ToString("MMMM");
        case "A_MMM": return now.ToString("MMM");
        case "A_DDDD": return now.ToString("dddd");
        case "A_DDD": return now.ToString("ddd");
        case "A_Hour": return now.ToString("HH");
        case "A_Min": return now.ToString("mm");
        case "A_Sec": return now.ToString("ss");
        case "A_Space": return " ";
        case "A_Tab": return "\t";
        default: return "";
    }
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: BuildInVars
libs: import java.time.LocalDateTime;|import java.time.format.DateTimeFormatter;|import java.time.temporal.ChronoUnit;
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
private static final LocalDateTime programStartTime = LocalDateTime.now();
public static String BuildInVars(String varName) {
    LocalDateTime now = LocalDateTime.now();
    switch (varName) {
        case "A_TickCount": return Long.toString(ChronoUnit.MILLIS.between(programStartTime, now));
        case "A_Now": return now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        case "A_YYYY": return now.format(DateTimeFormatter.ofPattern("yyyy"));
        case "A_MM": return now.format(DateTimeFormatter.ofPattern("MM"));
        case "A_DD": return now.format(DateTimeFormatter.ofPattern("dd"));
        case "A_MMMM": return now.format(DateTimeFormatter.ofPattern("MMMM"));
        case "A_MMM": return now.format(DateTimeFormatter.ofPattern("MMM"));
        case "A_DDDD": return now.format(DateTimeFormatter.ofPattern("EEEE"));
        case "A_DDD": return now.format(DateTimeFormatter.ofPattern("EEE"));
        case "A_Hour": return now.format(DateTimeFormatter.ofPattern("HH"));
        case "A_Min": return now.format(DateTimeFormatter.ofPattern("mm"));
        case "A_Sec": return now.format(DateTimeFormatter.ofPattern("ss"));
        case "A_Space": return " ";
        case "A_Tab": return "\t";
        default: return "";
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: BuildInVars
libs: import java.time.LocalDateTime|import java.time.format.DateTimeFormatter|import java.time.temporal.ChronoUnit
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
private val programStartTime = LocalDateTime.now()
fun BuildInVars(varName: String): String {
    val now = LocalDateTime.now()
    return when (varName) {
        "A_TickCount" -> ChronoUnit.MILLIS.between(programStartTime, now).toString()
        "A_Now" -> now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
        "A_YYYY" -> now.format(DateTimeFormatter.ofPattern("yyyy"))
        "A_MM" -> now.format(DateTimeFormatter.ofPattern("MM"))
        "A_DD" -> now.format(DateTimeFormatter.ofPattern("dd"))
        "A_MMMM" -> now.format(DateTimeFormatter.ofPattern("MMMM"))
        "A_MMM" -> now.format(DateTimeFormatter.ofPattern("MMM"))
        "A_DDDD" -> now.format(DateTimeFormatter.ofPattern("EEEE"))
        "A_DDD" -> now.format(DateTimeFormatter.ofPattern("EEE"))
        "A_Hour" -> now.format(DateTimeFormatter.ofPattern("HH"))
        "A_Min" -> now.format(DateTimeFormatter.ofPattern("mm"))
        "A_Sec" -> now.format(DateTimeFormatter.ofPattern("ss"))
        "A_Space" -> " "
        "A_Tab" -> "\t"
        else -> ""
    }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
$programStartTime_rb = Process.clock_gettime(Process::CLOCK_MONOTONIC)
def BuildInVars(varName)
    now = Time.now
    case varName
    when "A_TickCount"
        ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - $programStartTime_rb) * 1000).to_i.to_s
    when "A_Now"
        now.strftime("%Y-%m-%d %H:%M:%S")
    when "A_YYYY"
        now.strftime("%Y")
    when "A_MM"
        now.strftime("%m")
    when "A_DD"
        now.strftime("%d")
    when "A_MMMM"
        now.strftime("%B")
    when "A_MMM"
        now.strftime("%b")
    when "A_DDDD"
        now.strftime("%A")
    when "A_DDD"
        now.strftime("%a")
    when "A_Hour"
        now.strftime("%H")
    when "A_Min"
        now.strftime("%M")
    when "A_Sec"
        now.strftime("%S")
    when "A_Space"
        " "
    when "A_Tab"
        "\t"
    else
        ""
    end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: BuildInVars
libs: import times, strutils
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
let programStartTime_nim = epochTime()
proc BuildInVars(varName: string): string =
  let now = now()
  case varName
  of "A_TickCount":
    return $int((epochTime() - programStartTime_nim) * 1000)
  of "A_Now":
    return now.format("yyyy-MM-dd HH:mm:ss")
  of "A_YYYY":
    return now.format("yyyy")
  of "A_MM":
    return now.format("MM")
  of "A_DD":
    return now.format("dd")
  of "A_MMMM":
    return now.format("MMMM")
  of "A_MMM":
    return now.format("MMM")
  of "A_DDDD":
    return now.format("dddd")
  of "A_DDD":
    return now.format("ddd")
  of "A_Hour":
    return now.format("HH")
  of "A_Min":
    return now.format("mm")
  of "A_Sec":
    return now.format("ss")
  of "A_Space":
    return " "
  of "A_Tab":
    return "\t"
  else:
    return ""
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~

BuildInVars(varName) {
    if (varName = "A_Now") {
        FormatTime, TimeString, , yyyy-MM-dd HH:mm:ss
        return TimeString
    } else if (varName = "A_TickCount") {
        return A_TickCount
    } else if (varName = "A_ScreenWidth") {
        return A_ScreenWidth
    } else if (varName = "A_ScreenHeight") {
        return A_ScreenHeight
    } else if (varName = "A_LastKey") {
        return A_LastKey
    } else if (varName = "A_TimeIdle") {
        return A_TimeIdle
    } else if (varName = "A_YYYY") {
        return A_YYYY
    } else if (varName = "A_MM") {
        return A_MM
    } else if (varName = "A_DD") {
        return A_DD
    } else if (varName = "A_MMMM") {
        return A_MMMM
    } else if (varName = "A_MMM") {
        return A_MMM
    } else if (varName = "A_DDDD") {
        return A_DDDD
    } else if (varName = "A_DDD") {
        return A_DDD
    } else if (varName = "A_Hour") {
        return A_Hour
    } else if (varName = "A_Min") {
        return A_Min
    } else if (varName = "A_Sec") {
        return A_Sec
    } else if (varName = "A_Space") {
        return " "
    } else if (varName = "A_Tab") {
        return "\t"  ; Backtick-t is tab in AHK
    } else {
        return ""
    }
}

funcEND======================funcEND==============
func======================func==============
lang: swift
name: BuildInVars
libs: import Foundation
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
private let programStartTime_swift = Date()
func BuildInVars(_ varName: String) -> String {
    let now = Date()
    let formatter = DateFormatter()
    switch varName {
    case "A_TickCount":
        return String(Int(now.timeIntervalSince(programStartTime_swift) * 1000))
    case "A_Now":
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        return formatter.string(from: now)
    case "A_YYYY":
        formatter.dateFormat = "yyyy"
        return formatter.string(from: now)
    case "A_MM":
        formatter.dateFormat = "MM"
        return formatter.string(from: now)
    case "A_DD":
        formatter.dateFormat = "dd"
        return formatter.string(from: now)
    case "A_MMMM":
        formatter.dateFormat = "MMMM"
        return formatter.string(from: now)
    case "A_MMM":
        formatter.dateFormat = "MMM"
        return formatter.string(from: now)
    case "A_DDDD":
        formatter.dateFormat = "EEEE"
        return formatter.string(from: now)
    case "A_DDD":
        formatter.dateFormat = "E"
        return formatter.string(from: now)
    case "A_Hour":
        formatter.dateFormat = "HH"
        return formatter.string(from: now)
    case "A_Min":
        formatter.dateFormat = "mm"
        return formatter.string(from: now)
    case "A_Sec":
        formatter.dateFormat = "ss"
        return formatter.string(from: now)
    case "A_Space":
        return " "
    case "A_Tab":
        return "\t"
    default:
        return ""
    }
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
final _stopwatch = Stopwatch()..start();
String _formatTwoDigits(int n) => n.toString().padLeft(2, '0');
String BuildInVars(String varName) {
  final now = DateTime.now();
  final fullMonthNames = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  final shortMonthNames = ["", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  final fullDayNames = ["", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  final shortDayNames = ["", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];

  switch (varName) {
    case 'A_TickCount': return _stopwatch.elapsedMilliseconds.toString();
    case 'A_Now': return '${now.year}-${_formatTwoDigits(now.month)}-${_formatTwoDigits(now.day)} ${_formatTwoDigits(now.hour)}:${_formatTwoDigits(now.minute)}:${_formatTwoDigits(now.second)}';
    case 'A_YYYY': return now.year.toString();
    case 'A_MM': return _formatTwoDigits(now.month);
    case 'A_DD': return _formatTwoDigits(now.day);
    case 'A_MMMM': return fullMonthNames[now.month];
    case 'A_MMM': return shortMonthNames[now.month];
    case 'A_DDDD': return fullDayNames[now.weekday];
    case 'A_DDD': return shortDayNames[now.weekday];
    case 'A_Hour': return _formatTwoDigits(now.hour);
    case 'A_Min': return _formatTwoDigits(now.minute);
    case 'A_Sec': return _formatTwoDigits(now.second);
    case 'A_Space': return ' ';
    case 'A_Tab': return '\t';
    default: return '';
  }
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: BuildInVars
libs: null
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
const programStartTime_ts = performance.now();
function BuildInVars(varName: string): string {
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    switch (varName) {
        case "A_TickCount": return Math.floor(performance.now() - programStartTime_ts).toString();
        case "A_Now": return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
        case "A_YYYY": return now.getFullYear().toString();
        case "A_MM": return pad(now.getMonth() + 1);
        case "A_DD": return pad(now.getDate());
        case "A_MMMM": return now.toLocaleString('en-US', { month: 'long' });
        case "A_MMM": return now.toLocaleString('en-US', { month: 'short' });
        case "A_DDDD": return now.toLocaleString('en-US', { weekday: 'long' });
        case "A_DDD": return now.toLocaleString('en-US', { weekday: 'short' });
        case "A_Hour": return pad(now.getHours());
        case "A_Min": return pad(now.getMinutes());
        case "A_Sec": return pad(now.getSeconds());
        case "A_ScreenWidth": return typeof window !== 'undefined' ? window.screen.width.toString() : "";
        case "A_ScreenHeight": return typeof window !== 'undefined' ? window.screen.height.toString() : "";
        case "A_Space": return " ";
        case "A_Tab": return "\t";
        default: return "";
    }
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: BuildInVars
libs: import java.time.LocalDateTime|import java.time.format.DateTimeFormatter|import java.time.temporal.ChronoUnit
description: system~~~Retrieves various system-related, time-related, or environment-specific built-in variable values. The `varName` argument specifies which variable to get (e.g., "A_YYYY" for year, "A_ScreenWidth" for screen width, "A_TickCount" for milliseconds since program start). Availability of specific variables can depend on the target language and environment (e.g., screen dimensions are browser-specific).~~~Here is how to use it:~~~```htvm~~~; ==== Built-in Variables for BuildInVars() ====~~~; A_ScreenWidth  - Width of the window screen (browser only)~~~; A_ScreenHeight - Height of the window screen (browser only)~~~; A_LastKey      - Last key pressed by the user (browser only)~~~; A_TimeIdle     - Time the user has been idle (in ms or seconds)~~~; A_TickCount    - Current tick count (ms since the start)~~~; A_Now          - Local datetime string (full, locale-based)~~~; A_YYYY         - 4-digit current year~~~; A_MM           - 2-digit current month (0112)~~~; A_DD           - 2-digit current day of month (0131)~~~; A_MMMM         - Full month name (e.g. January)~~~; A_MMM          - Abbreviated month name (e.g. Jan)~~~; A_DDDD         - Full day name (e.g. Monday)~~~; A_DDD          - Abbreviated day name (e.g. Mon)~~~; A_Hour         - Current hour (0023)~~~; A_Min          - Current minute (0059)~~~; A_Sec          - Current second (0059)~~~; A_Space        - Space character (" ")~~~; A_Tab          - Tab character ("\t")~~~; ==========================================================~~~; Some behavior may vary depending on the target language!!!~~~; Make sure to test your code thoroughly!!!~~~; ==========================================================~~~; Examples:~~~str currentYear := BuildInVars("A_YYYY")~~~print("Current Year (A_YYYY): " . currentYear)~~~; ----------------------------------------------------~~~str currentMonth := BuildInVars("A_MMMM")~~~print("Current Month (A_MMMM): " . currentMonth)~~~if (StrLen(currentMonth) < 3) {~~~    print("BuildInVars A_MMMM test FAILED! Month name too short.")~~~}~~~; ----------------------------------------------------~~~str tabChar := BuildInVars("A_Tab")~~~print("Space char (A_Tab): '" . tabChar . "'")~~~; ----------------------------------------------------~~~; Browser-specific example (will return empty or error in non-browser environments)~~~str screenWidth := BuildInVars("A_ScreenWidth")~~~print("Screen Width (A_ScreenWidth): " . screenWidth)~~~if (HTVM_getLang_HTVM() = "js" and screenWidth = "") {~~~    print("BuildInVars A_ScreenWidth test needs a browser!")~~~}~~~; ----------------------------------------------------~~~str tickCount1 := BuildInVars("A_TickCount")~~~print("TickCount 1: " . STR(tickCount1))~~~await Sleep(100)~~~str tickCount2 := BuildInVars("A_TickCount")~~~print("TickCount 2 (after 100ms sleep): " . STR(tickCount2))~~~; This will never be perfectly 100 because:~~~; 1. Awaiting Sleep(100) requests a **minimum** delay of 100ms, not an exact one.~~~; 2. The actual sleep time depends on the timing resolution of the environment or runtime (e.g. JavaScript timers, OS scheduler).~~~; 3. Some overhead is added due to:~~~;    - Executing BuildInVars("A_TickCount") before and after.~~~;    - Interpreter/runtime processing.~~~;    - Internal event loop mechanics if async is involved.~~~; 4. On some systems or browsers, sleep may overshoot significantly (e.g. 101130ms).~~~if (INT(tickCount2) <= INT(tickCount1)) {~~~    print("BuildInVars A_TickCount test FAILED! Ticks did not increase.")~~~}~~~```~~~
// Groovy is on the JVM, so we can use a similar static approach as Java.
class GroovyBuiltIns {
    static final LocalDateTime programStartTime = LocalDateTime.now()
}
String BuildInVars(String varName) {
    def now = LocalDateTime.now()
    switch (varName) {
        case "A_TickCount": return ChronoUnit.MILLIS.between(GroovyBuiltIns.programStartTime, now).toString()
        case "A_Now": return now.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
        case "A_YYYY": return now.format(DateTimeFormatter.ofPattern("yyyy"))
        case "A_MM": return now.format(DateTimeFormatter.ofPattern("MM"))
        case "A_DD": return now.format(DateTimeFormatter.ofPattern("dd"))
        case "A_MMMM": return now.format(DateTimeFormatter.ofPattern("MMMM"))
        case "A_MMM": return now.format(DateTimeFormatter.ofPattern("MMM"))
        case "A_DDDD": return now.format(DateTimeFormatter.ofPattern("EEEE"))
        case "A_DDD": return now.format(DateTimeFormatter.ofPattern("EEE"))
        case "A_Hour": return now.format(DateTimeFormatter.ofPattern("HH"))
        case "A_Min": return now.format(DateTimeFormatter.ofPattern("mm"))
        case "A_Sec": return now.format(DateTimeFormatter.ofPattern("ss"))
        case "A_Space": return " "
        case "A_Tab": return "\t"
        default: return ""
    }
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
func HTVM_getLang_HTVM() string {
    return "go"
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
function HTVM_getLang_HTVM()
    return "lua"
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
public static string HTVM_getLang_HTVM() {
    return "cs";
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
public static String HTVM_getLang_HTVM() {
    return "java";
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
fun HTVM_getLang_HTVM(): String {
    return "kt"
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
def HTVM_getLang_HTVM()
  "rb"
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
proc HTVM_getLang_HTVM(): string =
  return "nim"
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
HTVM_getLang_HTVM() {
    return "ahk"
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
func HTVM_getLang_HTVM() -> String {
    return "swift"
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
String HTVM_getLang_HTVM() {
  return "dart";
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
function HTVM_getLang_HTVM(): string {
    return "ts";
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: HTVM_getLang_HTVM
libs: null
description: system~~~Returns a string indicating the current target language HTVM is configured to transpile to or is running in. For example, it might return "cpp", "py", "js", etc. Useful for writing conditional HTVM code based on the target environment.~~~Here is how to use it:~~~```htvm~~~str currentLang := HTVM_getLang_HTVM()~~~print("Current HTVM target language is: " . currentLang)~~~if (currentLang = "js") {~~~    print("This code is specific to JavaScript.")~~~} else if (currentLang = "py") {~~~    print("This part runs if the target is Python.")~~~} else if (currentLang = "cpp") {~~~    print("C++ specific logic here.")~~~} else {~~~    print("Running in or targeting another language: " . currentLang)~~~}~~~; Test: The function should return a non-empty string.~~~if (StrLen(currentLang) = 0) {~~~    print("HTVM_getLang_HTVM test FAILED! Returned empty string.")~~~} else {~~~    print("HTVM_getLang_HTVM test PASSED (returned a non-empty string).")~~~}~~~```~~~
String HTVM_getLang_HTVM() {
    return "groovy"
}
funcEND======================funcEND==============







func======================func==============
lang: go
name: Sleep
libs: )|"time"
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
func Sleep(milliseconds int) {
	time.Sleep(time.Duration(milliseconds) * time.Millisecond)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
-- Pure Lua busy-wait Sleep (no external libs)
function Sleep(milliseconds)
    local start = os.clock()
    local seconds = milliseconds / 1000
    while (os.clock() - start) < seconds do end
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: Sleep
libs: using System.Threading;
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
public static void Sleep(int milliseconds) {
    Thread.Sleep(milliseconds);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
public static void Sleep(int milliseconds) {
    try {
        Thread.sleep(milliseconds);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
fun Sleep(milliseconds: Int) {
    try {
        Thread.sleep(milliseconds.toLong())
    } catch (e: InterruptedException) {
        Thread.currentThread().interrupt()
    }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
def Sleep(milliseconds)
  sleep(milliseconds / 1000.0)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: Sleep
libs: import os
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
proc Sleep(milliseconds: int) =
  sleep(milliseconds)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
AHK_Sleep_AHK(sleepNumInMs) {
    Sleep, % sleepNumInMs
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: Sleep
libs: import Foundation
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
func Sleep(_ milliseconds: Int) {
    Thread.sleep(forTimeInterval: Double(milliseconds) / 1000.0)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: Sleep
libs: import 'dart:io';
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
void Sleep(int milliseconds) {
  sleep(Duration(milliseconds: milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
function Sleep(milliseconds: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: Sleep
libs: null
description: system~~~Pauses the execution of the program for a specified number of `milliseconds` (integer).~~~Here is how to use it:~~~```htvm~~~print("Starting sleep test...")~~~str startTime := BuildInVars("A_TickCount")~~~print("Start TickCount: " . STR(startTime))~~~; Sleep for 1 second (1000 milliseconds)~~~int duration := 1000~~~await Sleep(duration)~~~str endTime := BuildInVars("A_TickCount")~~~print("End TickCount: " . STR(endTime))~~~int elapsed := INT(endTime) - INT(startTime)~~~print("Elapsed time: " . STR(elapsed) . " ms")~~~; Test if elapsed time is approximately the sleep duration~~~; Allow for some overhead (e.g., +/- 200ms for system timing inaccuracies)~~~if (elapsed >= (duration - 200) and elapsed <= (duration + 2000)) {~~~    print("Sleep test PASSED! (Elapsed time is close to " . STR(duration) . "ms)")~~~} else {~~~    print("Sleep test FAILED! Elapsed: " . STR(elapsed) . "ms, Expected around: " . STR(duration) . "ms")~~~}~~~; ----------------------------------------------------~~~print("--- Another sleep for 500ms ---")~~~await Sleep(500)~~~print("Woke up after 500ms.")~~~```~~~
void Sleep(int milliseconds) {
    try {
        Thread.sleep(milliseconds)
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt()
    }
}
funcEND======================funcEND==============




func======================func==============
lang: go
name: ExitApp
libs: )|"os"
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
func ExitApp() {
	os.Exit(0)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: ExitApp
libs: local os = require("os")
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
function ExitApp()
    os.exit(0)
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: ExitApp
libs: using System;
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
public static void ExitApp() {
    Environment.Exit(0);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
public static void ExitApp() {
    System.exit(0);
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: ExitApp
libs: import kotlin.system.exitProcess
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
fun ExitApp() {
    exitProcess(0)
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
def ExitApp()
  exit(0)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
proc ExitApp() =
  quit(0)
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
ExitApp() {
    ExitApp
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: ExitApp
libs: import Foundation
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
func ExitApp() {
    exit(0)
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: ExitApp
libs: import 'dart:io';
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
void ExitApp() {
  exit(0);
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
// This function is only effective in a Node.js environment.
function ExitApp(): void {
    if (typeof process !== 'undefined' && process.exit) {
        process.exit(0);
    }
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: ExitApp
libs: null
description: system~~~Terminates the current program immediately. Any code following `ExitApp()` will not be executed. This function is not available in all target environments (e.g., standard web JavaScript).~~~Here is how to use it:~~~```htvm~~~print("Program is starting...")~~~; Set to true to test, false to continue~~~bool shouldExit := true~~~if (shouldExit = true) {~~~    print("Preparing to exit...")~~~    ; Note: The following line will only execute if ExitApp is NOT called or is unavailable.~~~    ; In a successful ExitApp call, "This line should not print..." will not appear.~~~    if (HTVM_getLang_HTVM() = "js") {~~~        ; ExitApp not typically available in a browser~~~        print("ExitApp is not available in this JavaScript environment. Skipping exit.")~~~    } else {~~~        print("Calling ExitApp()...")~~~        ExitApp()~~~        ; Test assertion~~~        print("This line SHOULD NOT PRINT if ExitApp worked!")~~~    }~~~}~~~print("Program continued (only if ExitApp was not called or not available).")~~~```~~~
void ExitApp() {
    System.exit(0)
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: isWindows
libs: )|"runtime"
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
func isWindows() bool {
    return runtime.GOOS == "windows"
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
function isWindows()
    return package.config:sub(1,1) == '\\'
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: isWindows
libs: using System.Runtime.InteropServices;
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
public static bool isWindows() {
    return RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
public static boolean isWindows() {
    return System.getProperty("os.name").toLowerCase().startsWith("windows");
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
fun isWindows(): Boolean {
    return System.getProperty("os.name").toLowerCase().startsWith("windows")
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
def isWindows
  /mingw|mswin|cygwin/.match?(RUBY_PLATFORM)
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
proc isWindows(): bool =
  const result = defined(windows)
  return result
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
isWindows() {
    ; AutoHotKey Must run only on Windows as its made only for Windows
    return true
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
#if os(Windows)
func isWindows() -> Bool {
    return true
}
#else
func isWindows() -> Bool {
    return false
}
#endif
funcEND======================funcEND==============
func======================func==============
lang: dart
name: isWindows
libs: import 'dart:io';
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
bool isWindows() {
  return Platform.isWindows;
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOnWindows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
function isWindows(): boolean {
    // This check is for Node.js environment. It will be false in browsers.
    if (typeof process !== 'undefined' && process.platform) {
        return process.platform === 'win32';
    }
    return false;
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: isWindows
libs: null
description: system~~~Checks if the current operating system is Windows. Returns `true` if the OS is identified as Windows, `false` otherwise. Not reliably available or meaningful in browser JavaScript environments (where it would typically always be false or unavailable).~~~Here is how to use it:~~~```htvm~~~bool runningOnWindows := isWindows()~~~if (runningOnWindows = true) {~~~    print("This script is running on a Windows system.")~~~} else {~~~    print("This script is NOT running on a Windows system (or function not fully supported in this env).")~~~}~~~; Test: The function should return a boolean.~~~if (runningOn-Windows = true or runningOnWindows = false) {~~~    print("isWindows test PASSED (returned a boolean). Current value: " . STR(runningOnWindows))~~~} else {~~~    print("isWindows test FAILED! Did not return a boolean.")~~~}~~~```~~~
boolean isWindows() {
    return System.getProperty("os.name").toLowerCase().startsWith("windows")
}
funcEND======================funcEND==============






func======================func==============
lang: go
name: input
libs: )|"bufio"|"fmt"|"os"|"strings"
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
func input(prompt string) string {
    fmt.Print(prompt)
    reader := bufio.NewReader(os.Stdin)
    text, _ := reader.ReadString('\n')
    return strings.TrimSpace(text)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
function input(prompt)
    io.write(prompt)
    return io.read()
end
funcEND======================funcEND==============
func======================func==============
lang: cs
name: input
libs: using System;
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
public static string input(string prompt) {
    Console.Write(prompt);
    return Console.ReadLine();
}
funcEND======================funcEND==============
func======================func==============
lang: java
name: input
libs: import java.util.Scanner;
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
private static final Scanner scanner = new Scanner(System.in);
public static String input(String prompt) {
    System.out.print(prompt);
    return scanner.nextLine();
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
fun input(prompt: String): String {
    print(prompt)
    return readLine() ?: ""
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
def input(prompt)
  print prompt
  $stdout.flush
  gets.chomp
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
proc input(prompt: string): string =
  stdout.write prompt
  stdout.flushFile()
  return stdin.readLine()
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
input(prompt) {
    InputBox, UserInput, Input, %prompt%
    return UserInput
}
funcEND======================funcEND==============
func======================func==============
lang: swift
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
func input(_ prompt: String) -> String {
    print(prompt, terminator: "")
    return readLine() ?? ""
}
funcEND======================funcEND==============
func======================func==============
lang: dart
name: input
libs: import 'dart:io';
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
String input(String prompt) {
  stdout.write(prompt);
  return stdin.readLineSync() ?? "";
}
funcEND======================funcEND==============
func======================func==============
lang: ts
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
// In a browser environment, this is the standard synchronous way.
// For Node.js, a library like 'readline-sync' would be needed for a true sync equivalent.
function input(promptText: string): string {
    return window.prompt(promptText) || "";
}
funcEND======================funcEND==============
func======================func==============
lang: groovy
name: input
libs: null
description: io~~~Prompts the user with `promptText` (string) and waits for them to enter text, then returns the entered text as a string. In graphical environments, this might open a dialog box. In console environments, it reads from standard input.~~~Here is how to use it:~~~```htvm~~~print("Starting input test...")~~~str namePrompt := "Please enter your name: "~~~str userName := input(namePrompt)~~~if (userName != "") {~~~    print("Hello, " . userName . "! You entered: '" . userName . "'")~~~    ; Simple check~~~    if (userName = "TestUser") { ~~~        print("Input test with 'TestUser' PASSED.")~~~    } else {~~~        print("Input received. For a full test, try entering 'TestUser'.")~~~    }~~~} else {~~~    print("No input received or input was empty.")~~~    ; Specifically empty~~~    if (userName = "") { ~~~        print("Input test (empty input) PASSED observation.")~~~    } else {~~~        print("Input test (empty input) FAILED observation, unexpected value for empty input.")~~~    }~~~}~~~; ----------------------------------------------------~~~str agePrompt := "Enter your age: "~~~str ageStr := input(agePrompt)~~~if (ageStr != "") {~~~    ; Assuming INT() can handle conversion~~~    int ageNum := INT(ageStr)~~~    print("You entered age: " . STR(ageNum))~~~    if (ageNum > 0) {~~~        print("Age input seems valid.")~~~    }~~~} else {~~~    print("No age input received.")~~~}~~~```~~~
String input(String prompt) {
    print prompt
    return System.in.newReader().readLine()
}
funcEND======================funcEND==============








func======================func==============
lang: go
name: getDataFromAPI
libs: )|"net/http"|"io"
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
func getDataFromAPI(url string) string {
	resp, err := http.Get(url)
	if err != nil {
		return ""
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return ""
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return ""
	}
	return string(body)
}
funcEND======================funcEND==============
func======================func==============
lang: lua
name: getDataFromAPI
libs: null
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
-- Assumes 'curl' is installed on the system.
function getDataFromAPI(url)
    local command = "curl -s -L \"" .. url .. "\""
    local handle = io.popen(command)
    if not handle then return "" end
    local result = handle:read("*a")
    handle:close()
    return result
end
funcEND======================funcEND==============

func======================func==============
lang: java
name: getDataFromAPI
libs: import java.net.HttpURLConnection;|import java.net.URL;|import java.util.Scanner;|import java.net.URI;|import java.net.URL;
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
public static String getDataFromAPI(String urlString) {
    try {
        URI uri = new URI(urlString);
        URL url = uri.toURL();
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("GET");
        conn.connect();
        if (conn.getResponseCode() != 200) {
            return "";
        }
        Scanner scanner = new Scanner(url.openStream());
        String response = scanner.useDelimiter("\\A").next();
        scanner.close();
        return response;
    } catch (Exception e) {
        return "";
    }
}
funcEND======================funcEND==============
func======================func==============
lang: kt
name: getDataFromAPI
libs: import java.net.URL
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
fun getDataFromAPI(url: String): String {
    return try {
        URL(url).readText()
    } catch (e: Exception) {
        ""
    }
}
funcEND======================funcEND==============
func======================func==============
lang: rb
name: getDataFromAPI
libs: null
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
def getDataFromAPI(url)
  begin
    uri = URI.parse(url)
    response = Net::HTTP.get_response(uri)
    return response.is_a?(Net::HTTPSuccess) ? response.body : ""
  rescue
    return ""
  end
end
funcEND======================funcEND==============
func======================func==============
lang: nim
name: getDataFromAPI
libs: import httpclient
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
proc getDataFromAPI(url: string): string =
  try:
    let client = newHttpClient()
    let response = client.get(url)
    if response.status == "200 OK":
      return response.body
    else:
      return ""
  except:
    return ""
funcEND======================funcEND==============
func======================func==============
lang: ahk
name: getDataFromAPI
libs: null
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
getDataFromAPI(url) {
    whr := ComObjCreate("WinHttp.WinHttpRequest.5.1")
    whr.Open("GET", url, false)
    whr.Send()
    if (whr.Status = 200)
        return whr.ResponseText
    return ""
}
funcEND======================funcEND==============

func======================func==============
lang: groovy
name: getDataFromAPI
libs: null
description: io~~~Asynchronously fetches data from a given `url` (string). It's typically used for making HTTP GET requests to APIs that return JSON data. The function returns the fetched data (often parsed JSON, or raw text if JSON parsing fails/is not applicable). Handles basic errors and non-OK HTTP responses.~~~Here is how to use it:~~~```htvm~~~; This function is asynchronous.~~~async func void performApiCall() {~~~    ; Public test API~~~    str apiUrl := "https://jsonplaceholder.typicode.com/todos/1"~~~    print("Fetching data from: " . apiUrl)~~~    ; In HTVM, if the function is async (like getDataFromAPI often is for JS/Python),~~~    ; you might need an 'await' keyword if HTVM supports it directly for this function,~~~    ; or handle it via callbacks/promises depending on the target language details.~~~    ; For this example, we'll assume direct await is possible or handled by HTVM.~~~    str responseData := await getDataFromAPI(apiUrl)~~~    if (responseData != "") {~~~        print("API Response Data (raw):")~~~        print(responseData)~~~    }~~~}~~~main~~~await performApiCall()~~~```~~~
String getDataFromAPI(String url) {
    try {
        return new URL(url).getText("UTF-8")
    } catch (Exception e) {
        return ""
    }
}
funcEND======================funcEND==============