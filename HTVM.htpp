; Wellcome the new revolution

; keyWordsCommands rules
; OUTVAR = the output variable
; INVAR = the input variable, like the one before the =
; INOUTVAR = both the output variable and the input variable
; lineTranspile = the first keyword will be replaced with the third section
; 'param123... = a parameter with ""
; param123... = a regular parameter, nothing much, just add as many as needed


func str KeyWordsCommands(str theCodeCommands, str mode, str keyWordsCommands, str langToTranspileTo)
{
theCodeCommands := StrReplace(theCodeCommands, "%", "")
if (mode = "check")
{
Loop, Parse, keyWordsCommands, "|"
{
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{

if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
return "true"
}
}

if (A_Index = 1)
{
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
return "true"
}
}


}

}
;MsgBox, false
return "false"
}

int AIndex
if (mode = "transpile")
{

int keyWordsCommandsNumLine := 1
Loop, Parse, keyWordsCommands, "|"
{
AIndex := A_Index
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{
if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}

if (A_Index = 1)
{
;MsgBox, %theCodeCommands% = %A_LoopField%
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}


}

}





str outConstuctTheOutFromTheCommands := ""
str outConstuctTheOutFromTheCommandsFucnName := ""
str outConstuctTheOutFromTheCommandsParams := ""
str outConstuctTheOutFromTheCommandsOutVar := ""
str outConstuctTheOutFromTheCommandsInVar := ""
int theCodeCommandNum := 1
int outConstuctTheOutFromTheCommandsLineTranspile := 0
str outConstuctTheOutFromTheCommandsLineTranspileText := ""

str semicolon := ""
if (langToTranspileTo != "py")
{
semicolon := ";"
}

arr str theCodeCommand
theCodeCommands := Trim(theCodeCommands)
Loop, Parse, theCodeCommands, `,
{
arr theCodeCommand .= Trim(A_LoopField)
;MsgBox, % A_LoopField
}


Loop, Parse, keyWordsCommands, "|"
{



if (keyWordsCommandsNumLine = A_Index)
{

;MsgBox, % A_LoopField

Loop, Parse, A_LoopField, `,
{




if (A_Index = 1)
{
outConstuctTheOutFromTheCommandsFucnName := A_LoopField
}
else if (A_Index = 2)
{

;MsgBox, % A_LoopField
if (A_LoopField = "lineTranspile")
{
outConstuctTheOutFromTheCommandsLineTranspile := 1
}

if (A_LoopField = "OUTVAR")
{
outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INOUTVAR")
{

outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}

}



}
else if (A_Index = 3)
{

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommandsLineTranspileText := A_LoopField
}


if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}

}
else
{

;MsgBox, % theCodeCommand[theCodeCommandNum]
if (InStr(A_LoopField, Chr(39)))
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}

}
else
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}
}
theCodeCommandNum++
}
break
}

}

StringTrimRight, outConstuctTheOutFromTheCommandsParams, outConstuctTheOutFromTheCommandsParams, 2

if (outConstuctTheOutFromTheCommandsOutVar != "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}

}

if (outConstuctTheOutFromTheCommandsOutVar = "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}
}

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsLineTranspileText
}


outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(, ", "( ")
outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(,", "(")
return outConstuctTheOutFromTheCommands





}

return "false"
}



func str ExtractDigits(str inputString)
{
str digits

Loop, Parse, inputString
{
    if (RegExMatch(A_LoopField, "\\d"))
    {
        digits .= A_LoopField
    }
}
return digits
}

func str convertJs_cpp_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

func str convertJs_py_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for " . indexName . " in range(" . indexEqual . ", " . indexMax . "):"
return out
}

func str convertPy_cpp_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax

if (InStr(theCode, ","))
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := Trim(StrReplace(StrReplace(StrReplace(A_LoopField, ";", ""), "range(", ""), ",", ""))
}
if (A_Index = 5)
{
indexMax := Trim(StrReplace(StrReplace(StrReplace(A_LoopField, ";", ""), ")", ""), ",", ""))
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}
else
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := "0"
indexMax := ExtractDigits(StrReplace(A_LoopField, ";", ""))
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

}

func str convertPy_js_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax

if (InStr(theCode, ","))
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := Trim(StrReplace(StrReplace(StrReplace(A_LoopField, ";", ""), "range(", ""), ",", ""))
}
if (A_Index = 5)
{
indexMax := Trim(StrReplace(StrReplace(StrReplace(A_LoopField, ";", ""), ")", ""), ",", ""))
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (let " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}
else
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := "0"
indexMax := ExtractDigits(StrReplace(A_LoopField, ";", ""))
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (let " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

}

func str convertCpp_js_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (let " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

func str convertCpp_py_Normal(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for " . indexName . " in range(" . indexEqual . ", " . indexMax . "):"
return out
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

str keyWordComment

func str convertJs_cpp_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}

indexMax := StrSplit(indexMax, ".", 1) . ".size()"

indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

func str convertJs_py_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrSplit(StrReplace(A_LoopField, ";", ""), ".", 1)
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for " . indexName . " in range(" . indexEqual . ", len(" . indexMax . ")):"
return out
}


func str convertPy_cpp_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax

if (InStr(theCode, ","))
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := ExtractDigits(StrReplace(A_LoopField, ";", ""))
}
if (A_Index = 5)
{
indexMax := StrSplit(StrSplit(StrReplace(A_LoopField, ";", ""), "len(", 2), ")", 1) . ".size()"
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}
else
{

Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := A_LoopField
}
if (A_Index = 4)
{
indexEqual := "0"
indexMax := StrSplit(StrSplit(StrReplace(A_LoopField, ";", ""), "len(", 2), ")", 1) . ".size()"
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (int " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

}

func str convertPy_js_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax

if (InStr(theCode, ","))
{
Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := ExtractDigits(StrReplace(A_LoopField, ";", ""))
}
if (A_Index = 5)
{
indexMax := StrSplit(StrSplit(StrReplace(A_LoopField, ";", ""), "len(", 2), ")", 1) . ".length"
}
}

out := "for (let " . StrReplace(indexName, ":", "") . " = " . StrReplace(indexEqual, ":", "") . "; " . StrReplace(indexName, ":", "") . " < " . StrReplace(indexMax, ":", "") . "; " . StrReplace(indexName, ":", "") . "++)"
return out
}
else
{

Loop, Parse, theCode, " "
{
if (A_Index = 2)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 4)
{
indexEqual := "0"
indexMax := StrSplit(StrSplit(StrReplace(A_LoopField, ";", ""), "len(", 2), ")", 1) . ".length"
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for (let " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}

}

func str convertCpp_js_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrReplace(A_LoopField, ";", "")
}
}

indexMax := StrSplit(indexMax, ".", 1) . ".length"

indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")

out := "for (let " . indexName . " = " . indexEqual . "; " . indexName . " < " . indexMax . "; " . indexName . "++)"
return out
}


func str convertCpp_py_Array(str theCode)
{
str out

str indexName
str indexEqual
str indexMax
Loop, Parse, theCode, " "
{
if (A_Index = 3)
{
indexName := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 5)
{
indexEqual := StrReplace(A_LoopField, ";", "")
}
if (A_Index = 8)
{
indexMax := StrSplit(StrReplace(A_LoopField, ";", ""), ".", 1)
}
}
indexName := StrReplace(indexName, ":", "")
indexEqual := StrReplace(indexEqual, ":", "")
indexMax := StrReplace(indexMax, ":", "")
out := "for " . indexName . " in range(" . indexEqual . ", len(" . indexMax . ")):"
return out
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str transpileForLoop(str langToConvertTo, str langForLoopStyleOfUser, str TheCode)
{
str out
bool isNormalLoop

; Check if source and target languages are the same
if (langForLoopStyleOfUser = langToConvertTo)
{
;theColon
if (langForLoopStyleOfUser = "py")
{
if (!(InStr(TheCode, ":")))
{
TheCode := TheCode . ":"
return TheCode
}
}
else
{
if (InStr(TheCode, ":"))
{
TheCode := StrReplace(TheCode, ":", "")
return TheCode
}
}
return TheCode
}

if (Trim(TheCode) = "for (;;)")
{
if (langToConvertTo != "py")
{
return "for (;;)"
}
else
{
return "while Ture:"
}
}

if (langForLoopStyleOfUser = "py")
{
if (InStr(TheCode, "len("))
{
isNormalLoop := false
}
else
{
isNormalLoop := true
}
}
else
{
if (InStr(TheCode, "."))
{
isNormalLoop := false
}
else
{
isNormalLoop := true
}
}

if (isNormalLoop)
{
if (langForLoopStyleOfUser = "py") && (langToConvertTo = "cpp")
{
out := convertPy_cpp_Normal(TheCode)
}
if (langForLoopStyleOfUser = "py") && (langToConvertTo = "js")
{
out := convertPy_js_Normal(TheCode)
}
if (langForLoopStyleOfUser = "js") && (langToConvertTo = "cpp")
{
out := convertJs_cpp_Normal(TheCode)
}
if (langForLoopStyleOfUser = "js") && (langToConvertTo = "py")
{
out := convertJs_py_Normal(TheCode)
}
if (langForLoopStyleOfUser = "cpp") && (langToConvertTo = "py")
{
out := convertCpp_py_Normal(TheCode)
}
if (langForLoopStyleOfUser = "cpp") && (langToConvertTo = "js")
{
out := convertCpp_js_Normal(TheCode)
}
}
else
{
if (langForLoopStyleOfUser = "py") && (langToConvertTo = "cpp")
{
out := convertPy_cpp_Array(TheCode)
}
if (langForLoopStyleOfUser = "py") && (langToConvertTo = "js")
{
out := convertPy_js_Array(TheCode)
}
if (langForLoopStyleOfUser = "js") && (langToConvertTo = "cpp")
{
out := convertJs_cpp_Array(TheCode)
}
if (langForLoopStyleOfUser = "js") && (langToConvertTo = "py")
{
out := convertJs_py_Array(TheCode)
}
if (langForLoopStyleOfUser = "cpp") && (langToConvertTo = "py")
{
out := convertCpp_py_Array(TheCode)
}
if (langForLoopStyleOfUser = "cpp") && (langToConvertTo = "js")
{
out := convertCpp_js_Array(TheCode)
}
}


return out
}



; Helper function to create spaces
func str spaces(int n)
{
str s := ""
if (n != 0)
{
Loop, % n
{
s .= " "
}
}
return s
}


; Define the function to check odd spaces at the beginning
func str CheckOddLeadingSpaces(str string123)
{
; Initialize a variable to count the spaces
int spaceCount := 0

; Loop through the string one character at a time
Loop, Parse, string123
{
; Check if the current character is a space
if (A_LoopField = Chr(32))
{
spaceCount++
}
else
{
; When we hit a non-space character, break the loop
break
}
}

; Return true if the number of spaces is odd, false otherwise
str sdsfawasd := STR(Mod(spaceCount, 2) = 1)
;MsgBox, % sdsfawasd
return sdsfawasd
}

func str LTrim(str input)
{
    str result := ""
    bool foundNonSpace := false

    Loop, Parse, input
    {
        if (A_LoopField != " " || foundNonSpace)
        {
            result .= A_LoopField
            foundNonSpace := true
        }
    }

    return result
}


func str getLastChar(str strippedString)
{
str lastChar
Loop, Parse, strippedString
{
lastChar := A_LoopField
}
return lastChar
}

func str AddCurlyBraces(str pythonCode)
{
pythonCode := StrReplace(pythonCode, A_Tab, "    ")
str result := ""
int indentLevel := 0
int indent
str line
str stripped
Loop, Parse, pythonCode, `n, `r
{
line := A_LoopField
stripped := Trim(line)
if (stripped == "")
{
result .= line . "`n"
continue
}

; Count leading spaces
indent := StrLen(line) - StrLen(LTrim(line))
;MsgBox, % indent
; Close braces for unindents

loop
{
if (indentLevel <= indent)
{
	break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


; Add opening brace for new blocks
if (getLastChar(stripped) = ":") && (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordComment))) != StrLower(keyWordComment))
{
result .= SubStr(line, 1, -1) . " {`n"
indentLevel += 4
}
else
{
result .= line . "`n"
}
}

; Close any remaining open braces
Loop
{
if (indentLevel <= 0)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


return result
}


func str RepeatSpaces(int count)
{
str spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}


func str indent_nested_curly_braces(str input_string, int modeCurlyBracesOn)
{
int indent_size := 4
int current_indent := 0
str result
str trimmed_line
str resultOut
;MsgBox, % input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}
else
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}

}


if (modeCurlyBracesOn = 0)
{
str resultOut
Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) != "{") && (Trim(A_LoopField) != "}")
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}
else
{
; format curly braces in a K&R style

arr str lookIntoFurture

Loop, Parse, result, `n, `r
{
arr lookIntoFurture .= Trim(A_LoopField)
}
arr lookIntoFurture .= " "

str resultOut
int skipNext := 0
Loop, Parse, result, `n, `r
{


skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(lookIntoFurture[A_Index + 1]) = "{")
{
resultOut .= A_LoopField . " {`n"
skipNext := 2
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}


}
StringTrimRight, result, resultOut, 1

arr str lookIntoFurture2

Loop, Parse, result, `n, `r
{
arr lookIntoFurture2 .= Trim(A_LoopField)
}
arr lookIntoFurture2 .= " "


resultOut := ""
skipNext := 0
str addSpacesAtTheBegginig
Loop, Parse, result, `n, `r
{
skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(A_LoopField) = "}") && (Trim(lookIntoFurture2[A_Index + 1]) = "else {")
{
skipNext := 2
addSpacesAtTheBegginig := ""
Loop, Parse, A_LoopField
{
if (A_LoopField = " ")
{
if (A_LoopField != " ")
{
break
}
addSpacesAtTheBegginig .= A_LoopField
}
}
resultOut .= addSpacesAtTheBegginig . "} else {`n"
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}


resultOut := ""
str ALoopField
Loop, Parse, result, `n, `r
{
if (CheckOddLeadingSpaces(A_LoopField) = "1")
{
StringTrimLeft, ALoopField, A_LoopField, 1
resultOut .= ALoopField . "`n"
}
else
{
resultOut .= A_LoopField . "`n"
}
}

StringTrimRight, result, resultOut, 1


; Return the result
return result
}





str keyWordsCommands
str fileExtention
str code
str keyWordINT
str keyWordSTR
str keyWordFLOAT
str instructions
str filePathOfCode
str langToTranspileTo
str out_KeyWordsCommands
str outTrimCode
str htCode
str str1
str str2
str str3
str str4
str str5
str str6
str str7
str str8
str str9
str str10
str outVarOperator
int lineDone
int areWeInAFuncFromInstructions
int areWeInAFuncFromInstructionsLineNum
str keyWordIF
str keyWordElseIf
str keyWordWhileLoop
str keyWordForLoop
str keyWordElse
str keyWordBOOL
str keyWordINT8
str keyWordINT16
str keyWordINT32
str keyWordINT64
str keyWordLoop
str keyWordLoopInfinite
str keyWordLoopParse
str keyWordBreak
str keyWordContinue
str keyWordFunc
str keyWordAwait
str keyWordConcatenationAssignmentOperator
str keyWordVariablesAssignmentOperator
str keyWordAdditionAssignmentOperator
str keyWordSubtractionAssignmentOperator
str keyWordMultiplicationAssignmentOperator
str keyWordDivisionAssignmentOperator
str keyWordAdditionOperator
str keyWordConcatenationOperator
str keyWordEqualOperator
str keyWordNotOperator
str keyWordGreaterThanOperator
str keyWordLessThanOperator
str keyWordGreaterThanOrEqualToOperator
str keyWordLessThanOrEqualToOperator
str keyWordOrOperator
str keyWordAndOperator
str keyWordNotEqualToOperator
str keyWordTrue
str keyWordFalse
str keyWordSwitch
str keyWordSwitchCase
str keyWordSwitchDefault
str keyWordThrow
str keyWordErrorMsg
str keyWordTry
str keyWordCatch
str keyWordFinally
str keyWordArrayAppend
str keyWordArrayPop
str keyWordArraySize
str keyWordArrayInsert
str keyWordArrayRemove
str keyWordArrayIndexOf
str keyWordArrayDefinition
str keyWordArrayOfIntegersDefinition
str keyWordArrayOfStringsDefinition
str keyWordArrayOfFloatingPointNumbersDefinition
str keyWordArrayOfBooleansDefinition
str keyWordJavaScriptVar
str keyWordJavaScriptLet
str keyWordJavaScriptConst
str keyWordReturnStatement
str keyWordEnd
str keyWordGlobal
;str keyWordComment defined at line 489
str keyWordCommentOpenMultiLine
str keyWordCommentCloseMultiLine
str keyWordEscpaeChar
str AHKlikeLoopsIndexedAt
str keyWordAIndex
str keyWordALoopField
str keyWordMainLabel

str useFuncKeyWord
str useCurlyBraces
str useEnd
str useSemicolon
str useParentheses
str usePythonicColonSyntax
str useTypes
str forLoopLang
str useJavaScriptInAfullHTMLfile
str useInJavaScriptAlwaysUseVar
str useJavaScriptAmainFuncDef

str theSemicolon
str theColon

str theCppVarForErrors := "jhku-dfsds-ds-d-ffdsf-sdfsfdsedsf"
str theJSvarDeclaredVarsBugFix := "|"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



func str isItAPlusPlusOrMinusMinus(str str111, int mode)
{
; 2 modes
; 0 mode = detect only

; mode 1
; ++
; ++;
; --
; --;
str out
str str1
str str2

str str11
str str12
str str13


int numCountFix

if (mode = 0)
{
Loop, Parse, str111
{
numCountFix++
}

Loop, Parse, str111
{
if (A_Index = numCountFix - 2)
{
str11 := A_LoopField
}
if (A_Index = numCountFix - 1)
{
str12 := A_LoopField
}
if (A_Index = numCountFix)
{
str13 := A_LoopField
}
}


if (str11 = "+") && (str12 = "+") && (str13 = ";")
{
return "detected"
}
if (str11 = "-") && (str12 = "-") && (str13 = ";")
{
return "detected"
}
if (str12 = "+") && (str13 = "+")
{
return "detected"
}
if (str12 = "-") && (str13 = "-")
{
return "detected"
}

return "no"
}


if (mode = 1)
{
Loop, Parse, str111
{
numCountFix++
}

Loop, Parse, str111
{
if (A_Index = numCountFix - 2)
{
str11 := A_LoopField
}
if (A_Index = numCountFix - 1)
{
str12 := A_LoopField
}
if (A_Index = numCountFix)
{
str13 := A_LoopField
}
}


if (str11 = "+") && (str12 = "+") && (str13 = ";")
{
StringTrimRight, str111, str111, 3
if (langToTranspileTo = "py")
{
str2 := str111 . " = " . Trim(str111) . " + 1"
}
else
{
str2 := str111 . "++;"
}
}
if (str11 = "-") && (str12 = "-") && (str13 = ";")
{
StringTrimRight, str111, str111, 3
if (langToTranspileTo = "py")
{
str2 := str111 . " = " . Trim(str111) . " - 1"
}
else
{
str2 := str111 . "--;"
}
}
if (str12 = "+") && (str13 = "+")
{
StringTrimRight, str111, str111, 2
if (langToTranspileTo = "py")
{
str2 := str111 . " = " . Trim(str111) . " + 1"
}
else
{
str2 := str111 . "++;"
}
}
if (str12 = "-") && (str13 = "-")
{
StringTrimRight, str111, str111, 2
if (langToTranspileTo = "py")
{
str2 := str111 . " = " . Trim(str111) . " - 1"
}
else
{
str2 := str111 . "--;"
}
}

out := str2

return out
}

return str111
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
func str fixFuncParamsHandleSpacesHELPER(int theINDEX, str str2FIXhelper)
{
if (theINDEX = 1)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordArrayDefinition) . "\\b", "std::vector<std::string>")
}
if (theINDEX = 2)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordArrayOfIntegersDefinition) . "\\b", "std::vector<int>")
}
if (theINDEX = 3)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordArrayOfStringsDefinition) . "\\b", "std::vector<std::string>")
}
if (theINDEX = 4)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordArrayOfFloatingPointNumbersDefinition) . "\\b", "std::vector<float>")
}
if (theINDEX = 5)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordArrayOfBooleansDefinition) . "\\b", "std::vector<bool>")
}
if (theINDEX = 6)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordINT) . "\\b", "int")
}
if (theINDEX = 7)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordSTR) . "\\b", "std::string")
}
if (theINDEX = 8)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordBOOL) . "\\b", "bool")
}
if (theINDEX = 9)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordINT8) . "\\b", "int8_t")
}
if (theINDEX = 10)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordINT16) . "\\b", "int8_t")
}
if (theINDEX = 11)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordINT32) . "\\b", "int32_t")
}
if (theINDEX = 12)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordINT64) . "\\b", "long long")
}
if (theINDEX = 13)
{
str2FIXhelper := RegExReplace(str2FIXhelper, "\\b" . Trim(keyWordFLOAT) . "\\b", "float")
}
return str2FIXhelper
}


func int getNumOfSpacesHelperFunc(str theTEXTtoGetTheSpaceCount)
{

int NUMofSpaces := 0

Loop, Parse, theTEXTtoGetTheSpaceCount
{
if (A_LoopField = " ")
{
NUMofSpaces++
}
}

return NUMofSpaces
}

func str fixFuncParamsHandleSpaces(str str2FIX)
{
arr int holdDoneIdexes

arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0
arr holdDoneIdexes .= 0

arr str holdAllKeyWords

arr holdAllKeyWords .= keyWordArrayDefinition
arr holdAllKeyWords .= keyWordArrayOfIntegersDefinition
arr holdAllKeyWords .= keyWordArrayOfStringsDefinition
arr holdAllKeyWords .= keyWordArrayOfFloatingPointNumbersDefinition
arr holdAllKeyWords .= keyWordArrayOfBooleansDefinition
arr holdAllKeyWords .= keyWordINT
arr holdAllKeyWords .= keyWordSTR
arr holdAllKeyWords .= keyWordBOOL
arr holdAllKeyWords .= keyWordINT8
arr holdAllKeyWords .= keyWordINT16
arr holdAllKeyWords .= keyWordINT32
arr holdAllKeyWords .= keyWordINT64
arr holdAllKeyWords .= keyWordFLOAT

int tempSIZEholder
int indexHolder
Loop, INT(holdAllKeyWords[0])
{
tempSIZEholder := 0
Loop, INT(holdAllKeyWords[0])
{



if (holdDoneIdexes[A_Index] = 0) && (getNumOfSpacesHelperFunc(holdAllKeyWords[A_Index]) >= tempSIZEholder)
{
tempSIZEholder := getNumOfSpacesHelperFunc(holdAllKeyWords[A_Index])
indexHolder := A_Index
}


}
holdDoneIdexes[indexHolder] := indexHolder
str2FIX := fixFuncParamsHandleSpacesHELPER(indexHolder, str2FIX)
}




return str2FIX
}




; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]
str OSPstrArrayStrALLobjInOSP := ""
str HoldOSPdethodNamePath := ""

func str findTypeOfOSPprop(str fullARRAYstr, str FromPath)
{
str outType := ""
; if the fullARRAYstr is in this format
; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]

str outFormat := ""
str outFormatHELP1 := ""
str outFormatHELP2 := ""


Loop, Parse, fullARRAYstr, "|"
{
if (Trim(A_LoopField) != "")
{
outFormatHELP1 := StrSplit(A_LoopField, ":", 1)
outFormatHELP2 := StrSplit(A_LoopField, ":", 2)
Loop, Parse, outFormatHELP2, `,
{
outFormat .= outFormatHELP1 . "." . A_LoopField . "|"
}
}
}
StringTrimRight, outFormat, outFormat, 1


Loop, Parse, outFormat, "|"
{
if (Trim(A_LoopField) != "")
{
if (StrSplit(Trim(A_LoopField), "[", 1) = Trim(FromPath))
{
outType := StrSplit(Trim(A_LoopField), "[", 2)
StringTrimRight, outType, outType, 1
break
}

}
}




if (outType = "vector<int>")
{
outType := "std::vector<int>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<float>")
{
outType := "std::vector<float>&"
}
else if (outType = "vector<bool>")
{
outType := "std::vector<bool>&"
}
else if (outType = Trim(keyWordINT))
{
outType := "int"
}
else if (outType = Trim(keyWordSTR))
{
outType := "std::string"
}
else if (outType = Trim(keyWordFLOAT))
{
outType := "float"
}
else if (outType = Trim(keyWordBOOL))
{
outType := "bool"
}
else if (outType = Trim(keyWordINT8))
{
outType := "int8_t"
}
else if (outType = Trim(keyWordINT16))
{
outType := "int16_t"
}
else if (outType = Trim(keyWordINT32))
{
outType := "int32_t"
}
else if (outType = Trim(keyWordINT64))
{
outType := "int64_t"
}


return outType
}


func str REMOVELastSTRfromDOT(str THESTR)
{
str THESTRout := ""
if (Trim(THESTR) = "")
{
return ""
}
int count12345 0

Loop, Parse, THESTR, "."
{
count12345++
}


Loop, Parse, THESTR, "."
{
if (count12345 = A_Index)
{
break
}
else
{
THESTRout .= Trim(A_LoopField) . "."
}
}

StringTrimRight, THESTRout, THESTRout, 1

return THESTRout
}


;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsPY_JS(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\\bthis\\b", "this__OSP__this[0]")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsLEFT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\\bthis\\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}

func str replaceTheOSPpathsRIGHT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
type := findTypeOfOSPprop(OSPstrArrayStrALLobjInOSP, ALoopField)
;MsgBox, % type

theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "std::any_cast<" . type . ">(OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_") . ")")

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\\bthis\\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


func str CheckStringPosition(str text, str target, str reference)
{

    str posReference := SubStr(text, 1, StrLen(reference))
    str posTarget := SubStr(text, 1, StrLen(target))

    ; Check if both strings are found (not using InStr)
    if (posReference != "" && posTarget != "")
    {
        ; Manually find the positions of the target and reference
        posTarget := RegExMatch(text, target)
        posReference := RegExMatch(text, reference)

        ; Compare positions of target and reference
        if (posTarget < posReference)
        {

            return "left"
        }
        else if (posTarget > posReference)
        {

return "not left"
        }
        else
        {

return "uuh"
        }
    }
    else
    {

        return "One or both strings not found."
    }

return "huh"
}


func str getIndexOfTheStrArrayStrOST(str ALoopField, str theSringOSPlineARRAYstrstrSTR)
{



Loop, Parse, theSringOSPlineARRAYstrstrSTR, "|"
{
if (Trim(StrSplit(A_LoopField, ":", 1)) = Trim(ALoopField))
{

return STR(A_Index)
}
}



return "0"
}



func str parserOSPgloabl(str theSringOSPline, str str123)
{
str str_1 := ""
str str_2 := ""
str str_3 := ""
str str_4 := ""
str str_5 := ""
str str_6 := ""

str HELPHoldOSPdethodNamePath := ""

StringTrimRight, HELPHoldOSPdethodNamePath, HoldOSPdethodNamePath, 1




Loop, Parse, theSringOSPline, "|"
{
str_1 .= Trim(StrSplit(A_LoopField, ":", 1)) . "`n"
str_5 := Trim(StrSplit(A_LoopField, ":", 1))
str_6 := Trim(StrSplit(A_LoopField, ":", 2))
Loop, Parse, str_6, `,
{
str_1 .= str_5 . "." . Trim(StrSplit(A_LoopField, "[", 1)) . "[" . STR(A_Index) . "]`n"
}

}

str_1 .= StrReplace(HELPHoldOSPdethodNamePath, "|", "`n")



str shortestLine
str currentLine
int currentLength
int minLength
str tempStr

; Sorting by repeatedly finding and appending the shortest line
Loop
{
    ; Initialize variables to track the shortest line in this pass
    shortestLine := ""
    minLength := 999999

    ; Find the shortest line in str_1
    Loop, Parse, str_1, `n, `r
    {
        currentLine := A_LoopField
        currentLength := StrLen(currentLine)
        if (currentLength < minLength)
        {
            minLength := currentLength
            shortestLine := currentLine
        }
    }

    ; If no shortest line is found, break (str_1 is empty)
    if (shortestLine = "")
	{
        break
	}

    ; Add the shortest line to the sorted result
    str_2 .= shortestLine . "`n"

    ; Rebuild str_1 without the shortest line
    tempStr := ""
    Loop, Parse, str_1, `n, `r
    {
        if (A_LoopField != shortestLine)
		{
            tempStr .= A_LoopField . "`n"
		}

    }
    StringTrimRight, tempStr, tempStr, 1
    str_1 := tempStr
}

; Trim the final trailing newline from str_2
StringTrimRight, str_2, str_2, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Initialize an empty result for the reversed lines
str reversedStr := ""

; Count the number of lines
int lineCount := 0
int index
int lineNum

Loop, Parse, str_2, `n, `r
{
    lineCount++
}

; Reverse the order by re-parsing and appending lines in reverse order
Loop, % lineCount
{
    ; Inner loop to find the (lineCount - A_Index + 1)-th line
    index := lineCount - A_Index + 1
    currentLine := ""
    lineNum := 0

    Loop, Parse, str_2, `n, `r
    {
        lineNum++
        if (lineNum = index)
        {
            currentLine := A_LoopField
            break
        }
    }

    ; Append the line in reverse order
    reversedStr .= currentLine . "`n"
}

; Trim the final trailing newline
StringTrimRight, str_2, reversedStr, 1


; Display the sorted result
;MsgBox, % str_2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;CheckStringPosition(text, target, reference)
str ALoopField := ""
str ALoopField1 := ""

Loop, Parse, str_2, `n, `r
{

if (langToTranspileTo = "cpp")
{

if (Trim(A_LoopField) != "")
{


if (InStr(str123, " += "))
{
str6 := " += "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " = "))
{

str6 := " = "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " -= "))
{
str6 := " -= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " *= "))
{
str6 := " *= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " /= "))
{

str6 := " /= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else
{

str123 := replaceTheOSPpathsRIGHT(str123, A_LoopField)

}


;;;;;
}
}
else
{
if (Trim(A_LoopField) != "")
{
str123 := replaceTheOSPpathsPY_JS(str123, A_LoopField)
}
}



}



return str123
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str expressionParserTranspiler(str expression)
{

if (forLoopLang = "cpp")
{
expression := RegExReplace(expression, "\\b" . Trim(keyWordINT) . "\\b", "int")
}

expression := StrReplace(expression, " " . keyWordAdditionOperator . " ", " + ")
expression := StrReplace(expression, " " . keyWordConcatenationOperator . " ", " + ")
expression := StrReplace(expression, " " . keyWordEqualOperator . " ", " == ")


if (langToTranspileTo = "py")
{
expression := RegExReplace(expression, keyWordNotOperator . "([\\w]+)", "not $1")
}

if (langToTranspileTo = "py")
{
expression := StrReplace(expression, keyWordNotOperator, "not")
}
else
{
expression := StrReplace(expression, keyWordNotOperator, "!")
}
expression := StrReplace(expression, " " . keyWordGreaterThanOperator . " ", " > ")
expression := StrReplace(expression, " " . keyWordLessThanOperator . " ", " < ")
expression := StrReplace(expression, " " . keyWordGreaterThanOrEqualToOperator . " ", " >= ")
expression := StrReplace(expression, " " . keyWordLessThanOrEqualToOperator . " ", " <= ")
if (langToTranspileTo = "py")
{
expression := StrReplace(expression, " " . keyWordOrOperator . " ", " or ")
}
else
{
expression := StrReplace(expression, " " . keyWordOrOperator . " ", " || ")
}
if (langToTranspileTo = "py")
{
expression := StrReplace(expression, " " . keyWordAndOperator . " ", " and ")
}
else
{
expression := StrReplace(expression, " " . keyWordAndOperator . " ", " && ")
}
expression := StrReplace(expression, " " . keyWordNotEqualToOperator . " ", " != ")
expression := StrReplace(expression, " not= ", " != ")


if (langToTranspileTo = "py")
{
; Python-specific replacements
expression := RegExReplace(expression, "\\b" . keyWordTrue . "\\b", "True")
expression := RegExReplace(expression, "\\b" . keyWordFalse . "\\b", "False")
expression := RegExReplace(expression, "\\bnull\\b", "None")
expression := StrReplace(expression, "{}", "[]")

expression := RegExReplace(expression, "\\b" . keyWordErrorMsg . "\\b", "Exception")
expression := StrReplace(expression, keyWordArrayAppend, ".append")
expression := StrReplace(expression, keyWordArrayPop, ".pop")

expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayInsert . "\\(([^,]+), ([^)]+)\\)", "$1.insert($2, $3)")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayRemove . "\\(([^)]+)\\)", "$1.remove($2)")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayIndexOf . "\\(([^)]+)\\)", "$1.index($2) if $2 in $1 else -1")



expression := StrReplace(expression, ") and (", " and ")
expression := StrReplace(expression, ") or (", " or ")


if (InStr(expression, keyWordArraySize))
{

str pattern1 := "(\\w{1,1})\\" . keyWordArraySize
str pattern2 := "(\\w+)\\" . keyWordArraySize

int result2 := RegExMatch(expression, pattern1)
int result1 := RegExMatch(expression, pattern2)

str concatResults
Loop, Parse, expression
{
if (A_Index >= result1) && (A_Index <= result2)
{
concatResults .= A_LoopField
}
}
expression := StrReplace(expression, concatResults . ".", ".")
expression := StrReplace(expression, keyWordArraySize, "len(" . concatResults . ")")
expression := StrReplace(expression, ")()", ")")
}


}
else if (langToTranspileTo = "js")
{
; JavaScript-specific replacements
expression := RegExReplace(expression, "\\b" . keyWordTrue . "\\b", "true")
expression := RegExReplace(expression, "\\b" . keyWordFalse . "\\b", "false")
expression := RegExReplace(expression, "\\bNone\\b", "null")
expression := StrReplace(expression, "{}", "[]")

expression := RegExReplace(expression, "\\b" . keyWordErrorMsg . "\\b", "new Error")
expression := StrReplace(expression, keyWordArrayAppend, ".push")
expression := StrReplace(expression, keyWordArrayPop, ".pop")
expression := StrReplace(expression, keyWordArraySize, ".length")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayInsert . "\\(([^,]+), ([^)]+)\\)", "$1.splice($2, 0, $3)")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayRemove . "\\(([^)]+)\\)", "$1.splice($1.indexOf($2), 1)")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayIndexOf . "\\(([^)]+)\\)", "$1.includes($2) ? $1.indexOf($2) : -1")



expression := StrReplace(expression, ") && (", " && ")
expression := StrReplace(expression, ") || (", " || ")

}
else if (langToTranspileTo = "cpp")
{
; C++-specific replacements
expression := RegExReplace(expression, "\\b" . theCppVarForErrors . "\\b", theCppVarForErrors . ".what()")
expression := RegExReplace(expression, "\\b" . keyWordTrue . "\\b", "true")
expression := RegExReplace(expression, "\\b" . keyWordFalse . "\\b", "false")
expression := RegExReplace(expression, "\\bnull\\b", Chr(34) . Chr(34))
expression := RegExReplace(expression, "\\bNone\\b", Chr(34) . Chr(34))
expression := StrReplace(expression, "[]", "{}")

expression := RegExReplace(expression, "\\b" . keyWordErrorMsg . "\\b", "std::runtime_error")
expression := StrReplace(expression, keyWordArrayAppend, ".push_back")
expression := StrReplace(expression, keyWordArrayPop, ".pop_back")
expression := StrReplace(expression, keyWordArraySize, ".size")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayInsert . "\\(([^,]+), ([^)]+)\\)", "$1.insert($1.begin() + $2, $3)")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayRemove . "\\(([^)]+)\\)", "$1.erase(std::remove($1.begin(), $1.end(), $2), $1.end())")
expression := RegExReplace(expression, "(\\w+)\\" . keyWordArrayIndexOf . "\\(([^)]+)\\)", "std::find($1.begin(), $1.end(), $2) != $1.end() ? std::find($1.begin(), $1.end(), $2) - $1.begin() : -1")


expression := StrReplace(expression, ") && (", " && ")
expression := StrReplace(expression, ") || (", " || ")

}

expression := StrReplace(expression, ".length()", ".length")

expression := StrReplace(expression, . " " . Trim(keyWordVariablesAssignmentOperator) . " ", " = ")


return expression
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


func void compiler()
{
str params := GetParams()
if (params = "")
{
MsgBox, % str10 . "Usage: HTVM <yourCodeFileName.yourExtension> <HT-instructions.txt> [optional LangToTranspileTo]`n`nOptions:`n  <yourCodeFileName.yourExtension>  The source code file to transpile.`n  <HT-instructions.txt>              The instructions file for transpilation.`n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js).`n`nExample:`n  HTVM main.ht HT-instructions.txt cpp`n"
ExitApp
}

int linesFixBugBUGbugBUG := 0
Loop, Parse, params, `n, `r
{
linesFixBugBUGbugBUG++
}

if (linesFixBugBUGbugBUG < 2)
{
MsgBox, You need at leats 2 params
MsgBox, % str10 . "Usage: HTVM <yourCodeFileName.yourExtension> <HT-instructions.txt> [optional LangToTranspileTo]`n`nOptions:`n  <yourCodeFileName.yourExtension>  The source code file to transpile.`n  <HT-instructions.txt>              The instructions file for transpilation.`n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js).`n`nExample:`n  HTVM main.ht HT-instructions.txt cpp`n"
ExitApp
}

int optionalLangToTranspileTo := 0
Loop, Parse, params, `n, `r
{
if (A_Index = 1)
{
MsgBox, % A_LoopField
filePathOfCode := Trim(A_LoopField)
;MsgBox, % filePathOfCode
;code := FileRead(filePathOfCode)
FileRead, code, %filePathOfCode%
;MsgBox, % code
}
if (A_Index = 2)
{
MsgBox, % A_LoopField

FileRead, instructions, %A_LoopField%
}
if (A_Index = 3)
{
optionalLangToTranspileTo := 1
langToTranspileTo := Trim(A_LoopField)
}
}
;MsgBox, % code

Loop, Parse, instructions, `n, `r
{
if (A_Index = 1)
{
if (optionalLangToTranspileTo = 0)
{
langToTranspileTo := Trim(A_LoopField)
}
}
if (A_Index = 2)
{
fileExtention := Trim(A_LoopField)
}
if (A_Index = 3)
{
keyWordsCommands := Trim(A_LoopField)
}

if (A_Index = 4)
{
keyWordINT := Trim(A_LoopField) . " "
}
if (A_Index = 5)
{
keyWordSTR := Trim(A_LoopField) . " "
}
if (A_Index = 6)
{
keyWordBOOL := Trim(A_LoopField) . " "
}
if (A_Index = 7)
{
keyWordFLOAT := Trim(A_LoopField) . " "
}
if (A_Index = 8)
{
keyWordINT8 := Trim(A_LoopField) . " "
}
if (A_Index = 9)
{
keyWordINT16 := Trim(A_LoopField) . " "
}
if (A_Index = 10)
{
keyWordINT32 := Trim(A_LoopField) . " "
}
if (A_Index = 11)
{
keyWordINT64 := Trim(A_LoopField) . " "
}
if (A_Index = 12)
{
keyWordIF := Trim(A_LoopField) . " "
}
if (A_Index = 13)
{
keyWordElseIf := Trim(A_LoopField) . " "
}
if (A_Index = 14)
{
keyWordElse := Trim(A_LoopField)
}
if (A_Index = 15)
{
keyWordWhileLoop := Trim(A_LoopField) . " "
}
if (A_Index = 16)
{
keyWordForLoop := Trim(A_LoopField) . " "
}
if (A_Index = 17)
{
keyWordLoopInfinite := Trim(A_LoopField)
}
if (A_Index = 18)
{
keyWordLoop := Trim(A_LoopField) . " "
}
if (A_Index = 19)
{
keyWordLoopParse := Trim(A_LoopField) . " "
}
if (A_Index = 20)
{
keyWordContinue := Trim(A_LoopField)
}
if (A_Index = 21)
{
keyWordBreak := Trim(A_LoopField)
}
if (A_Index = 22)
{
keyWordFunc := Trim(A_LoopField) . " "
}
if (A_Index = 23)
{
keyWordAwait := Trim(A_LoopField) . " "
}
if (A_Index = 24)
{
keyWordVariablesAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 25)
{
keyWordConcatenationAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 26)
{
keyWordAdditionAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 27)
{
keyWordSubtractionAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 28)
{
keyWordMultiplicationAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 29)
{
keyWordDivisionAssignmentOperator := Trim(A_LoopField)
}
if (A_Index = 30)
{
keyWordAdditionOperator := Trim(A_LoopField)
}
if (A_Index = 31)
{
keyWordConcatenationOperator := Trim(A_LoopField)
}
if (A_Index = 32)
{
keyWordEqualOperator := Trim(A_LoopField)
}
if (A_Index = 33)
{
keyWordNotOperator := Trim(A_LoopField)
}
if (A_Index = 34)
{
keyWordGreaterThanOperator := Trim(A_LoopField)
}
if (A_Index = 35)
{
keyWordLessThanOperator := Trim(A_LoopField)
}
if (A_Index = 36)
{
keyWordGreaterThanOrEqualToOperator := Trim(A_LoopField)
}
if (A_Index = 37)
{
keyWordLessThanOrEqualToOperator := Trim(A_LoopField)
}
if (A_Index = 38)
{
keyWordOrOperator := Trim(A_LoopField)
}
if (A_Index = 39)
{
keyWordAndOperator := Trim(A_LoopField)
}
if (A_Index = 40)
{
keyWordNotEqualToOperator := Trim(A_LoopField)
}
if (A_Index = 41)
{
keyWordTrue := Trim(A_LoopField)
}
if (A_Index = 42)
{
keyWordFalse := Trim(A_LoopField)
}
if (A_Index = 43)
{
keyWordSwitch := Trim(A_LoopField) . " "
}
if (A_Index = 44)
{
keyWordSwitchCase := Trim(A_LoopField) . " "
}
if (A_Index = 45)
{
keyWordSwitchDefault := Trim(A_LoopField)
}
if (A_Index = 46)
{
keyWordThrow := Trim(A_LoopField) . " "
}
if (A_Index = 47)
{
keyWordErrorMsg := Trim(A_LoopField)
}
if (A_Index = 48)
{
keyWordTry := Trim(A_LoopField)
}
if (A_Index = 49)
{
keyWordCatch := Trim(A_LoopField) . " "
}
if (A_Index = 50)
{
keyWordFinally := Trim(A_LoopField)
}
if (A_Index = 51)
{
keyWordArrayAppend := Trim(A_LoopField)
}
if (A_Index = 52)
{
keyWordArrayPop := Trim(A_LoopField)
}
if (A_Index = 53)
{
keyWordArraySize := Trim(A_LoopField)
}
if (A_Index = 54)
{
keyWordArrayInsert := Trim(A_LoopField)
}
if (A_Index = 55)
{
keyWordArrayRemove := Trim(A_LoopField)
}
if (A_Index = 56)
{
keyWordArrayIndexOf := Trim(A_LoopField)
}
if (A_Index = 57)
{
keyWordArrayDefinition := Trim(A_LoopField) . " "
}
if (A_Index = 58)
{
keyWordArrayOfIntegersDefinition := Trim(A_LoopField) . " "
}
if (A_Index = 59)
{
keyWordArrayOfStringsDefinition := Trim(A_LoopField) . " "
}
if (A_Index = 60)
{
keyWordArrayOfFloatingPointNumbersDefinition := Trim(A_LoopField) . " "
}
if (A_Index = 61)
{
keyWordArrayOfBooleansDefinition := Trim(A_LoopField) . " "
}
if (A_Index = 62)
{
keyWordJavaScriptVar := Trim(A_LoopField) . " "
}
if (A_Index = 63)
{
keyWordJavaScriptLet := Trim(A_LoopField) . " "
}
if (A_Index = 64)
{
keyWordJavaScriptConst := Trim(A_LoopField) . " "
}
if (A_Index = 65)
{
keyWordReturnStatement := Trim(A_LoopField) . " "
}
if (A_Index = 66)
{
keyWordEnd := Trim(A_LoopField)
}
if (A_Index = 67)
{
keyWordGlobal := Trim(A_LoopField) . " "
}
if (A_Index = 68)
{
keyWordComment := Trim(A_LoopField)
}
if (A_Index = 69)
{
keyWordCommentOpenMultiLine := Trim(A_LoopField)
}
if (A_Index = 70)
{
keyWordCommentCloseMultiLine := Trim(A_LoopField)
}
if (A_Index = 71)
{
keyWordEscpaeChar := Trim(A_LoopField)
}
if (A_Index = 72)
{
AHKlikeLoopsIndexedAt := Trim(A_LoopField)
}
if (A_Index = 73)
{
keyWordAIndex := Trim(A_LoopField)
}
if (A_Index = 74)
{
keyWordALoopField := Trim(A_LoopField)
}
if (A_Index = 75)
{
keyWordMainLabel := Trim(A_LoopField)
}
if (A_Index = 76)
{
useFuncKeyWord := Trim(A_LoopField)
}
if (A_Index = 77)
{
useCurlyBraces := Trim(A_LoopField)
}
if (A_Index = 78)
{
useEnd := Trim(A_LoopField)
}
if (A_Index = 79)
{
useSemicolon := Trim(A_LoopField)
}
if (A_Index = 80)
{
useParentheses := Trim(A_LoopField)
}
if (A_Index = 81)
{
usePythonicColonSyntax := Trim(A_LoopField)
}
if (A_Index = 82)
{
forLoopLang := Trim(A_LoopField)
}
if (A_Index = 83)
{
useInJavaScriptAlwaysUseVar := Trim(A_LoopField)
}
if (A_Index = 84)
{
useJavaScriptInAfullHTMLfile := Trim(A_LoopField)
}
if (A_Index = 85)
{
useJavaScriptAmainFuncDef := Trim(A_LoopField)
}

}






str htCodeOUT754754 := ""
int areWEinSome34sNum := 0
int theIdNumOfThe34 := 0



arr str theIdNumOfThe34theVar


arr str getAllCharForTheFurtureSoIcanAddEscapeChar

int removeNexFixkeyWordEscpaeChar := 0
Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
arr getAllCharForTheFurtureSoIcanAddEscapeChar .= A_LoopField
}
arr str getAllCharForTheFurtureSoIcanAddEscapeChar .= " "

str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuusgfgesrheidFor-asas-theuhtuwaesphoutr" . Chr(34)
str OutFixDoubleQuotesInsideDoubleQuotes

int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) && (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}

StringTrimRight, code, OutFixDoubleQuotesInsideDoubleQuotes, 1
if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}


if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
;MsgBox, % A_LoopField . " = " . keyWordEscpaeChar . ") && (" . keyWordEscpaeChar . " = " . getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] . ")"
if (A_LoopField = keyWordEscpaeChar) && (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}



code := StrReplace(code, Chr(13), "")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (langToTranspileTo != "py") && (useSemicolon = "off")
{
theSemicolon := ";"
}
else
{
theSemicolon := ""
}


if (langToTranspileTo != "py") && (usePythonicColonSyntax = "off")
{
theColon := ""
}
else
{
theColon := ":"
}




str beforeKeywordForRemoveCommentsOnTheEndOfTheLine
str newStringOutCode
int posForRemoveCommentsOnTheEndOfTheLine
str originalStringForRemoveCommentsOnTheEndOfTheLine
Loop, Parse, code, `n, `r
{

; Define the original string
originalStringForRemoveCommentsOnTheEndOfTheLine := A_LoopField

; Find the position of the keyword in the original string
posForRemoveCommentsOnTheEndOfTheLine := InStr(originalStringForRemoveCommentsOnTheEndOfTheLine, " " . keyWordComment)

if (!(SubStr(Trim(A_LoopField), 1, StrLen(keyWordComment)) = keyWordComment))
{
if (posForRemoveCommentsOnTheEndOfTheLine > 0)
{

; Extract the part of the string before the keyword
if (!(SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop)))
{
beforeKeywordForRemoveCommentsOnTheEndOfTheLine := SubStr(originalStringForRemoveCommentsOnTheEndOfTheLine, 1, posForRemoveCommentsOnTheEndOfTheLine - 1)
}
else
{
beforeKeywordForRemoveCommentsOnTheEndOfTheLine := A_LoopField
}

; Construct the new string with everything before the keyword
newStringOutCode .= beforeKeywordForRemoveCommentsOnTheEndOfTheLine . "`n"
}
else
{
newStringOutCode .= A_LoopField . "`n"
}
}
else
{
newStringOutCode .= A_LoopField . "`n"
}

}

StringTrimRight, code, newStringOutCode, 1
;MsgBox, % code


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

str htCodeOutFixEnd
if (useEnd = "on")
{
Loop, Parse, code, `n, `r
{
if (StrLower(Trim(A_LoopField)) = StrLower(keyWordEnd))
{
htCodeOutFixEnd .= str10 . "}" . "`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopInfinite))) = StrLower(keyWordLoopInfinite))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchDefault))) = StrLower(keyWordSwitchDefault))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordTry))) = StrLower(keyWordTry))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("alliance"))) = StrLower("alliance"))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("crew"))) = StrLower("crew"))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("def obj"))) = StrLower("def obj"))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("method"))) = StrLower("method"))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1
}


if (useEnd = "off") && (useCurlyBraces = "off")
{
htCodeOutFixEnd := ""
Loop, Parse, code, `n, `r
{
if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopInfinite))) = StrLower(keyWordLoopInfinite))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchDefault))) = StrLower(keyWordSwitchDefault))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordTry))) = StrLower(keyWordTry))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("alliance"))) = StrLower("alliance"))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("crew"))) = StrLower("crew"))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("def obj"))) = StrLower("def obj"))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower("method"))) = StrLower("method"))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1

}


if (useCurlyBraces = "off") && (useEnd = "off")
{
code := AddCurlyBraces(code)
}


Loop, Parse, code, `n, `r
{
outTrimCode .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, outTrimCode, 1


; for converting c++ to js and py
code := StrReplace(code, "{}", "[]")

str outCodeFixBraces
Loop, 2
{
outCodeFixBraces := ""
Loop, Parse, code, `n, `r
{
if (InStr(Trim(A_LoopField), "{")) && (Trim(A_LoopField) != "{")
{
outCodeFixBraces .= Trim(StrReplace(Trim(A_LoopField), "{", "")) . "`n{`n"
}
else if (InStr(Trim(A_LoopField), "}")) && (Trim(A_LoopField) != "}")
{
outCodeFixBraces .= "}`n" . Trim(StrReplace(Trim(A_LoopField), "}", "")) . "`n"
}
else
{
outCodeFixBraces .= Trim(A_LoopField) . "`n"
}

}

StringTrimRight, code , outCodeFixBraces , 1
}
;MsgBox, % code

; main loop
; main loop
; main loop
; main loop

int haveWeEverUsedAloop := 0
int lineDone := 0
str var1 := ""
str nothing := ""
int AindexcharLength := 1
str AindexcharLengthStr := ""
str theFixTextLoopNL := ""
int htCodeAcurlyBraceAddSomeVrasFixNL := 0
str htCodeLoopfixa := ""
str htCodeLoopfixa1 := ""
str str123 := ""
str out2 := ""
str myVar := ""
str lineYGI := ""
str line := ""
str line1 := ""
str line2 := ""
str line3 := ""
str itemsOut := ""
str var1out := ""
str theFixTextLoopLP := ""
int htCodeAcurlyBraceAddSomeVrasFixLP := 0
int AIndexLoopCurlyFix := 0
str sstr123 := ""
str fixLoopLokingFor := ""
int fixLoopLokingForfound := 0
str out1 := ""
int wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
int inTarget := 0
int insideBracket := 0
int netsedCurly := 0
int eldLoopNestedBADlol := 0
int readyToEnd := 0
int endBracketDOntPutThere := 0
int dontSaveStr := 0
int weAreDoneHereCurly := 0
int DeleayOneCuzOfLoopParse := 0
int fixLoopLokingForNum := 0
int insdeAnestedLoopBAD := 0
int foundTheTopLoop := 0
str out4758686d86d86d86578991a
str ALoopField := ""
str out1z := ""
int insideBracket1 := 0
int netsedCurly1 := 0
int readyToEnd1 := 0
str strstysrstsytTRIMHELP := ""
str out4758686d86dgt8r754444444 := ""
int hold := 0
str holdText := ""
int ignore := 0
str htCodeOut1234565432 := ""
str out := ""
str s := ""
int skipLeftCuleyForFuncPLS := 0



; main loop
; main loop
; main loop
; main loop
; main loop

int didWeUseMainLabel := 0
str codeOutFixAndAddMainFunc

Loop, Parse, code, `n, `r
{

if (StrLower(A_LoopField) = StrLower(keyWordMainLabel))
{
didWeUseMainLabel := 1
if (langToTranspileTo = "cpp")
{
codeOutFixAndAddMainFunc .= "int main(int argc, char* argv[])`n{`n"
}
if (langToTranspileTo = "js") && (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc .= "async function main()`n{`n"
}

}
else
{
codeOutFixAndAddMainFunc .= A_LoopField . "`n"
}
}

if (didWeUseMainLabel != 1) && (langToTranspileTo = "cpp")
{
codeOutFixAndAddMainFunc := "int main(int argc, char* argv[])`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) && (langToTranspileTo = "js") && (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc := "async function main()`n{`n" . codeOutFixAndAddMainFunc
}


StringTrimRight, code, codeOutFixAndAddMainFunc, 1
; main loop
; main loop

arr str lookIntoTheNextLineForFuncWhitNoKeyWord
Loop, Parse, code, `n, `r
{
arr lookIntoTheNextLineForFuncWhitNoKeyWord .= A_LoopField
}
arr lookIntoTheNextLineForFuncWhitNoKeyWord .= " "

; main loop
; main loop
; main loop



Loop, Parse, code, `n, `r
{
lineDone := 0


if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower("prop "))) = StrLower("prop "))
{


if (InStr(A_LoopField, " " . Trim(keyWordConcatenationAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordConcatenationAssignmentOperator) . " ", " += ")) . "`n"
}
else if (InStr(A_LoopField, " " . Trim(keyWordVariablesAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordVariablesAssignmentOperator) . " ", " = ")) . "`n"
}
else if (InStr(A_LoopField, " " . Trim(keyWordAdditionAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordAdditionAssignmentOperator) . " ", " += ")) . "`n"
}
else if (InStr(A_LoopField, " " . Trim(keyWordSubtractionAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordSubtractionAssignmentOperator) . " ", " -= ")) . "`n"
}
else if (InStr(A_LoopField, " " . Trim(keyWordMultiplicationAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordMultiplicationAssignmentOperator) . " ", " *= ")) . "`n"
}
else if (InStr(A_LoopField, " " . Trim(keyWordDivisionAssignmentOperator) . " "))
{
htCode .= expressionParserTranspiler(StrReplace(A_LoopField, " " . Trim(keyWordDivisionAssignmentOperator) . " ", " /= ")) . "`n"
}
else
{
htCode .= expressionParserTranspiler(A_LoopField) . "`n"
}


lineDone := 1
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordINT))) = StrLower(keyWordINT))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordINT))



if (langToTranspileTo = "cpp")
{
str5 := "int "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordSTR))) = StrLower(keyWordSTR))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordSTR))


if (langToTranspileTo = "cpp")
{
str5 := "std::string "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordBOOL))) = StrLower(keyWordBOOL))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordBOOL))


if (langToTranspileTo = "cpp")
{
str5 := "bool "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordFLOAT))) = StrLower(keyWordFLOAT))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordFLOAT))


if (langToTranspileTo = "cpp")
{
str5 := "float "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordINT8))) = StrLower(keyWordINT8))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordINT8))


if (langToTranspileTo = "cpp")
{
str5 := "int8_t "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}

;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordINT16))) = StrLower(keyWordINT16))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordINT16))


if (langToTranspileTo = "cpp")
{
str5 := "int16_t "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordINT32))) = StrLower(keyWordINT32))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordINT32))


if (langToTranspileTo = "cpp")
{
str5 := "int32_t "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordINT64))) = StrLower(keyWordINT64))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordINT64))


if (langToTranspileTo = "cpp")
{
str5 := "long long "
}
else if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}

;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordIF))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
;useParentheses
if (useParentheses = "off")
{
str8 := ""
str9 := expressionParserTranspiler(str1)
Loop, Parse, str9, " "
{
str8 := STR(A_Index)
}

if (INT(str8) <= 4)
{
str2 := "if " . expressionParserTranspiler(str1) . theColon
}
else
{
str2 := "if " . str10 . "(" . StrReplace(expressionParserTranspiler(str1), ":", "") . ")" . theColon
}

}
else
{
str2 := "if " . expressionParserTranspiler(str1) . theColon
}

str2 := StrReplace(str2, ";", "")
str2 := StrReplace(str2, "::", ":")
}
else
{

str1 := StrReplace(str1, ":", "")
if (useParentheses = "off")
{
str2 := "if " . str10 . "(" . expressionParserTranspiler(str1) . ")"
}
else
{
str2 := "if " . expressionParserTranspiler(str1)
}
str2 := StrReplace(str2, ";;", ";")
}
str2 := StrReplace(str2, "::", ":")
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordElseIf))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
;useParentheses
if (useParentheses = "off")
{
str8 := ""
str9 := expressionParserTranspiler(str1)
Loop, Parse, str9, " "
{
str8 := STR(A_Index)
}

if (INT(str8) <= 4)
{
str2 := "elif " . expressionParserTranspiler(str1) . theColon
}
else
{
str2 := "elif " . str10 . "(" . StrReplace(expressionParserTranspiler(str1), ":", "") . ")" . theColon
}

}
else
{
str2 := "elif " . expressionParserTranspiler(str1) . theColon
}

str2 := StrReplace(str2, ";", "")
str2 := StrReplace(str2, "::", ":")
}
else
{

str1 := StrReplace(str1, ":", "")
if (useParentheses = "off")
{
str2 := "else if " . str10 . "(" . expressionParserTranspiler(str1) . ")"
}
else
{
str2 := "else if " . expressionParserTranspiler(str1)
}
str2 := StrReplace(str2, ";;", ";")
}
str2 := StrReplace(str2, "::", ":")
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordElse))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str2 := "else:"
}
else
{
str2 := "else"
}

htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordWhileLoop))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
;useParentheses
if (useParentheses = "off")
{
str8 := ""
str9 := expressionParserTranspiler(str1)
Loop, Parse, str9, " "
{
str8 := STR(A_Index)
}

if (INT(str8) <= 4)
{
str2 := "while " . expressionParserTranspiler(str1) . theColon
}
else
{
str2 := "while " . str10 . "(" . StrReplace(expressionParserTranspiler(str1), ":", "") . ")" . theColon
}

}
else
{
str2 := "while " . expressionParserTranspiler(str1) . theColon
}

str2 := StrReplace(str2, ";", "")
str2 := StrReplace(str2, "::", ":")
}
else
{

str1 := StrReplace(str1, ":", "")
if (useParentheses = "off")
{
str2 := "while " . str10 . "(" . expressionParserTranspiler(str1) . ")"
}
else
{
str2 := "while " . expressionParserTranspiler(str1)
}
str2 := StrReplace(str2, ";;", ";")
}
str2 := StrReplace(str2, "::", ":")
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordForLoop))
;MsgBox, % A_LoopField
if (useParentheses = "on")
{
str2 := transpileForLoop(langToTranspileTo, forLoopLang, "for " . expressionParserTranspiler(str1))
}
else
{
if (langToTranspileTo = "py")
{
str2 := transpileForLoop(langToTranspileTo, forLoopLang, "for " . expressionParserTranspiler(str1))
}
if (langToTranspileTo = "js")
{
str2 := transpileForLoop(langToTranspileTo, forLoopLang, "for (" . expressionParserTranspiler(str1) . ")")
}
if (langToTranspileTo = "cpp")
{
str2 := transpileForLoop(langToTranspileTo, forLoopLang, "for (" . expressionParserTranspiler(str1) . ")")
}
}

lineDone := 1
str2 := StrReplace(str2, "::", ":")
str2 := StrReplace(str2, ";;", ";")
htCode .= str2 . "`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite)) or (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite . ":"))
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1

if (langToTranspileTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , value in enumerate(iter(int, 1), start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToTranspileTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToTranspileTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}


nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
lineDone := 1
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
AindexcharLength++
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop)) && (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) != StrLower(keyWordLoop) . "% ") && (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) != StrLower(keyWordLoopParse))
{
out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop))
out2 := StrReplace(out2, ":", "")
;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToTranspileTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToTranspileTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToTranspileTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1

htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) = StrLower(keyWordLoop) . "% ")
{

out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop) + 2)
out2 := StrReplace(out2, ":", "")

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToTranspileTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToTranspileTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToTranspileTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1

htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
var1 := StringTrimLeft(A_LoopField, StrLen(keyWordLoopParse))
out2 := StrReplace(out2, ":", "")
lineDone := 1

line1 := Trim(StrSplit(var1, ",", 1))

line1 := expressionParserTranspiler(line1)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, keyWordEscpaeChar . ","))
{
line2 := Chr(34) . "," . Chr(34)


if (langToTranspileTo = "py") or (langToTranspileTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
else
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
}
else
{


if (line2 = "") && (line3 = "")
{
; nothing so only each char
if (langToTranspileTo = "py") or (langToTranspileTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
else
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}

}

if (line2 != "") && (line3 = "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (langToTranspileTo = "py") or (langToTranspileTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
else
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}


}

if (line2 != "") && (line3 != "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, keyWordEscpaeChar))
{
line3 := Chr(34) . line3 . Chr(34)
}

if (langToTranspileTo = "py") or (langToTranspileTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
else
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}

}



itemsOut := StrReplace(itemsOut, keyWordEscpaeChar, Chr(92))



}



if (langToTranspileTo = "py")
{
var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in enumerate(items" . STR(AindexcharLength) . ", start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToTranspileTo = "js")
{
var1out := itemsOut . "`n" . "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToTranspileTo = "cpp")
{
var1out := itemsOut . "`n" . "for (size_t " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".size() + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}


nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

;
;
theFixTextLoopLP := ""
if (langToTranspileTo = "cpp")
{
theFixTextLoopLP := "std::string " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}
if (langToTranspileTo = "js")
{
theFixTextLoopLP := "const " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}

htCodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
htCodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
AindexcharLength++
htCode .= htCodeLoopfixa1 . "`n" . var1out . "`n"





}
else if (StrLower(A_LoopField) = StrLower(keyWordContinue)) or (StrLower(A_LoopField) = StrLower(keyWordContinue . ";"))
{
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str2 := "continue"
}
else
{
str2 := "continue;"
}

htCode .= str2 . "`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordBreak)) or (StrLower(A_LoopField) = StrLower(keyWordBreak . ";"))
{
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str2 := "break"
}
else
{
str2 := "break;"
}
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc)) && (useFuncKeyWord = "on")
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordFunc))
;MsgBox, % A_LoopField

str2 := str1
str2 := StrReplace(str2, ":", "")
str2 := StrReplace(str2, Trim(keyWordVariablesAssignmentOperator), "=")
if (langToTranspileTo = "cpp")
{
str2 := RegExReplace(str2, "\\b" . keyWordTrue . "\\b", "true")
str2 := RegExReplace(str2, "\\b" . keyWordFalse . "\\b", "false")
str2 := fixFuncParamsHandleSpaces(str2)


}
else
{
str2 := RegExReplace(str2, "\\bvoid\\b", "")

if (langToTranspileTo != "py")
{
str2 := RegExReplace(str2, "\\b" . keyWordTrue . "\\b", "true")
str2 := RegExReplace(str2, "\\b" . keyWordFalse . "\\b", "false")
}
else
{
str2 := RegExReplace(str2, "\\b" . keyWordTrue . "\\b", "True")
str2 := RegExReplace(str2, "\\b" . keyWordFalse . "\\b", "False")
}


str2 := RegExReplace(str2, "\\b" . Trim(keyWordArrayDefinition) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordArrayOfIntegersDefinition) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordArrayOfStringsDefinition) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordArrayOfFloatingPointNumbersDefinition) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordArrayOfBooleansDefinition) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordINT) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordSTR) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordBOOL) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordINT8) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordINT16) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordINT32) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordINT64) . "\\b", "")
str2 := RegExReplace(str2, "\\b" . Trim(keyWordFLOAT) . "\\b", "")

}

str2 := StrReplace(str2, "):", ")")
str2 := StrReplace(str2, ") :", ")")


if (langToTranspileTo = "py")
{
str3 := "def " . str2 . ":"
}
if (langToTranspileTo = "js")
{
str3 := "async function " . str2
}
if (langToTranspileTo = "cpp")
{
str3 := str2
}
str3 := StrReplace(str3, "  ", " ")
str3 := StrReplace(str3, "( ", "(")
lineDone := 1
htCode .= str3 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordAwait))) = StrLower(keyWordAwait))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordAwait))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str2 := expressionParserTranspiler(str1) . theSemicolon
str2 := StrReplace(str2, ";", "")
}
else if (langToTranspileTo = "js")
{
str2 := "await " . expressionParserTranspiler(str1) . theSemicolon
str2 := StrReplace(str2, ";;", ";")
}
else
{
str2 := expressionParserTranspiler(str1) . theSemicolon
str2 := StrReplace(str2, ";;", ";")
}

htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordSwitch))
;MsgBox, % A_LoopField
lineDone := 1
str1 := StrReplace(str1, ":", "")
if (langToTranspileTo = "py")
{
str2 := "match " . expressionParserTranspiler(str1) . theColon
str2 := StrReplace(str2, ";", "")
str2 := StrReplace(str2, "::", ":")
str2 := StrReplace(str2, "(", "")
str2 := StrReplace(str2, ")", "")
}
else
{
str1 := StrReplace(str1, ":", "")
str2 := "switch " . expressionParserTranspiler(str1)
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordSwitchCase))
;MsgBox, % A_LoopField
str1 := StrReplace(str1, ":", "")
str2 := "case " . expressionParserTranspiler(str1) . ":"

lineDone := 1
htCode .= str2 . "`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordSwitchDefault)) or (StrLower(A_LoopField) = StrLower(keyWordSwitchDefault . ":"))
{
;MsgBox, % A_LoopField
if (langToTranspileTo = "py")
{
str2 := "case _:"
}
else
{
str2 := "default:"
}
lineDone := 1
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordThrow))) = StrLower(keyWordThrow))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordThrow))
;MsgBox, % A_LoopField
;#include <stdexcept>

lineDone := 1
if (langToTranspileTo = "py")
{
str2 := "raise " . expressionParserTranspiler(str1) . theSemicolon
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := "throw " . expressionParserTranspiler(str1) . theSemicolon
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordTry)) or (StrLower(A_LoopField) = StrLower(keyWordTry . ":"))
{
;MsgBox, % A_LoopField
if (langToTranspileTo = "py")
{
str2 := "try:"
}
else
{
str2 := "try"
}
lineDone := 1
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordCatch))
;MsgBox, % A_LoopField
lineDone := 1
str1 := StrReplace(str1, ":", "")
if (langToTranspileTo = "cpp")
{
str2 := "catch " . str10 . "(const std::exception& " . Trim(StrReplace(StrReplace(StrReplace(str1, ":", ""), ")", ""), "(", "")) . ")"
theCppVarForErrors := Trim(StrReplace(StrReplace(StrReplace(str1, ":", ""), ")", ""), "(", ""))
}
if (langToTranspileTo = "js")
{
str2 := "catch " . str10 . "(" . Trim(StrReplace(StrReplace(StrReplace(str1, ":", ""), ")", ""), "(", "")) . ")"
}
if (langToTranspileTo = "py")
{
str2 := "except " . str10 . "Exception as " . Trim(StrReplace(StrReplace(StrReplace(str1, ":", ""), ")", ""), "(", "")) . ":"
}

htCode .= str2 . "`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordFinally)) or (StrLower(A_LoopField) = StrLower(keyWordFinally . ":"))
{
;MsgBox, % A_LoopField

if (langToTranspileTo = "py")
{
str2 := "finally:"
}
if (langToTranspileTo = "js")
{
str2 := "finally"
}
if (langToTranspileTo = "cpp")
{
str2 := "if (" . Chr(34) . "finally dosent exist in c++" . Chr(34) . " == " . Chr(34) . "finally dosent exist in c++" . Chr(34) . ")"
}

lineDone := 1
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordArrayOfIntegersDefinition))) = StrLower(keyWordArrayOfIntegersDefinition))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordArrayOfIntegersDefinition))
if (langToTranspileTo = "cpp")
{
str5 := "std::vector<int> "
}
else if (langToTranspileTo = "js")
{
str5 := "let "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = []"
}
else if (langToTranspileTo = "js")
{
str4 := str5 . StrReplace(str1, ";", "") . " = [];"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordArrayOfStringsDefinition))) = StrLower(keyWordArrayOfStringsDefinition))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordArrayOfStringsDefinition))
if (langToTranspileTo = "cpp")
{
str5 := "std::vector<std::string> "
}
else if (langToTranspileTo = "js")
{
str5 := "let "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = []"
}
else if (langToTranspileTo = "js")
{
str4 := str5 . StrReplace(str1, ";", "") . " = [];"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordArrayOfFloatingPointNumbersDefinition))) = StrLower(keyWordArrayOfFloatingPointNumbersDefinition))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordArrayOfFloatingPointNumbersDefinition))
if (langToTranspileTo = "cpp")
{
str5 := "std::vector<float> "
}
else if (langToTranspileTo = "js")
{
str5 := "let "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = []"
}
else if (langToTranspileTo = "js")
{
str4 := str5 . StrReplace(str1, ";", "") . " = [];"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordArrayOfBooleansDefinition))) = StrLower(keyWordArrayOfBooleansDefinition))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordArrayOfBooleansDefinition))
if (langToTranspileTo = "cpp")
{
str5 := "std::vector<bool> "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = []"
}
else if (langToTranspileTo = "js")
{
str4 := str5 . StrReplace(str1, ";", "") . " = [];"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordArrayDefinition))) = StrLower(keyWordArrayDefinition)) && (lineDone = 0)
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordArrayDefinition))
if (langToTranspileTo = "cpp")
{
str5 := "std::vector<std::string> "
}
else if (langToTranspileTo = "js")
{
str5 := "let "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = []"
}
else if (langToTranspileTo = "js")
{
str4 := str5 . StrReplace(str1, ";", "") . " = [];"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}



;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordJavaScriptVar))) = StrLower(keyWordJavaScriptVar))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordJavaScriptVar))

if (langToTranspileTo = "js")
{
str5 := "var "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordJavaScriptLet))) = StrLower(keyWordJavaScriptLet))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordJavaScriptLet))

if (langToTranspileTo = "js")
{
str5 := "let "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordJavaScriptConst))) = StrLower(keyWordJavaScriptConst))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordJavaScriptConst))

if (langToTranspileTo = "js")
{
str5 := "const "
}
else
{
str5 := ""
}

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"
str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{
if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else
{
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"
str4 := str5 . str1 . theSemicolon
}
}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if (isItAPlusPlusOrMinusMinus(Trim(A_LoopField), 0) != "no") && ((InStr(A_LoopField, "++")) or (InStr(A_LoopField, "--")))
{
str1 := isItAPlusPlusOrMinusMinus(Trim(A_LoopField), 1)
lineDone := 1
htCode .= str1 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordReturnStatement))) = StrLower(keyWordReturnStatement))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordReturnStatement))
;MsgBox, % A_LoopField
lineDone := 1
str2 := "return " . expressionParserTranspiler(str1) . theSemicolon

if (langToTranspileTo = "py")
{
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else if (StrLower(Trim(A_LoopField)) = StrLower(Trim(keyWordReturnStatement)))
{
;MsgBox, % A_LoopField
lineDone := 1
str2 := "return;"

if (langToTranspileTo = "py")
{
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordGlobal))) = StrLower(keyWordGlobal))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordGlobal))
;MsgBox, % A_LoopField
str1 := StrReplace(str1, ";", "")
lineDone := 1
if (langToTranspileTo = "py")
{
str2 := "global " . str1
}
else
{
str2 := ""
}

htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordComment))) = StrLower(keyWordComment))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordComment))
;MsgBox, % A_LoopField
if (langToTranspileTo = "py")
{
str2 := "#" . str1
}
if (langToTranspileTo = "js")
{
str2 := "//" . str1
}
if (langToTranspileTo = "cpp")
{
str2 := "//" . str1
}


lineDone := 1
htCode .= str2 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordCommentOpenMultiLine))) = StrLower(keyWordCommentOpenMultiLine))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordCommentOpenMultiLine))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
htCode .= Chr(34) . Chr(34) . Chr(34) . "`n"
}
else
{
htCode .= Chr(47) . Chr(42) . "`n"
}

}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordCommentCloseMultiLine))) = StrLower(keyWordCommentCloseMultiLine))
{
str1 := StringTrimLeft(A_LoopField, StrLen(keyWordCommentCloseMultiLine))
;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
htCode .= Chr(34) . Chr(34) . Chr(34) . "`n"
}
else
{
htCode .= Chr(42) . Chr(47) . "`n"
}
}
else if (KeyWordsCommands(A_LoopField, "check", keyWordsCommands, langToTranspileTo) = "true") && (lineDone = 0)
{
out_KeyWordsCommands := KeyWordsCommands(A_LoopField, "transpile", keyWordsCommands, langToTranspileTo)
;MsgBox, % out_KeyWordsCommands
lineDone := 1
htCode .= out_KeyWordsCommands . "`n"
}
else if (InStr(A_LoopField, keyWordArrayAppend)) or (InStr(A_LoopField, keyWordArrayPop)) or (InStr(A_LoopField, keyWordArraySize)) or (InStr(A_LoopField, keyWordArrayInsert)) or (InStr(A_LoopField, keyWordArrayRemove)) or (InStr(A_LoopField, keyWordArrayIndexOf)) && (lineDone = 0)
{
;MsgBox, % A_LoopField
lineDone := 1
str2 := expressionParserTranspiler(A_LoopField) . theSemicolon

if (langToTranspileTo = "py")
{
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else if (InStr(A_LoopField, keyWordVariablesAssignmentOperator)) or (InStr(A_LoopField, keyWordConcatenationAssignmentOperator)) or (InStr(A_LoopField, keyWordAdditionAssignmentOperator)) or (InStr(A_LoopField, keyWordSubtractionAssignmentOperator)) or (InStr(A_LoopField, keyWordMultiplicationAssignmentOperator)) or (InStr(A_LoopField, keyWordDivisionAssignmentOperator)) && (lineDone = 0)
{
str1 := A_LoopField

str5 := ""

if (InStr(str1, keyWordVariablesAssignmentOperator))
{
outVarOperator := "="

str2 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordVariablesAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordConcatenationAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordConcatenationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordAdditionAssignmentOperator))
{
outVarOperator := "+="

str2 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordAdditionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordSubtractionAssignmentOperator))
{
outVarOperator := "-="

str2 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordSubtractionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordMultiplicationAssignmentOperator))
{
outVarOperator := "*="

str2 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordMultiplicationAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else if (InStr(str1, keyWordDivisionAssignmentOperator))
{
outVarOperator := "/="

str2 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 1))
str3 := Trim(StrSplit(str1, keyWordDivisionAssignmentOperator, 2))
str3 := expressionParserTranspiler(str3)

if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str2, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str2, ";", "")) . "|"

str4 := str5 . str2 . " " . outVarOperator . " " . str3 . theSemicolon
}
else
{



if (langToTranspileTo = "py")
{
str4 := Trim(str5) . Trim(str1) . " = None"
}
else if (langToTranspileTo = "js")
{


if (langToTranspileTo = "js") && (useInJavaScriptAlwaysUseVar = "on")
{
;theJSvarDeclaredVarsBugFix
if (InStr(theJSvarDeclaredVarsBugFix, "|" . Trim(StrReplace(str1, ";", "")) . "|"))
{
str5 := ""
}
else
{
str5 := "var "
}
}
else
{
str5 := ""
}
theJSvarDeclaredVarsBugFix .= "|" . Trim(StrReplace(str1, ";", "")) . "|"

str4 := str5 . str1 . theSemicolon
}
else
{
str4 := str5 . str1 . theSemicolon
}



}


;MsgBox, % A_LoopField
lineDone := 1
if (langToTranspileTo = "py")
{
str4 := StrReplace(str4, ";", "")
}
else
{
str4 := StrReplace(str4, ";;", ";")
}
htCode .= str4 . "`n"
}
else if ((SubStr(Trim(A_LoopField), -2) = ");") or (SubStr(Trim(A_LoopField), -1) = ")")) && (!(InStr(A_LoopField, "int main(int argc, char* argv[])"))) && (!(InStr(A_LoopField, "async function main()"))) && (lineDone = 0)
{
lineDone := 1
str1 := A_LoopField
if (langToTranspileTo = "py")
{
str1 := StrReplace(str1, ";", "")
}

if (Trim(lookIntoTheNextLineForFuncWhitNoKeyWord[A_Index + 1]) = "{") && (useFuncKeyWord = "off")
{
str2 := str1



str2 := StrReplace(str2, Trim(keyWordVariablesAssignmentOperator), "=")
str2 := StrReplace(str2, "):", ")")
str2 := StrReplace(str2, ") :", ")")


if (langToTranspileTo = "py")
{
str3 := "def " . str2 . ":"
}
if (langToTranspileTo = "js")
{
str3 := "async function " . str2
}
if (langToTranspileTo = "cpp")
{
str3 := str1
}


htCode .= str3 . "`n"
}
else
{
str2 := expressionParserTranspiler(Trim(str1)) . ";"
if (langToTranspileTo = "py")
{
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
}
else
{
;MsgBox, % "else else else " . A_LoopField
; this is THE else
if (lineDone != 1)
{
if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
htCode .= Chr(125) . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixLP = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixLP := 0


htCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixNL = 1) && (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixNL := 0
htCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
htCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}
}
}

}

StringTrimRight, htCode, htCode, 1













































int indentTrackCurlyBraceOpenClose := 0
int canEndIndentTrackCurlyBraceOpenClose := 0
int indentTrackCurlyBraceOpenCloseSTARTEDAT := 0
int indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
int indentTrackCurlyBraceOpenCloseENDNEXT := 0


int INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 0

int INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0

int INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover := 0


int startInStartEdCurlyBraceStartONce := 0
str OSPpasringHoldNameFirstPart := ""

str addOSPtoHTVM := ""

int foundAllianceCrewOrOtehrs := 0
foundAllianceCrewOrOtehrs := 0
Loop, Parse, htCode, `n ,`r
{



if (SubStr(StrLower(Trim(A_LoopField)), 1, 9) = "alliance ")
{
foundAllianceCrewOrOtehrs := 1
StringTrimLeft, OSPpasringHoldNameFirstPart, A_LoopField, 9
OSPpasringHoldNameFirstPart := Trim(OSPpasringHoldNameFirstPart)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 1
indentTrackCurlyBraceOpenCloseSTARTEDAT := A_Index
indentTrackCurlyBraceOpenClose := 0
canEndIndentTrackCurlyBraceOpenClose := 0
indentTrackCurlyBraceOpenCloseENDNEXT := 0
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
startInStartEdCurlyBraceStartONce := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
}
else if (Trim(A_LoopField) = "{")
{
if (foundAllianceCrewOrOtehrs = 1)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
startInStartEdCurlyBraceStartONce++
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
if (startInStartEdCurlyBraceStartONce = 1)
{
addOSPtoHTVM .= "alliance|start|" . OSPpasringHoldNameFirstPart . "`n"
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose--
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else if (Trim(A_LoopField) = "}")
{
if (foundAllianceCrewOrOtehrs = 1)
{
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose++
if (indentTrackCurlyBraceOpenClose = 0)
{
indentTrackCurlyBraceOpenCloseENDNEXT := 1

indentTrackCurlyBraceOpenCloseENDNEXTonce++
if (indentTrackCurlyBraceOpenCloseENDNEXTonce = 1) && (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover++
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE++
addOSPtoHTVM .= "alliance|end|" . OSPpasringHoldNameFirstPart . "`n"
;MsgBox, % "foundCLose } at line " . STR(A_Index) . " and started at " . STR(indentTrackCurlyBraceOpenCloseSTARTEDAT)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 0
}
}

if (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
addOSPtoHTVM .= A_LoopField . "`n"
}


}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}

}


StringTrimRight, htCode, addOSPtoHTVM, 1



foundAllianceCrewOrOtehrs := 0
addOSPtoHTVM := ""

Loop, Parse, htCode, `n ,`r
{
if (SubStr(StrLower(Trim(A_LoopField)), 1, 5) = "crew ")
{
foundAllianceCrewOrOtehrs := 1
StringTrimLeft, OSPpasringHoldNameFirstPart, A_LoopField, 5
OSPpasringHoldNameFirstPart := Trim(OSPpasringHoldNameFirstPart)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 1
indentTrackCurlyBraceOpenCloseSTARTEDAT := A_Index
indentTrackCurlyBraceOpenClose := 0
canEndIndentTrackCurlyBraceOpenClose := 0
indentTrackCurlyBraceOpenCloseENDNEXT := 0
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
startInStartEdCurlyBraceStartONce := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
}
else if (Trim(A_LoopField) = "{")
{
if (foundAllianceCrewOrOtehrs = 1)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
startInStartEdCurlyBraceStartONce++
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
if (startInStartEdCurlyBraceStartONce = 1)
{
addOSPtoHTVM .= "crew|start|" . OSPpasringHoldNameFirstPart . "`n"
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose--
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else if (Trim(A_LoopField) = "}")
{
if (foundAllianceCrewOrOtehrs = 1)
{
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose++
if (indentTrackCurlyBraceOpenClose = 0)
{
indentTrackCurlyBraceOpenCloseENDNEXT := 1

indentTrackCurlyBraceOpenCloseENDNEXTonce++
if (indentTrackCurlyBraceOpenCloseENDNEXTonce = 1) && (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover++
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE++
addOSPtoHTVM .= "crew|end|" . OSPpasringHoldNameFirstPart . "`n"
;MsgBox, % "foundCLose } at line " . STR(A_Index) . " and started at " . STR(indentTrackCurlyBraceOpenCloseSTARTEDAT)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 0
}
}

if (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
addOSPtoHTVM .= A_LoopField . "`n"
}


}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}

}


StringTrimRight, htCode, addOSPtoHTVM, 1





addOSPtoHTVM := ""
foundAllianceCrewOrOtehrs := 0
Loop, Parse, htCode, `n ,`r
{
if (SubStr(StrLower(Trim(A_LoopField)), 1, 8) = "def obj ")
{
foundAllianceCrewOrOtehrs := 1
StringTrimLeft, OSPpasringHoldNameFirstPart, A_LoopField, 8
OSPpasringHoldNameFirstPart := Trim(OSPpasringHoldNameFirstPart)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 1
indentTrackCurlyBraceOpenCloseSTARTEDAT := A_Index
indentTrackCurlyBraceOpenClose := 0
canEndIndentTrackCurlyBraceOpenClose := 0
indentTrackCurlyBraceOpenCloseENDNEXT := 0
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
startInStartEdCurlyBraceStartONce := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
}
else if (Trim(A_LoopField) = "{")
{
if (foundAllianceCrewOrOtehrs = 1)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
startInStartEdCurlyBraceStartONce++
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
if (startInStartEdCurlyBraceStartONce = 1)
{
addOSPtoHTVM .= "def obj|start|" . OSPpasringHoldNameFirstPart . "`n"
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose--
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else if (Trim(A_LoopField) = "}")
{
if (foundAllianceCrewOrOtehrs = 1)
{
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose++
if (indentTrackCurlyBraceOpenClose = 0)
{
indentTrackCurlyBraceOpenCloseENDNEXT := 1

indentTrackCurlyBraceOpenCloseENDNEXTonce++
if (indentTrackCurlyBraceOpenCloseENDNEXTonce = 1) && (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover++
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE++
addOSPtoHTVM .= "def obj|end|" . OSPpasringHoldNameFirstPart . "`n"
;MsgBox, % "foundCLose } at line " . STR(A_Index) . " and started at " . STR(indentTrackCurlyBraceOpenCloseSTARTEDAT)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 0
}
}

if (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
addOSPtoHTVM .= A_LoopField . "`n"
}

}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}

}


StringTrimRight, htCode, addOSPtoHTVM, 1




addOSPtoHTVM := ""
foundAllianceCrewOrOtehrs := 0
Loop, Parse, htCode, `n ,`r
{
if (SubStr(StrLower(Trim(A_LoopField)), 1, 7) = "method ")
{
foundAllianceCrewOrOtehrs := 1
StringTrimLeft, OSPpasringHoldNameFirstPart, A_LoopField, 7
OSPpasringHoldNameFirstPart := Trim(OSPpasringHoldNameFirstPart)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 1
indentTrackCurlyBraceOpenCloseSTARTEDAT := A_Index
indentTrackCurlyBraceOpenClose := 0
canEndIndentTrackCurlyBraceOpenClose := 0
indentTrackCurlyBraceOpenCloseENDNEXT := 0
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
startInStartEdCurlyBraceStartONce := 0
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
}
else if (Trim(A_LoopField) = "{")
{
if (foundAllianceCrewOrOtehrs = 1)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
startInStartEdCurlyBraceStartONce++
indentTrackCurlyBraceOpenCloseENDNEXTonce := 0
if (startInStartEdCurlyBraceStartONce = 1)
{
addOSPtoHTVM .= "method|start|" . OSPpasringHoldNameFirstPart . "`n"
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose--
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else if (Trim(A_LoopField) = "}")
{
if (foundAllianceCrewOrOtehrs = 1)
{
canEndIndentTrackCurlyBraceOpenClose := 1
indentTrackCurlyBraceOpenClose++
if (indentTrackCurlyBraceOpenClose = 0)
{
indentTrackCurlyBraceOpenCloseENDNEXT := 1

indentTrackCurlyBraceOpenCloseENDNEXTonce++
if (indentTrackCurlyBraceOpenCloseENDNEXTonce = 1) && (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_itsOVERover++
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE++
addOSPtoHTVM .= "method|end|" . OSPpasringHoldNameFirstPart . "`n"
;MsgBox, % "foundCLose } at line " . STR(A_Index) . " and started at " . STR(indentTrackCurlyBraceOpenCloseSTARTEDAT)
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDE := 0
}
}

if (INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE = 0)
{
INSIDEindentTrackCurlyBraceOpenCloseENDNEXT_INSIDEdoneDONE := 0
addOSPtoHTVM .= A_LoopField . "`n"
}

}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}
}
else
{
addOSPtoHTVM .= A_LoopField . "`n"
}

}


StringTrimRight, htCode, addOSPtoHTVM, 1




;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================
;MsgBox, % htCode
;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================
;MsgBox, ========================== phase1 =============================


arr str statckOSPgetData
arr str OSPconnectionArrayHOLD
str OSPconnectionStrHOLD

str OSPholdPROPstrForArray := ""


; important string
; exmaple how it will look like



int areWeInDefObj := 0


addOSPtoHTVM := ""

Loop, Parse, htCode, `n ,`r
{

if (InStr(A_LoopField, "alliance|start|"))
{
arr statckOSPgetData .= Trim(StrSplit(A_LoopField, "|", 3))
}
else if (InStr(A_LoopField, "crew|start|"))
{
arr statckOSPgetData .= Trim(StrSplit(A_LoopField, "|", 3))
}
else if (InStr(A_LoopField, "def obj|start|"))
{
OSPholdPROPstrForArray := ""
areWeInDefObj := 1
arr statckOSPgetData .= Trim(StrSplit(A_LoopField, "|", 3))
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, 5) = "prop ")
{
OSPholdPROPstrForArray .= A_LoopField . "|"
}
else if (InStr(A_LoopField, "method|start|"))
{
if (InStr(Trim(A_LoopField), " "))
{
arr statckOSPgetData .= Trim(StrSplit(Trim(StrSplit(Trim(StrSplit(A_LoopField, "|", 3)), "(", 1)), " ", 2))
}
else
{
arr statckOSPgetData .= Trim(StrSplit(Trim(StrSplit(A_LoopField, "|", 3)), "(", 1))
}

OSPconnectionStrHOLD := ""
Loop, % INT(statckOSPgetData[0])
{
;MsgBox, % "aswadsfadsfasdfasd::::::::::::::" . statckOSPgetData[A_Index]
OSPconnectionStrHOLD .= statckOSPgetData[A_Index] . "_"
str5 := statckOSPgetData[A_Index]
}

StringTrimRight, OSPconnectionStrHOLD, OSPconnectionStrHOLD, 1
;MsgBox, % OSPconnectionStrHOLD



HoldOSPdethodNamePath .= StrReplace(OSPconnectionStrHOLD, "_", ".") . "|"


str1 := Trim(StrSplit(Trim(StrSplit(A_LoopField, "|", 3)), " ", 1))
str2 := OSPconnectionStrHOLD


if (str1 = Trim(keyWordINT))
{
str4 := "int"
}
else if (str1 = Trim(keyWordSTR))
{
str4 := "std::string"
}
else if (str1 = Trim(keyWordFLOAT))
{
str4 := "float"
}
else if (str1 = Trim(keyWordBOOL))
{
str4 := "bool"
}
else if (str1 = Trim(keyWordINT8))
{
str4 := "int8_t"
}
else if (str1 = Trim(keyWordINT16))
{
str4 := "int16_t"
}
else if (str1 = Trim(keyWordINT32))
{
str4 := "int32_t"
}
else if (str1 = Trim(keyWordINT64))
{
str4 := "int64_t"
}
else
{
str4 := "void"
}

if (langToTranspileTo = "cpp")
{
addOSPtoHTVM .= str4 . " OSPHTVMOSP_" . str2 . "(std::optional<std::vector<std::any>> this__OSP__this = std::nullopt)`n{`n"
}
if (langToTranspileTo = "js")
{
addOSPtoHTVM .= "async function OSPHTVMOSP_" . str2 . "(this__OSP__this = null)`n{`n"
}
if (langToTranspileTo = "py")
{
addOSPtoHTVM .= "def OSPHTVMOSP_" . str2 . "(this__OSP__this = None):`n{`n"
}

}
else if (InStr(A_LoopField, "alliance|end|"))
{
OSPconnectionStrHOLD := ""
Loop, % INT(statckOSPgetData[0])
{
OSPconnectionStrHOLD .= statckOSPgetData[A_Index] . "."
}
StringTrimRight, OSPconnectionStrHOLD, OSPconnectionStrHOLD, 1
arr OSPconnectionArrayHOLD .= OSPconnectionStrHOLD
statckOSPgetData.pop_back()
}
else if (InStr(A_LoopField, "crew|end|"))
{
OSPconnectionStrHOLD := ""
Loop, % INT(statckOSPgetData[0])
{
OSPconnectionStrHOLD .= statckOSPgetData[A_Index] . "."
}
StringTrimRight, OSPconnectionStrHOLD, OSPconnectionStrHOLD, 1
arr OSPconnectionArrayHOLD .= OSPconnectionStrHOLD
statckOSPgetData.pop_back()
}
else if (InStr(A_LoopField, "def obj|end|"))
{

StringTrimRight, OSPholdPROPstrForArray, OSPholdPROPstrForArray, 1
if (Trim(OSPholdPROPstrForArray) != "")
{

str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str6 := ""
str7 := ""
str8 := ""
str9 := ""
str10 := ""

str1 := ""


areWeInDefObj := 0
OSPconnectionStrHOLD := ""
Loop, % INT(statckOSPgetData[0])
{
OSPconnectionStrHOLD .= statckOSPgetData[A_Index] . "."
}
StringTrimRight, OSPconnectionStrHOLD, OSPconnectionStrHOLD, 1
arr OSPconnectionArrayHOLD .= OSPconnectionStrHOLD
statckOSPgetData.pop_back()

OSPstrArrayStrALLobjInOSP .= OSPconnectionStrHOLD . ":"


if (langToTranspileTo = "cpp")
{
str2 := "std::vector<std::any> OSPHTVMOSP_" . StrReplace(OSPconnectionStrHOLD, ".", "_") . " = {`nstd::string(" . Chr(34) . OSPconnectionStrHOLD . Chr(34) . "),`n"
}
if (langToTranspileTo = "py")
{
str2 := "OSPHTVMOSP_" . StrReplace(OSPconnectionStrHOLD, ".", "_") . " = [`n" . Chr(34) . OSPconnectionStrHOLD . Chr(34) . ",`n"
}
if (langToTranspileTo = "js")
{
str2 := "let OSPHTVMOSP_" . StrReplace(OSPconnectionStrHOLD, ".", "_") . " = [`n" . Chr(34) . OSPconnectionStrHOLD . Chr(34) . ",`n"
}

Loop, Parse, OSPholdPROPstrForArray, "|"
{
str1 := A_LoopField
if (Trim(A_LoopField) != "")
{
; prop str typeOf := ""
; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]
;;;;;;;;



str1 := StrReplace(str1, Trim(keyWordArrayOfIntegersDefinition) . " ", "vector<int> ")
str1 := StrReplace(str1, Trim(keyWordArrayOfStringsDefinition) . " ", "vector<string> ")
str1 := StrReplace(str1, Trim(keyWordArrayOfFloatingPointNumbersDefinition) . " ", "vector<float> ")
str1 := StrReplace(str1, Trim(keyWordArrayOfBooleansDefinition) . " ", "vector<bool> ")
str1 := StrReplace(str1, Trim(keyWordArrayDefinition) . " ", "vector<string> ")
str1 := StrReplace(str1, ";", "")

OSPstrArrayStrALLobjInOSP .= Trim(StrSplit(str1, " ", 3)) . "[" . Trim(StrSplit(str1, " ", 2)) . "],"

if (InStr(Trim(StrSplit(str1, " ", 5)), "ihuiuuhuuhtheidFor-asas-theuhturtyphoutr-")) or (InStr(Trim(StrSplit(str1, " ", 5)), Chr(34)))
{
if (langToTranspileTo = "cpp")
{
str4 .= "std::string(" . Trim(StrSplit(str1, " ", 5)) . "),`n"
}
else
{
str4 .= Trim(StrSplit(str1, " ", 5)) . ",`n"
}

}
else
{

if (langToTranspileTo = "cpp")
{
str4 .= Trim(StrSplit(str1, " ", 5)) . ",`n"
}
else
{
str4 .= Trim(StrSplit(str1, " ", 5)) . ",`n"
}


}

;;;;;;;;
}
}
StringTrimRight, OSPstrArrayStrALLobjInOSP, OSPstrArrayStrALLobjInOSP, 1
OSPstrArrayStrALLobjInOSP .= "|"

if (langToTranspileTo = "cpp")
{
addOSPtoHTVM .= str2 . str4 . "};`n"
}
else
{
addOSPtoHTVM .= str2 . str4 . "]`n"
}

}

}
else if (InStr(A_LoopField, "method|end|"))
{
addOSPtoHTVM .= "}`n"
OSPconnectionStrHOLD := ""
Loop, % INT(statckOSPgetData[0])
{
OSPconnectionStrHOLD .= statckOSPgetData[A_Index] . "."
}
StringTrimRight, OSPconnectionStrHOLD, OSPconnectionStrHOLD, 1
arr OSPconnectionArrayHOLD .= OSPconnectionStrHOLD
statckOSPgetData.pop_back()
}
else
{
addOSPtoHTVM .= parserOSPgloabl(OSPstrArrayStrALLobjInOSP, A_LoopField) . "`n"
}
}
StringTrimRight, htCode, addOSPtoHTVM, 1
StringTrimRight, OSPstrArrayStrALLobjInOSP, OSPstrArrayStrALLobjInOSP, 1

; alliance|start|animalsKingdom
; crew|start|animals
; def obj|start|Dog


;MsgBox, ========================== phase2 =============================
;MsgBox, ========================== phase2 =============================
;MsgBox, % OSPstrArrayStrALLobjInOSP
;MsgBox, ========================== phase2 =============================
;MsgBox, ========================== phase2 =============================
;MsgBox, % htCode
;MsgBox, ========================== phase2 =============================
;MsgBox, ========================== phase2 =============================
;MsgBox, ========================== phase2 =============================
;MsgBox, ========================== phase2 =============================




; last OSP fix



str fixJSthatVARkeyword := ""
str fixJSthatVARkeywordOUT := ""

if (langToTranspileTo = "js")
{

Loop, Parse, htCode, `n, `r
{
    if (SubStr(Trim(A_LoopField), 1, StrLen("var ")) = "var ")
    {
        if (InStr(A_LoopField, "= "))
        {
            if (InStr(StrSplit(A_LoopField, "= ", 1), "[")) or (InStr(StrSplit(A_LoopField, "= ", 1), "."))
            {
                fixJSthatVARkeywordOUT .= StringTrimLeft(A_LoopField, 4) . "`n"
            }
            else
            {
                fixJSthatVARkeywordOUT .= A_LoopField . "`n"
            }
        }
        else
        {
            fixJSthatVARkeywordOUT .= A_LoopField . "`n"
        }
    }
    else
    {
        fixJSthatVARkeywordOUT .= A_LoopField . "`n"
    }
}

StringTrimRight, htCode, fixJSthatVARkeywordOUT, 1


}











































;s

if (haveWeEverUsedAloop = 1)
{

StringTrimRight, htCodeLoopfixa, htCodeLoopfixa, 1

;OutputDebug, |%htCodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, htCodeLoopfixa, `n, `r
{



sstr123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(sstr123 ,"|" , 1)
out2 := StrSplit(sstr123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{

inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField


DeleayOneCuzOfLoopParse := 1


out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}

out4758686d86d86d86578991a .= A_LoopField . "`n"
}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\\d*", "" . keyWordAIndex . "" . out1z)




out4758686d86d86d86578991a .= ALoopField . "`n"

}


if (inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) && (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") && (weAreDoneHereCurly != 1) && (insdeAnestedLoopBAD != 1) && (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField

DeleayOneCuzOfLoopParse := 1

out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(123))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) && (InStr(A_LoopField, Chr(125))) && (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") && (insdeAnestedLoopBAD != 1) && (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) && (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) && (readyToEnd1 = 1) && (netsedCurly1 = 0) && (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}


out4758686d86d86d86578991a .= A_LoopField . "`n"

}


if (inTarget = 1) && (dontSaveStr != 1) && (fixLoopLokingForNum != 1) && (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField

; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\\d*", "" . keyWordAIndex . "" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordALoopField . "\\d*", "" . keyWordALoopField . "" . out1z)





out4758686d86d86d86578991a .= ALoopField . "`n"

}


if ((inTarget = 1) && (InStr(A_LoopField, Chr(125))) && (readyToEnd = 1) && (netsedCurly = 0) && (weAreDoneHereCurly = 0) && (dontSaveStr != 1) && (insdeAnestedLoopBAD != 1))
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) && (endBracketDOntPutThere != 1) && (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, htCode, `n, `r
{
ignore := 0
if (SubStr(Trim(A_LoopField), 1, 4) = "for ")
{
if (hold = 1) && (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!(ignore))
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
htCode := out4758686d86dgt8r754444444


}


htCodeOut1234565432 := ""
Loop, Parse, htCode, `n, `r
{
out := A_LoopField
if (!(InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|")))
{
htCodeOut1234565432 .= out . "`n"
}
}


StringTrimRight, htCode, htCodeOut1234565432, 1















areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0

str funcLangHolder
str funcNameHolder
str funcLibsHolder
str funcFuncHolder
str funcDescriptionHolder

arr str allFuncLang
arr str allFuncNames
arr str allFuncLibs
arr str allFuncs
arr str allfuncDescription


int correctLang := 0
Loop, Parse, instructions, `n, `r
{
if (Trim(A_LoopField) = "funcEND======================funcEND==============")
{
areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0
if (correctLang = 1) && (InStr(htCode, Trim(funcNameHolder)))
{
;MsgBox, % funcFuncHolder
arr allFuncs .= funcFuncHolder
}
correctLang := 0
funcFuncHolder := ""
}

if (areWeInAFuncFromInstructions = 1)
{

if (areWeInAFuncFromInstructionsLineNum = 1)
{
; name of the func
StringTrimLeft, funcLangHolder, A_LoopField, 5
if (Trim(funcLangHolder) = langToTranspileTo)
{
arr allFuncLang .= Trim(funcLangHolder)
correctLang := 1
}
}
if (areWeInAFuncFromInstructionsLineNum = 2)
{
; name of the func
StringTrimLeft, funcNameHolder, A_LoopField, 5
if (correctLang = 1) && (InStr(htCode, Trim(funcNameHolder)))
{
arr allFuncNames .= Trim(funcNameHolder)
}
}
if (areWeInAFuncFromInstructionsLineNum = 3)
{
; all libs
StringTrimLeft, funcLibsHolder, A_LoopField, 5
if (correctLang = 1) && (InStr(htCode, Trim(funcNameHolder)))
{
arr allFuncLibs .= Trim(funcLibsHolder)
}
}
if (areWeInAFuncFromInstructionsLineNum = 4)
{
; func description
StringTrimLeft, funcDescriptionHolder, A_LoopField, 12
if (correctLang = 1) && (InStr(htCode, Trim(funcNameHolder)))
{
arr allfuncDescription .= Trim(funcDescriptionHolder)
}
}
if (areWeInAFuncFromInstructionsLineNum >= 5)
{
; the full func
if (correctLang = 1) && (InStr(htCode, Trim(funcNameHolder)))
{
funcFuncHolder .= A_LoopField . "`n"
}
}

;MsgBox, % A_LoopField

areWeInAFuncFromInstructionsLineNum++
}


if (Trim(A_LoopField) = "func======================func==============")
{
areWeInAFuncFromInstructions := 1
areWeInAFuncFromInstructionsLineNum := 1
correctLang := 0
}



}

;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncNames
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLibs
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLang
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncs
;~ MsgBox, ===========================================================================


if (langToTranspileTo = "py")
{
htCode := indent_nested_curly_braces(htCode, 0)
}
else
{
htCode := indent_nested_curly_braces(htCode, 1)
}



if (langToTranspileTo = "cpp")
{
htCode := htCode . "`n    return 0;`n}"
htCode := StrReplace(htCode, "int main(int argc, char* argv[]);", "int main(int argc, char* argv[])")
}
if (langToTranspileTo = "js") && (useJavaScriptAmainFuncDef = "on")
{
htCode := htCode . "`n}`nmain();"
htCode := StrReplace(htCode, "async function main();", "async function main()")
htCode := StrReplace(htCode, "function async function main()", "async function main()")
}



str jsHTMLdownCode := "</script>`n</body>`n</html>"

int includeLibsInCppIf

str allFuncsToPutAtTop := "`n"
str allLibsToPutAtTop
MsgBox, Transpiling...
if (!(INT(allFuncNames[0]) <= 0))
{
Loop, % INT(allFuncNames[0])
{
if (InStr(htCode, allFuncNames[A_Index]) . "(")
{
;MsgBox, % allFuncNames[A_Index]

allFuncsToPutAtTop .= allFuncs[A_Index] . "`n"

if (Trim(allFuncLibs[A_Index]) != "null")
{
allLibsToPutAtTop .= allFuncLibs[A_Index] . "|"
}

}
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTop, 1

str allLibsToPutAtTopTEMP
Loop, Parse, allLibsToPutAtTop, "|"
{
allLibsToPutAtTopTEMP .= A_LoopField . "`n"
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTopTEMP, 1

includeLibsInCppIf := 1

if (langToTranspileTo = "cpp")
{
allLibsToPutAtTop := "#include <iostream>`n#include <sstream>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n#include <any>`n#include <optional>`n" . allLibsToPutAtTop
}

Sort, allLibsToPutAtTop, U

allLibsToPutAtTop := StrReplace(allLibsToPutAtTop, "~", "`n")

if (langToTranspileTo != "js")
{
htCode := allLibsToPutAtTop . "`n" . allFuncsToPutAtTop . "`n" . htCode
}
else
{
htCode := "`n" . allFuncsToPutAtTop . "`n" . htCode
}

}
MsgBox, Transpiling...

Loop, % theIdNumOfThe34
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidFor-asas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(A_Index) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index])
}

htCode := StrReplace(htCode, ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes, Chr(92) . Chr(34))


htCode := StrReplace(htCode, "std::string(" . Chr(34) . Chr(34) . ";),", "std::string(" . Chr(34) . Chr(34) . "),")





str jsHTMLupCode := "<!doctype html>`n<html lang=" . Chr(34) . "en" . Chr(34) . ">`n    <head>`n        <meta charset=" . Chr(34) . "UTF-8" . Chr(34) . " />`n        <meta name=" . Chr(34) . "viewport" . Chr(34) . " content=" . Chr(34) . "width=device-width, initial-scale=1.0" . Chr(34) . " />`n        <title>HTVM</title>`n        <style>`n            body {`n                background-color: #202020;`n                font-family:`n                    " . Chr(34) . "Open Sans" . Chr(34) . ",`n                    -apple-system,`n                    BlinkMacSystemFont,`n                    " . Chr(34) . "Segoe UI" . Chr(34) . ",`n                    Roboto,`n                    Oxygen-Sans,`n                    Ubuntu,`n                    Cantarell,`n                    " . Chr(34) . "Helvetica Neue" . Chr(34) . ",`n                    Helvetica,`n                    Arial,`n                    sans-serif;`n            }`n        </style>`n" . allLibsToPutAtTop . "`n</head>`n    <body>`n<script>"



if (useJavaScriptInAfullHTMLfile = "on") && (langToTranspileTo = "js")
{
htCode := jsHTMLupCode . "`n" . htCode . "`n" . jsHTMLdownCode
}

if (langToTranspileTo = "cpp") && (includeLibsInCppIf = 0)
{
htCode := "#include <iostream>`n#include <sstream>`n#include <any>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n`n" . htCode
}



MsgBox, % htCode

Loop, Parse, fileExtention
{
StringTrimRight, filePathOfCode, filePathOfCode, 1
}
if (useJavaScriptInAfullHTMLfile = "on") && (langToTranspileTo = "js")
{
filePathOfCode := filePathOfCode . "html"
}
else
{
filePathOfCode := filePathOfCode . langToTranspileTo
}
FileDelete, %filePathOfCode%
FileAppend, %htCode%, %filePathOfCode%

}

main:
compiler()


