; Function to generate the randomized states (from previous request, UNCHANGED)
func arr str GenerateRandomizedStates() {
    int numStates := 13
    arr str states
    Loop, % numStates {
        states.add("off")
    }
    int randomPick_c2 := Random(0, 1)
    if (randomPick_c2 = 0) {
        states[4] := "on"
        states[5] := "off"
    } else {
        states[4] := "off"
        states[5] := "on"
    }
    int randomPick_s0 := Random(0, 1)
    if (randomPick_s0 = 0) {
        states[0] := "on"
    } else {
        states[0] := "off"
    }
    if (states[0] = "on") {
        states[1] := "off"
    } else {
        int randomPick_s1 := Random(0, 1)
        if (randomPick_s1 = 0) {
            states[1] := "on"
        } else {
            states[1] := "off"
        }
    }
    if (states[0] = "on") {
        states[6] := "off"
    } else {
        int randomPick_s6 := Random(0, 1)
        if (randomPick_s6 = 0) {
            states[6] := "on"
        } else {
            states[6] := "off"
        }
    }
    arr int remainingIndices := [2, 3, 7, 8, 9, 10, 11, 12]
    Loop, % remainingIndices.size() {
        int currentIndexInLoop := A_Index
        int idxToSet := remainingIndices[currentIndexInLoop]
        int randomPick_remaining := Random(0, 1)
        if (randomPick_remaining = 0) {
            states[idxToSet] := "on"
        } else {
            states[idxToSet] := "off"
        }
    }
    return states
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start of A_Index / A_LoopField variant generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function to generate a random "sane" name for A_Index alternatives (UNCHANGED HELPER)
func str GetRandomSaneIndexName() {
    arr str saneNames := ["A_I", "A_Current", "A_Iteration", "A_Idx", "A_Counter", "LoopIndex", "CurrentItemNo", "A_Position", "A_Num", "A_Step", "A_Seq", "A_Ordinal", "A_Rank", "A_Row", "A_Column", "A_Depth", "A_Level", "A_FilePos", "A_LineNum", "A_CharPos", "A_ItemNum", "A_RecordId", "A_NodeId", "A_ArrayIndex", "A_ListPosition", "A_MapKeyIndex", "A_ProcessCounter", "A_ThreadIndex", "A_TaskID", "A_JobID", "A_EventIndex", "A_MessageID", "A_PacketNumber", "A_FrameCounter", "A_TickCount", "A_Cycle", "A_Phase", "A_Stage", "A_Section", "A_Chapter", "A_Verse", "A_Paragraph", "A_Sentence", "A_WordIndex", "A_LetterIndex", "A_ByteOffset", "A_BlockNum", "A_SectorID", "A_ClusterRef", "A_PageIndex", "A_BufferSlot", "A_StackPointer", "A_HeapMarker", "A_RegistryKey", "A_UserID", "A_SessionCounter", "A_TransactionNum", "A_OrderID", "A_ProductID", "A_CustomerID", "A_EmployeeIndex", "A_StudentId", "A_CourseNum", "A_BookMark", "A_ReferenceId", "A_PointerVal", "A_HandleId", "A_SocketIndex", "A_PortNum", "A_ChannelId", "A_StreamPosition", "A_ResourceIndex", "A_AssetId", "A_ComponentRef", "A_EntityNum", "A_SpriteIndex", "A_TileCoord", "A_VertexId", "A_PolygonIndex", "A_PixelRow", "A_PixelCol", "A_ColorIndex", "A_PaletteRef", "A_SoundIndex", "A_MusicTrack", "A_EffectSlot", "A_ButtonId", "A_MenuIndex", "A_WindowHandle", "A_ControlId", "A_FormElementIndex", "A_DatabaseRow", "A_QueryIndex", "A_ResultOffset", "A_ReportSectionNum", "A_LogEntryId", "A_BackupVersion", "A_RevisionNum", "A_CommitCounter", "A_BranchIndex", "A_TagID", "A_VersionMarker", "idx", "i", "j", "k", "count", "counter", "iter", "loopVar", "LoopCount", "itemNum", "elementNo", "SeqNum", "RecCount", "FilePos", "TheIndex", "MyLoopIter", "ItemPointer", "CursorPosition", "StepValue", "B_Index", "C_Iter", "D_Count", "E_Pos", "F_idx", "G_i", "H_k", "I_n", "J_Counter", "K_Var", "L_LoopVar", "M_Tracker", "N_Pointer", "O_Seq", "P_Current", "Q_Num", "R_Step", "S_PosVal", "T_IterVal", "U_IndexVal", "V_LoopCounter", "W_LoopNumber", "X_ItemIndex", "Y_ElementIndex", "Z_RecordIndex", "AlphaIdx", "BetaCount", "GammaIter", "DeltaPos", "EpsilonNum", "ZetaSeq", "EtaStep", "ThetaTracker", "IotaPointer", "KappaLoopVar", "LambdaCurrent", "MuItemNum", "NuElementNo", "XiSeqNum", "OmicronRecCount", "PiFilePos", "RhoLoopCount", "SigmaIterVal", "TauIndexVal", "UpsilonCursor", "PhiStepValue", "ChiItemPointer", "PsiElementCounter", "OmegaLoopIter", "IteratorMan", "CountMaster", "IndexKing", "LoopBoss", "NumberCruncher", "PositionFinder", "StepSkipper", "SequenceSorcerer", "OrdinalOracle", "RankRanger", "RowRider", "ColumnCommander", "DepthDiver", "LevelLeaper", "FileFinger", "LineLiner", "CharChaser", "ItemInspector", "RecordRuler", "NodeNavigator", "ArrayArtist", "ListLifter", "MapMaestro", "ProcessPilot", "ThreadTamer", "TaskTrackerPrime", "JobJuggler", "EventExplorer", "MessageMover", "PacketPicker", "FrameFollower", "TickTock", "CycleChief", "PhasePhantom", "StageStomper", "SectionSeeker", "ChapterChampion", "VerseVoyager", "ParagraphPilot", "SentenceScanner", "WordWizard", "LetterLasso", "ByteBoss", "BlockBuilder", "SectorSleuth", "ClusterCrusader", "PageProwler", "BufferBuddy", "StackStalker", "HeapHero", "RegistryRanger", "UserEnumerator", "SessionScribe", "TransactionTracer", "OrderOriginator", "ProductPickerPrime", "CustomerCounter", "EmployeeEnumerator", "StudentScanner", "CourseCataloger", "BookMarkBuddy", "ReferenceRanger", "PointerPro", "HandleHolder", "SocketSelector", "PortPilot", "ChannelChallenger", "StreamSeeker", "ResourceRanger", "AssetAccountant", "ComponentCommander", "EntityEnumerator", "SpriteScanner", "TileTracker", "VertexValidator", "PolygonPilot", "PixelPusherRow", "PixelPusherCol", "ColorCoder", "PalettePicker", "SoundSelector", "MusicMaestro", "EffectEnabler", "ButtonBasher", "MenuMover", "WindowWrangler", "ControlCrusader", "FormFollower", "DatabaseDigger", "QueryQuester", "ResultRetriever", "ReportRuler", "LogLogger", "BackupBuddy", "RevisionRanger", "CommitCounterPrime", "BranchBoss", "TagTracker", "VersionValidator", "LoopDeLoop", "CountVonCount", "IndexDex", "IterNation", "StepMasterFlex"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; Function to generate a random "sane" name for A_LoopField alternatives (UNCHANGED HELPER)
func str GetRandomSaneLoopFieldName() {
    arr str saneNames := ["A_Item", "A_FieldVal", "A_Value", "A_LoopData", "A_Element", "LoopFieldContent", "CurrentValue", "A_Content", "A_EntryData", "A_RecordData", "A_TextSegment", "A_Datum", "A_Token", "A_Word", "A_Line", "A_Character", "A_Byte", "A_Block", "A_Sector", "A_Cluster", "A_PageContent", "A_BufferData", "A_StackItem", "A_HeapObject", "A_RegistryValue", "A_UserField", "A_SessionData", "A_TransactionDetail", "A_OrderItem", "A_ProductInfo", "A_CustomerDetail", "A_EmployeeData", "A_StudentInfo", "A_CourseMaterial", "A_BookContent", "A_ReferenceValue", "A_PointerTarget", "A_HandleInfo", "A_SocketData", "A_PortInfo", "A_ChannelContent", "A_StreamData", "A_ResourceValue", "A_AssetData", "A_ComponentState", "A_EntityAttribute", "A_SpriteData", "A_TileInfo", "A_VertexValue", "A_PolygonData", "A_PixelValue", "A_ColorData", "A_PaletteEntry", "A_SoundClip", "A_MusicData", "A_EffectParam", "A_ButtonText", "A_MenuItemLabel", "A_WindowTitle", "A_ControlValue", "A_FormData", "A_DatabaseField", "A_QueryResult", "A_ReportData", "A_LogMessage", "A_BackupFileContent", "A_RevisionData", "A_CommitMessage", "A_BranchInfo", "A_TagValue", "A_VersionDetail", "item", "element", "value", "data", "field", "record", "entry", "txt", "segment", "loopItem", "CurrentData", "FieldValue", "ItemContent", "ElementInfo", "RecordEntry", "EntryDetail", "MyItem", "TheValue", "ThisData", "AnElement", "SomeField", "MyRecord", "TheEntry", "ThisText", "AContent", "CurrentFieldVal", "IteratedContent", "FetchedRecord", "ParsedData", "LoopFieldData", "DataElement", "B_Item", "C_Value", "D_Data", "E_Field", "F_Record", "G_Entry", "H_Text", "I_Content", "J_Element", "K_LoopData", "L_CurrentVal", "M_Segment", "N_Token", "O_Word", "P_Line", "Q_Datum", "R_AssetInfo", "S_ComponentData", "T_EntityVal", "U_SpriteInfo", "V_TileData", "W_VertexData", "X_PolygonInfo", "Y_PixelData", "Z_ColorValue", "AlphaItem", "BetaValue", "GammaData", "DeltaField", "EpsilonRecord", "ZetaEntry", "EtaText", "ThetaContent", "IotaElement", "KappaLoopData", "LambdaCurrentVal", "MuSegment", "NuToken", "XiWord", "OmicronLine", "PiDatum", "RhoAssetInfo", "SigmaComponentData", "TauEntityVal", "UpsilonSpriteInfo", "PhiTileData", "ChiVertexData", "PsiPolygonInfo", "OmegaPixelData", "ItemDude", "ValueGal", "DataMan", "FieldFinder", "RecordKeeper", "EntryExplorer", "TextTwister", "ContentCollector", "ElementExtractor", "LoopLoot", "CurrentCargo", "SegmentSnatcher", "TokenTaker", "WordWrangler", "LineLifter", "DatumDigger", "AssetAccessor", "ComponentCatcher", "EntityExaminer", "SpriteScannerPrime", "TileTaster", "VertexVoyager", "PolygonPicker", "PixelProfiler", "ColorCollector", "PaletteProber", "SoundSniffer", "MusicMiner", "EffectEvaluator", "ButtonLabel", "MenuItemMagician", "WindowTitleWizard", "ControlContent", "FormFiller", "DatabaseDiver", "QueryQuesterPrime", "ResultReader", "ReportRenderer", "LogLine", "BackupBlob", "RevisionReader", "CommitComment", "BranchBuddy", "TagText", "VersionValue", "TheGoods", "WhatYouGot", "CurrentStuff", "LoopOutput", "FieldOfDreams"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; Function to generate a gibberish, but valid, variable name (general purpose) (UNCHANGED HELPER)
func str GenerateGibberishName(int minLen, int maxLen) {
    str name := ""
    str firstChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    str otherChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
    int len := Random(minLen, maxLen)
    if (len <= 0) {
        return "gib_err"
    }
    name .= SubStr(firstChars, Random(1, StrLen(firstChars)), 1)
    Loop, % (len - 1) {
        name .= SubStr(otherChars, Random(1, StrLen(otherChars)), 1)
    }
    return name
}

; UPDATED function to generate A_Index and A_LoopField variants with mode control
func arr str GenerateLoopVariableNames(int generationMode := 0) {
    str indexNameFinal
    str loopFieldNameFinal
    arr str returnArray
    if (generationMode = 1) {
        indexNameFinal := "A_Index"
        loopFieldNameFinal := "A_LoopField"
    } else if (generationMode = 2) {
        indexNameFinal := GetRandomSaneIndexName()
        loopFieldNameFinal := GetRandomSaneLoopFieldName()
    } else if (generationMode = 3) {
        indexNameFinal := GenerateGibberishName(2, 20)
        loopFieldNameFinal := GenerateGibberishName(2, 20)
    } else {
        if (Random(1, 100) <= 10) {
            indexNameFinal := "A_Index"
            loopFieldNameFinal := "A_LoopField"
            returnArray.add(indexNameFinal)
            returnArray.add(loopFieldNameFinal)
            return returnArray
        }
        if (Random(1, 100) <= 10) {
            indexNameFinal := "A_Index"
        } else {
            if (Random(1, 100) <= 20) {
                indexNameFinal := GenerateGibberishName(2, 20)
            } else {
                indexNameFinal := GetRandomSaneIndexName()
            }
        }
        if (Random(1, 100) <= 10) {
            loopFieldNameFinal := "A_LoopField"
        } else {
            if (Random(1, 100) <= 20) {
                loopFieldNameFinal := GenerateGibberishName(2, 20)
            } else {
                loopFieldNameFinal := GetRandomSaneLoopFieldName()
            }
        }
    }
    returnArray.add(indexNameFinal)
    returnArray.add(loopFieldNameFinal)
    return returnArray
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start of Increment/Decrement Keyword Generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function to generate a random "sane" increment keyword (UNCHANGED HELPER)
func str GetRandomSaneIncrementKeyword() {
    arr str saneNames := ["inc", "addOne", "plusUp", "incrementValue", "StepUp", "NextVal", "Advance", "IncrementBy1", "UpTick", "LevelUp", "Boost", "PlusOne", "IncVal", "GoUp", "Forward", "Proceed", "Augment", "Raise", "Elevate", "Progress", "Gain", "Accrue", "PlusIt", "OneMore", "TickForward", "AdvanceCounter", "IncrementCounter", "StepForward", "NextNumber", "ValueUp", "Bump", "NudgeUp", "IncByOne", "SumOne", "AddTo", "Grow", "Enlarge", "ExpandVal", "ScalarUp", "NumericUp", "CountUp", "IterateForward", "SequenceNext", "ProgressValue", "IncrementStep", "ForwardMarch", "PlusPlusCustom", "IncreaseAmount", "AddQuantity", "LiftValue", "HikeValue", "SurgeValue", "RiseValue", "AmplifyVal", "EscalateVal", "MountUp", "ShootUp", "SpringUp", "VaultUp", "AscendVal", "ClimbVal", "SoarVal", "SkyrocketVal", "ZenithStep", "PeakPlus", "SummitInc", "ApexAdd", "CrestCount", "PinnaclePlus", "VertexInc", "TopTick", "MaxStep", "UltraInc", "MegaPlus", "GigaAdd", "TeraCount", "HyperIncrement", "SuperStep", "PowerUp", "ChargeUp", "EnergizePlus", "ActivateInc", "TriggerNext", "FireUp", "IgnitePlus", "LaunchInc", "BlastOffAdd", "AccelerateVal", "SpeedUp", "FastForwardStep", "QuickInc", "RapidPlus", "SwiftAdd", "NimbleCount", "AgileStep", "BriskInc", "FleetPlus", "VelocityUp", "MomentumInc", "ForceAdd", "ThrustUp", "ImpulsePlus", "PropelInc", "DriveForward", "PushValue", "ShoveUp", "HeavePlus", "HoistInc", "ElevatorUp", "EscalatorPlus", "StairwayInc", "LadderAdd", "RampUp", "InclinePlus", "UpgradeVal", "EnhanceStep", "RefineInc", "OptimizePlus", "PerfectAdd", "PolishUp", "SharpenInc", "HonePlus", "TuneUp", "CalibrateInc", "AdjustPlus", "FineTuneVal", "PrecisionStep", "AccuracyInc", "DotPlus", "CrossAdd", "CheckUp", "MarkInc", "ScorePlus", "PointAdd", "TallyUp", "RegisterInc", "LogPlus", "RecordAdd", "NotateUp", "DocumentInc", "ChartPlus", "GraphAdd", "PlotUp", "MapInc", "NavigateForward", "ExploreNext", "DiscoverPlus", "UncoverInc", "RevealAdd", "ExposeUp", "ManifestInc", "MaterializePlus", "GenerateNext", "CreateInc", "ProduceAdd", "FormUp", "ShapeInc", "BuildPlus", "ConstructAdd", "FabricateUp", "AssembleInc", "ComposePlus", "DesignNext", "ArchitectInc", "EngineerAdd", "DevelopUp", "EvolveInc", "MaturePlus", "RipenAdd", "BlossomUp", "FlowerInc", "SproutPlus", "GerminateAdd", "CultivateUp", "NurtureInc", "FosterPlus", "DevelopValue", "GrowValue", "AdvanceValue", "ProgressByOne", "StepValueUp", "NextInSequence", "IncrementOperator", "PlusOperator", "AddOp", "IncOp", "LevelUpPlayer", "ScorePoint", "GainLife", "ChargeBattery", "FillTank", "RaiseVolume", "BrightenScreen", "ZoomIn", "ExpandView", "NextChapter", "NextTrack", "SkipForward", "FastForwardMedia", "IncreaseSpeed", "AdvanceTurn", "NextLevelGame", "UnlockNext", "ProceedToNext", "OneStepMore", "PlusUltraMeme", "YeetUp", "ToTheMoon", "StonksGoUp", "BigBrainInc", "GalaxyBrainPlus", "ChadStep", "SigmaGrindInc", "WojakHappyPlus", "PepeThumbsUp", "DogeMuchIncrease", "ThisIsTheWayInc", "IncrementoPatronum", "WingardiumIncreosa", "ExpectoIncrementum", "AccioNextNumber", "UpAndAdam", "RiseAndShineInc", "GoForth", "OnwardsAndUpwards", "HigherGround", "ElevateMind", "PlusPositive", "AddJoy", "IncrementHappiness", "BoostMorale", "LevelUpLife", "AdvanceWisdom", "GainExperience", "ProgressJourney", "StepIntoFuture", "NextAdventure", "ForwardMomentum", "PositiveVibesInc", "GoodTimesPlus", "MakeItBetter", "ImproveScore", "OptimizeLife", "RefineCharacter", "HoneSkills", "SharpenWit", "TuneMind", "CalibrateSoul", "AdjustAttitude"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; Function to generate a random "sane" decrement keyword (UNCHANGED HELPER)
func str GetRandomSaneDecrementKeyword() {
    arr str saneNames := ["dec", "subOne", "minusDown", "decrementValue", "StepDown", "PrevVal", "Retreat", "DecrementBy1", "DownTick", "LevelDown", "Nerf", "MinusOne", "DecVal", "GoDown", "Backward", "Recede", "Diminish", "Reduce", "Lower", "Regress", "Lose", "Deplete", "MinusIt", "OneLess", "TickBackward", "RetreatCounter", "DecrementCounter", "StepBackward", "PrevNumber", "ValueDown", "Drop", "NudgeDown", "DecByOne", "SubtractOne", "TakeFrom", "Shrink", "Condense", "ContractVal", "ScalarDown", "NumericDown", "CountDown", "IterateBackward", "SequencePrev", "RegressValue", "DecrementStep", "BackwardMarch", "MinusMinusCustom", "DecreaseAmount", "SubtractQuantity", "LowerValue", "DipValue", "PlungeValue", "FallValue", "DampenVal", "AttenuateVal", "SubsideDown", "SinkDown", "DescendVal", "DeclineVal", "WaneVal", "EbbVal", "NadirStep", "TroughMinus", "BottomDec", "AbyssSub", "ValleyCount", "RecessMinus", "FloorDec", "MinStep", "UltraDec", "MegaMinus", "GigaSub", "TeraCountDown", "HyperDecrement", "SuperStepDown", "PowerDown", "DrainDown", "DepleteMinus", "DeactivateDec", "TriggerPrev", "DouseDown", "ExtinguishMinus", "LandDec", "ReturnToBaseSub", "DecelerateVal", "SlowDown", "RewindStep", "QuickDec", "RapidMinus", "SwiftSub", "LethargicCount", "SluggishStep", "LazyDec", "TardyMinus", "VelocityDown", "ResistanceDec", "BrakeSub", "HaltDown", "DragMinus", "ReelInDec", "PullValueBack", "ShoveDown", "LowerItMinus", "DepressDec", "BasementDown", "SubwayMinus", "DescenderSub", "DeclineMinus", "DowngradeVal", "DiminishStep", "SimplifyDec", "StreamlineMinus", "ReduceToMin", "BluntDown", "DullMinus", "DetuneDown", "MiscalibrateDec", "ReadjustMinus", "CoarseTuneVal", "RoughStep", "ImprecisionDec", "UncheckMinus", "EraseSub", "ClearDown", "UndoDec", "RevertMinus", "ResetToPrev", "RollbackSub", "RegressToLast", "BacktrackDec", "NavigateBackward", "ReturnPrev", "ConcealMinus", "HideDec", "ObscureSub", "CoverDown", "VanishDec", "DematerializeMinus", "DegeneratePrev", "DestroyDec", "DismantleSub", "DeconstructDown", "DisassembleDec", "DecomposeMinus", "UnravelPrev", "RegressToSimple", "DevolveDec", "WitherMinus", "DecaySub", "FadeDown", "ShrinkValue", "LessenValue", "RegressValueByOne", "StepValueDown", "PrevInSequence", "DecrementOperator", "MinusOperator", "SubOp", "DecOp", "LevelDownPlayer", "LosePoint", "LoseLife", "DrainBattery", "EmptyTank", "LowerVolume", "DimScreen", "ZoomOut", "ContractView", "PrevChapter", "PrevTrack", "SkipBackward", "RewindMedia", "DecreaseSpeed", "RegressTurn", "PrevLevelGame", "LockPrev", "ReturnToPrev", "OneStepLess", "MinusUltraMeme", "YeetDown", "ToTheCore", "StonksGoDown", "SmallBrainDec", "LocalBrainMinus", "VirginStepBack", "SigmaGrindDec", "WojakSadMinus", "PepeThumbsDown", "DogeMuchDecrease", "ThisIsNotTheWayDec", "DecrementoPatronum", "WingardiumDecreosa", "ExpectoDecrementum", "AccioPrevNumber", "FallAndRest", "FadeToBlackDec", "GoBack", "DownwardsAndBackwards", "LowerGround", "SimplifyMind", "MinusNegative", "SubtractSadness", "DecrementMisery", "NerfMorale", "LevelDownLife", "RegressWisdom", "LoseExperience", "RewindJourney", "StepIntoPast", "PreviousAdventure", "BackwardMomentum", "NegativeVibesDec", "BadTimesMinus", "MakeItWorse", "WorsenScore", "ComplicateLife", "ConfuseCharacter", "DullSkills", "BluntWit", "UntuneMind", "DecalibrateSoul", "WorsenAttitude"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; Function to generate operator-like gibberish (e.g., "+abc", "-xyz123") (UNCHANGED HELPER)
func str GenerateOperatorGibberishName(str prefix, int minTotalLen, int maxTotalLen) {
    str name := prefix
    str validChars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
    if (minTotalLen = 1 and prefix != "") {
        if (Random(0,1) = 0) {
            return prefix
        }
    }
    int remainingLen := Random(minTotalLen - 1, maxTotalLen - 1)
    if (prefix = "") {
        remainingLen := Random(minTotalLen, maxTotalLen)
    }
    if (prefix != "" and remainingLen <= 0) {
        remainingLen := 1
    }
    if (prefix = "" and remainingLen < minTotalLen ) {
         remainingLen := minTotalLen
    }
    if (remainingLen <= 0 and minTotalLen > 0) {
        remainingLen := 1
    }
    Loop, % remainingLen {
        name .= SubStr(validChars, Random(1, StrLen(validChars)), 1)
    }
    return name
}

; UPDATED function to generate Increment and Decrement keywords with mode control
func arr str GenerateIncrementDecrementKeywords(int generationMode := 0) {
    str incrementKeyword
    str decrementKeyword
    arr str returnArray
    if (generationMode = 1) {
        incrementKeyword := "++"
        decrementKeyword := "--"
    } else if (generationMode = 2) {
        incrementKeyword := GetRandomSaneIncrementKeyword()
        decrementKeyword := GetRandomSaneDecrementKeyword()
    } else if (generationMode = 3) {
        incrementKeyword := GenerateOperatorGibberishName("+", 2, 20)
        decrementKeyword := GenerateOperatorGibberishName("-", 2, 20)
    } else {
        if (Random(1, 100) <= 50) {
            incrementKeyword := "++"
            decrementKeyword := "--"
        } else {
            if (Random(1, 100) <= 20) {
                incrementKeyword := GenerateOperatorGibberishName("+", 2, 20)
            } else {
                incrementKeyword := GetRandomSaneIncrementKeyword()
            }
            if (Random(1, 100) <= 20) {
                decrementKeyword := GenerateOperatorGibberishName("-", 2, 20)
            } else {
                decrementKeyword := GetRandomSaneDecrementKeyword()
            }
        }
    }
    returnArray.add(incrementKeyword)
    returnArray.add(decrementKeyword)
    return returnArray
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start of Ternary Operator Keyword Generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Function to generate a random "sane" keyword for the first ternary operator (?)
func str GetRandomSaneTernary1Keyword() {
    arr str saneNames := ["then", "ifTrue", "whenTrue", "isTrue", "trueCase", "consequent", "resultIfTrue", "outcome1", "positiveBranch", "yesPath", "affirmative", "doThis", "optionA", "firstChoice", "mainPath", "primaryResult", "directOutcome", "ifCondition", "queryThen", "checkThen", "evalTrue", "yieldTrue", "returnTrue", "getTrueVal", "trueValueIs", "TheResultIs", "PickThis", "ChooseA", "SelectIfTrue", "TrueBranchSelect", "ConditionalThen", "QueryResponse", "AskThenGive", "TruthValue", "LogicTrue", "BooleanYes", "ConfirmThen", "VerifyResult", "ValidateTrue", "IsTrueReturn", "IfYes", "ThenWhat", "Result1", "Path1", "Output1", "BranchA", "CaseTrue", "Scenario1", "PossibilityA", "Alternative1", "RouteOne", "FirstOption", "MainOutcome", "ConsequenceTrue", "PositiveResult", "TrueOutcome", "TruthPath", "AffirmativeOutcome", "DoThisPath", "ChooseThisOne", "SelectA", "TakeTrue", "TrueResultSelected", "YieldThis", "ReturnResultA", "GetValueA", "TrueExpression", "TheAnswerIs", "ThisWay", "PathYes", "BranchConfirm", "CheckMark", "ThumbsUpPath", "GoRoute", "ProceedPath", "FlowA", "StreamTrue", "ChannelYes", "PipeA", "OutputTrue", "SendTrue", "EmitYes", "ProduceA", "GenerateTrue", "CreateOptionA", "FormTrue", "ShapeResult1", "BuildBranchA", "ConstructCaseTrue", "FabricateScenario1", "AssemblePossibilityA", "ComposeAlternative1", "DesignRouteOne", "ArchitectFirstOption", "EngineerMainOutcome", "DevelopConsequenceTrue", "EvolvePositiveResult", "MatureTrueOutcome", "RipenTruthPath", "BlossomAffirmativeOutcome", "FlowerDoThisPath", "SproutChooseThisOne", "GerminateSelectA", "CultivateTakeTrue", "NurtureTrueResultSelected", "FosterYieldThis", "DevelopReturnResultA", "GrowGetValueA", "AdvanceTrueExpression", "ProgressTheAnswerIs", "StepThisWay", "NextPathYes", "ForwardBranchConfirm", "OnwardCheckMark", "HigherThumbsUpPath", "ElevateGoRoute", "LiftProceedPath", "RaiseFlowA", "AmplifyStreamTrue", "BoostChannelYes", "AugmentPipeA", "EnhanceOutputTrue", "OptimizeSendTrue", "RefineEmitYes", "SharpenProduceA", "HoneGenerateTrue", "TuneCreateOptionA", "CalibrateFormTrue", "AdjustShapeResult1", "PrecisionBuildBranchA", "AccuracyConstructCaseTrue", "ValidateFabricateScenario1", "VerifyAssemblePossibilityA", "ConfirmComposeAlternative1", "CheckDesignRouteOne", "TestArchitectFirstOption", "ProbeEngineerMainOutcome", "QueryDevelopConsequenceTrue", "AskEvolvePositiveResult", "InquireMatureTrueOutcome", "QuestionRipenTruthPath", "ExamineBlossomAffirmative", "InspectFlowerDoThisPath", "ScrutinizeSproutChooseOne", "AnalyzeGerminateSelectA", "DissectCultivateTakeTrue", "UnpackNurtureTrueResult", "DecodeFosterYieldThis", "DecipherDevelopReturnResultA", "InterpretGrowGetValueA", "UnderstandAdvanceTrueExpr", "GraspProgressTheAnswerIs", "ComprehendStepThisWay", "ApprehendNextPathYes", "PerceiveForwardBranchConf", "SenseOnwardCheckMark", "FeelHigherThumbsUpPath", "ImagineElevateGoRoute", "VisualizeLiftProceedPath", "PictureRaiseFlowA", "EnvisionAmplifyStreamTrue", "DreamBoostChannelYes", "FantasiizeAugmentPipeA", "SupposeEnhanceOutputTrue", "AssumeOptimizeSendTrue", "PresumeRefineEmitYes", "TheorizeSharpenProduceA", "HypothesizeHoneGenerateTrue", "PositTuneCreateOptionA", "PostulateCalibrateFormTrue", "ConjectureAdjustShapeResult1", "GuessPrecisionBuildBranchA", "SurmiseAccuracyConstructTrue", "InferValidateFabricateScen1", "DeduceVerifyAssemblePoss", "ReasonConfirmComposeAlt1", "LogicCheckDesignRouteOne", "CogitateTestArchitectFirst", "PonderProbeEngineerMain", "MuseQueryDevelopConsequence", "ReflectAskEvolvePositive", "MeditateInquireMatureTrue", "ContemplateQuestionRipen", "DeliberateExamineBlossom", "ConsiderInspectFlowerDo", "WeighScrutinizeSprout", "JudgeAnalyzeGerminate", "AssessDissectCultivate", "EvaluateUnpackNurture", "AppraiseDecodeFoster", "ReckonDecipherDevelop", "CalculateInterpretGrow", "ComputeUnderstandAdvance", "TallyGraspProgress", "SumComprehendStep", "TotalApprehendNext", "AggregatePerceiveForward", "SynthesizeSenseOnward", "CombineFeelHigher", "IntegrateImagineElevate", "UnifyVisualizeLift", "ConsolidatePictureRaise", "MergeEnvisionAmplify", "BlendDreamBoost", "FuseFantasiizeAugment", "JoinSupposeEnhance", "LinkAssumeOptimize", "ConnectPresumeRefine", "CoupleTheorizeSharpen", "PairHypothesizeHone", "MatchPositTune", "AlignPostulateCalibrate", "SynchronizeConjectureAdjust", "CoordinateGuessPrecision", "OrganizeSurmiseAccuracy", "StructureInferValidate", "SystematizeDeduceVerify", "ArrangeReasonConfirm", "OrderLogicCheck", "SequenceCogitateTest", "MarshalPonderProbe", "GroupMuseQuery", "CategorizeReflectAsk", "ClassifyMeditateInquire", "SortContemplateQuestion"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; Function to generate a random "sane" keyword for the second ternary operator (:)
func str GetRandomSaneTernary2Keyword() {
    arr str saneNames := ["else", "ifFalse", "whenFalse", "isFalse", "falseCase", "alternative", "resultIfFalse", "outcome2", "negativeBranch", "noPath", "negative", "doThat", "optionB", "secondChoice", "alternatePath", "secondaryResult", "indirectOutcome", "elseCondition", "queryElse", "checkElse", "evalFalse", "yieldFalse", "returnFalse", "getFalseVal", "falseValueIs", "OtherwiseDo", "PickThat", "ChooseB", "SelectIfFalse", "FalseBranchSelect", "ConditionalElse", "ElseResponse", "AskThenDoOther", "FalsehoodValue", "LogicFalse", "BooleanNo", "DenyThen", "InvalidateResult", "ValidateFalse", "IsFalseReturn", "IfNo", "ElseWhat", "Result2", "Path2", "Output2", "BranchB", "CaseFalse", "Scenario2", "PossibilityB", "Alternative2", "RouteTwo", "SecondOption", "AlternateOutcome", "ConsequenceFalse", "NegativeResult", "FalseOutcome", "FalsehoodPath", "NegativeOutcome", "DoThatPath", "ChooseThatOne", "SelectB", "TakeFalse", "FalseResultSelected", "YieldThat", "ReturnResultB", "GetValueB", "FalseExpression", "TheOtherAnswer", "ThatWay", "PathNo", "BranchDeny", "CrossMark", "ThumbsDownPath", "StopRoute", "RecedePath", "FlowB", "StreamFalse", "ChannelNo", "PipeB", "OutputFalse", "SendFalse", "EmitNo", "ProduceB", "GenerateFalse", "CreateOptionB", "FormFalse", "ShapeResult2", "BuildBranchB", "ConstructCaseFalse", "FabricateScenario2", "AssemblePossibilityB", "ComposeAlternative2", "DesignRouteTwo", "ArchitectSecondOption", "EngineerAlternateOutcome", "DevelopConsequenceFalse", "EvolveNegativeResult", "MatureFalseOutcome", "RipenFalsehoodPath", "BlossomNegativeOutcome", "FlowerDoThatPath", "SproutChooseThatOne", "GerminateSelectB", "CultivateTakeFalse", "NurtureFalseResultSelect", "FosterYieldThat", "DevelopReturnResultB", "GrowGetValueB", "AdvanceFalseExpression", "ProgressTheOtherAnswer", "StepThatWay", "NextPathNo", "ForwardBranchDeny", "OnwardCrossMark", "HigherThumbsDownPath", "ElevateStopRoute", "LiftRecedePath", "RaiseFlowB", "AmplifyStreamFalse", "BoostChannelNo", "AugmentPipeB", "EnhanceOutputFalse", "OptimizeSendFalse", "RefineEmitNo", "SharpenProduceB", "HoneGenerateFalse", "TuneCreateOptionB", "CalibrateFormFalse", "AdjustShapeResult2", "PrecisionBuildBranchB", "AccuracyConstructCaseFalse", "ValidateFabricateScenario2", "VerifyAssemblePossibilityB", "ConfirmComposeAlternative2", "CheckDesignRouteTwo", "TestArchitectSecondOption", "ProbeEngineerAlternateOutcome", "QueryDevelopConsequenceFalse", "AskEvolveNegativeResult", "InquireMatureFalseOutcome", "QuestionRipenFalsehoodPath", "ExamineBlossomNegative", "InspectFlowerDoThatPath", "ScrutinizeSproutChooseThat", "AnalyzeGerminateSelectB", "DissectCultivateTakeFalse", "UnpackNurtureFalseResult", "DecodeFosterYieldThat", "DecipherDevelopReturnResB", "InterpretGrowGetValueB", "UnderstandAdvanceFalseExpr", "GraspProgressTheOtherAnswer", "ComprehendStepThatWay", "ApprehendNextPathNo", "PerceiveForwardBranchDeny", "SenseOnwardCrossMark", "FeelHigherThumbsDownPath", "ImagineElevateStopRoute", "VisualizeLiftRecedePath", "PictureRaiseFlowB", "EnvisionAmplifyStreamFalse", "DreamBoostChannelNo", "FantasiizeAugmentPipeB", "SupposeEnhanceOutputFalse", "AssumeOptimizeSendFalse", "PresumeRefineEmitNo", "TheorizeSharpenProduceB", "HypothesizeHoneGenerateFalse", "PositTuneCreateOptionB", "PostulateCalibrateFormFalse", "ConjectureAdjustShapeResult2", "GuessPrecisionBuildBranchB", "SurmiseAccuracyConstructFalse", "InferValidateFabricateScen2", "DeduceVerifyAssemblePossB", "ReasonConfirmComposeAlt2", "LogicCheckDesignRouteTwo", "CogitateTestArchitectSecond", "PonderProbeEngineerAlternate", "MuseQueryDevelopConsequenceF", "ReflectAskEvolveNegative", "MeditateInquireMatureFalse", "ContemplateQuestionRipenF", "DeliberateExamineBlossomNeg", "ConsiderInspectFlowerDoThat", "WeighScrutinizeSproutChoose", "JudgeAnalyzeGerminateSelectB", "AssessDissectCultivateTakeF", "EvaluateUnpackNurtureFalse", "AppraiseDecodeFosterYield", "ReckonDecipherDevelopReturn", "CalculateInterpretGrowValueB", "ComputeUnderstandAdvanceFalse", "TallyGraspProgressOther", "SumComprehendStepThatWay", "TotalApprehendNextPathNo", "AggregatePerceiveForwardDeny", "SynthesizeSenseOnwardCross", "CombineFeelHigherThumbsDown", "IntegrateImagineElevateStop", "UnifyVisualizeLiftRecede", "ConsolidatePictureRaiseFlowB", "MergeEnvisionAmplifyStreamF", "BlendDreamBoostChannelNo", "FuseFantasiizeAugmentPipeB", "JoinSupposeEnhanceOutputF", "LinkAssumeOptimizeSendF", "ConnectPresumeRefineEmitNo", "CoupleTheorizeSharpenProdB", "PairHypothesizeHoneGenerateF", "MatchPositTuneCreateOptionB", "AlignPostulateCalibrateFormF", "SynchronizeConjectureAdjustF", "CoordinateGuessPrecisionBuildB", "OrganizeSurmiseAccuracyConstF", "StructureInferValidateFabric2", "SystematizeDeduceVerifyAssB", "ArrangeReasonConfirmComposeA2", "OrderLogicCheckDesignRouteTwo", "SequenceCogitateTestArchSec", "MarshalPonderProbeEngineerAlt", "GroupMuseQueryDevelopConseqF", "CategorizeReflectAskEvolveN", "ClassifyMeditateInquireMatF", "SortContemplateQuestionRipenF"]
    int randomIndex := Random(0, saneNames.size() - 1)
    return saneNames[randomIndex]
}

; UPDATED function to generate Ternary Operator keyword variants with mode control
func arr str GenerateTernaryOperators(int generationMode := 0) {
    str ternary1Keyword
    str ternary2Keyword
    arr str returnArray

    if (generationMode = 1) {
        ternary1Keyword := "?"
        ternary2Keyword := ":"
    } else if (generationMode = 2) {
        ternary1Keyword := GetRandomSaneTernary1Keyword()
        ternary2Keyword := GetRandomSaneTernary2Keyword()
    } else if (generationMode = 3) {
        ternary1Keyword := GenerateGibberishName(2, 20)
        ternary2Keyword := GenerateGibberishName(2, 20)
    } else {
        if (Random(1, 100) <= 50) {
            ternary1Keyword := "?"
            ternary2Keyword := ":"
        } else {
            if (Random(1, 100) <= 20) {
                ternary1Keyword := GenerateGibberishName(2, 20)
            } else {
                ternary1Keyword := GetRandomSaneTernary1Keyword()
            }
            if (Random(1, 100) <= 20) {
                ternary2Keyword := GenerateGibberishName(2, 20)
            } else {
                ternary2Keyword := GetRandomSaneTernary2Keyword()
            }
        }
    }
    returnArray.add(ternary1Keyword)
    returnArray.add(ternary2Keyword)
    return returnArray
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Start of Assignment Operator Keyword Generation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; --- Helper functions for "sane" assignment operator keywords ---
func str GetRandomSane_Assign_Keyword() {
    arr str saneNames := ["assign", "set", "is", "becomes", "equals", "letBe", "store", "defineAs", "setTo", "make", "transfer", "copyTo", "initAs", "valueIs", "varIs", "dataIs", "bindTo", "linkTo", "holdVal", "giveVal", "acceptVal", "fixVal", "placeVal", "gets", "receives", "takes"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignAdd_Keyword() {
    arr str saneNames := ["addAssign", "plusEquals", "incrementBy", "addTo", "sumAssign", "increaseBy", "accumulate", "appendNum", "augAssign", "combineAdd", "mergeSum", "growBy", "extendSum", "amassAdd", "PlusEq", "sumTo", "tallyUp"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignConcat_Keyword() {
    arr str saneNames := ["concatAssign", "appendStr", "stringAdd", "dotEquals", "joinAssign", "textAppend", "mergeStr", "combineText", "chainStr", "linkText", "uniteStr", "fuseText", "weldStr", "CatEq", "stringJoin", "attachText"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignSub_Keyword() {
    arr str saneNames := ["subAssign", "minusEquals", "decrementBy", "subFrom", "deductAssign", "decreaseBy", "reduceBy", "diminishBy", "shrinkBy", "lessenBy", "withdrawFrom", "MinusEq", "takeAway", "deductFrom"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignMul_Keyword() {
    arr str saneNames := ["mulAssign", "timesEquals", "multiplyBy", "scaleBy", "productAssign", "factorAssign", "amplifyBy", "magnifyBy", "replicateBy", "TimesEq", "MultEq", "productIs"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignDiv_Keyword() {
    arr str saneNames := ["divAssign", "divideEquals", "divideBy", "ratioAssign", "quotientAssign", "shareBy", "splitBy", "partitionBy", "DivEq", "SlashEq", "quotientIs"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignMod_Keyword() {
    arr str saneNames := ["modAssign", "moduloEquals", "remainderAssign", "modBy", "cycleAssign", "wrapAssign", "ModEq", "RemEq", "PercentEq", "moduloIs"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignShiftLeft_Keyword() {
    arr str saneNames := ["shiftLAssign", "lshEquals", "bitShiftLStore", "moveBitsLSet", "slideLStore", "LShiftEq", "LeftShiftAssign", "LSLset", "bitSlideL"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignShiftRight_Keyword() {
    arr str saneNames := ["shiftRAssign", "rshEquals", "bitShiftRStore", "moveBitsRSet", "slideRStore", "RShiftEq", "RightShiftAssign", "RSRset", "bitSlideR"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignUShiftRight_Keyword() {
    arr str saneNames := ["uShiftRAssign", "urshEquals", "logicShiftRStore", "zeroFillRSet", "positiveRStore", "URShiftEq", "UShiftAssign", "USRset", "logicSlideR"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignBitAnd_Keyword() {
    arr str saneNames := ["bitAndAssign", "andEquals", "maskAssign", "intersectStore", "filterAndSet", "BitAndEq", "AmpersandEq", "bitwiseAndSet"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignBitOr_Keyword() {
    arr str saneNames := ["bitOrAssign", "orEquals", "setBitsStore", "unionOrSet", "includeOrStore", "BitOrEq", "PipeEq", "bitwiseOrSet"]
    return saneNames[Random(0, saneNames.size() - 1)]
}
func str GetRandomSane_AssignBitXor_Keyword() {
    arr str saneNames := ["bitXorAssign", "xorEquals", "toggleBitsStore", "exclusiveOrSet", "flipBitsStore", "BitXorEq", "CaretEq", "bitwiseXorSet"]
    return saneNames[Random(0, saneNames.size() - 1)]
}

; Main function to generate all 13 assignment operator keywords based on mode
func arr str GenerateAllAssignmentOperators(int generationMode := 0) {
    arr str operatorKeywords
    str currentKeyword

    ; Define an array of default operators and their corresponding "sane" keyword getter functions
    ; This is a bit meta, but helps reduce repetition.
    ; We can't directly store function references in HTVM arrays, so we'll use names and a dispatcher or just inline.
    ; For simplicity here, I'll inline the logic, but a dispatcher would be cleaner for more ops.

    ; Operator 1: = (Assign)
    if (generationMode = 1) { currentKeyword := "=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_Assign_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else { ; Mode 0: Randomized
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_Assign_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 2: += (AssignAdd)
    if (generationMode = 1) { currentKeyword := "+=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignAdd_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "+=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignAdd_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 3: .= (AssignConcat)
    if (generationMode = 1) { currentKeyword := ".=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignConcat_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := ".=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignConcat_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 4: -= (AssignSub)
    if (generationMode = 1) { currentKeyword := "-=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignSub_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "-=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignSub_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 5: *= (AssignMul)
    if (generationMode = 1) { currentKeyword := "*=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignMul_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "*=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignMul_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 6: /= (AssignDiv)
    if (generationMode = 1) { currentKeyword := "/=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignDiv_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "/=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignDiv_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 7: %= (AssignMod)
    if (generationMode = 1) { currentKeyword := "%=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignMod_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "%=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignMod_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 8: <<= (AssignShiftLeft)
    if (generationMode = 1) { currentKeyword := "<<=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignShiftLeft_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(3, 10) } ; Min 3 for gibberish due to operator length
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "<<=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignShiftLeft_Keyword() }
        else { currentKeyword := GenerateGibberishName(3, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 9: >>= (AssignShiftRight)
    if (generationMode = 1) { currentKeyword := ">>=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignShiftRight_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(3, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := ">>=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignShiftRight_Keyword() }
        else { currentKeyword := GenerateGibberishName(3, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 10: >>>= (AssignUShiftRight)
    if (generationMode = 1) { currentKeyword := ">>>=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignUShiftRight_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(4, 10) } ; Min 4 for gibberish
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := ">>>=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignUShiftRight_Keyword() }
        else { currentKeyword := GenerateGibberishName(4, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 11: &= (AssignBitAnd)
    if (generationMode = 1) { currentKeyword := "&=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignBitAnd_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "&=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignBitAnd_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 12: |= (AssignBitOr)
    if (generationMode = 1) { currentKeyword := "|=" }
    else if (generationMode = 2) { currentKeyword := GetRandomSane_AssignBitOr_Keyword() }
    else if (generationMode = 3) { currentKeyword := GenerateGibberishName(2, 10) }
    else {
        int r := Random(1, 100)
        if (r <= 50) { currentKeyword := "|=" }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignBitOr_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    ; Operator 13: ^= (AssignBitXor)
    if (generationMode = 1) {
    currentKeyword := "^=" 
    }
    else if (generationMode = 2) {
    currentKeyword := GetRandomSane_AssignBitXor_Keyword() 
    }
    else if (generationMode = 3) { 
    currentKeyword := GenerateGibberishName(2, 10) 
    }
    else {
        int r := Random(1, 100)
        if (r <= 50) { 
        currentKeyword := "^=" 
        }
        else if (r <= 80) { currentKeyword := GetRandomSane_AssignBitXor_Keyword() }
        else { currentKeyword := GenerateGibberishName(2, 10) }
    }
    operatorKeywords.add(currentKeyword)

    return operatorKeywords
}


main
    ; --- Demonstrate Loop Variable Names with Modes ---
    print("--- Generating Loop Variable Name Variants (Mode Test) ---")
    arr str loopNames
    print("Mode 0 (Randomized):")
    loopNames := GenerateLoopVariableNames(0)
    print("  IndexName = '" . loopNames[0] . "', LoopFieldName = '" . loopNames[1] . "'")
    loopNames := GenerateLoopVariableNames()
    print("  IndexName = '" . loopNames[0] . "', LoopFieldName = '" . loopNames[1] . "'")
    print("Mode 1 (Defaults):")
    loopNames := GenerateLoopVariableNames(1)
    print("  IndexName = '" . loopNames[0] . "', LoopFieldName = '" . loopNames[1] . "'")
    print("Mode 2 (Random Sane):")
    loopNames := GenerateLoopVariableNames(2)
    print("  IndexName = '" . loopNames[0] . "', LoopFieldName = '" . loopNames[1] . "'")
    print("Mode 3 (Gibberish):")
    loopNames := GenerateLoopVariableNames(3)
    print("  IndexName = '" . loopNames[0] . "', LoopFieldName = '" . loopNames[1] . "'")
    print("-------------------------------------")
    print("A_Index = A_Index")
    print("A_LoopField = A_LoopField")
    print(";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;")

    ; --- Demonstrate Increment/Decrement Keywords with Modes ---
    print("--- Generating Increment/Decrement Keyword Variants (Mode Test) ---")
    arr str opKeywords
    print("Mode 0 (Randomized):")
    opKeywords := GenerateIncrementDecrementKeywords(0)
    print("  Increment = '" . opKeywords[0] . "', Decrement = '" . opKeywords[1] . "'")
    opKeywords := GenerateIncrementDecrementKeywords()
    print("  Increment = '" . opKeywords[0] . "', Decrement = '" . opKeywords[1] . "'")
    print("Mode 1 (Defaults):")
    opKeywords := GenerateIncrementDecrementKeywords(1)
    print("  Increment = '" . opKeywords[0] . "', Decrement = '" . opKeywords[1] . "'")
    print("Mode 2 (Random Sane):")
    opKeywords := GenerateIncrementDecrementKeywords(2)
    print("  Increment = '" . opKeywords[0] . "', Decrement = '" . opKeywords[1] . "'")
    print("Mode 3 (Gibberish):")
    opKeywords := GenerateIncrementDecrementKeywords(3)
    print("  Increment = '" . opKeywords[0] . "', Decrement = '" . opKeywords[1] . "'")
    print("-------------------------------------")

    ; --- Demonstrate Ternary Operators with Modes ---
    print("--- Generating Ternary Operator Variants (Mode Test) ---")
    arr str ternaryOps
    print("Mode 0 (Randomized):")
    ternaryOps := GenerateTernaryOperators(0)
    print("  Op1 = '" . ternaryOps[0] . "', Op2 = '" . ternaryOps[1] . "'")
    ternaryOps := GenerateTernaryOperators()
    print("  Op1 = '" . ternaryOps[0] . "', Op2 = '" . ternaryOps[1] . "'")
    print("Mode 1 (Defaults):")
    ternaryOps := GenerateTernaryOperators(1)
    print("  Op1 = '" . ternaryOps[0] . "', Op2 = '" . ternaryOps[1] . "'")
    print("Mode 2 (Random Sane):")
    ternaryOps := GenerateTernaryOperators(2)
    print("  Op1 = '" . ternaryOps[0] . "', Op2 = '" . ternaryOps[1] . "'")
    print("Mode 3 (Gibberish):")
    ternaryOps := GenerateTernaryOperators(3)
    print("  Op1 = '" . ternaryOps[0] . "', Op2 = '" . ternaryOps[1] . "'")
    print("-------------------------------------")

    ; --- Demonstrate Assignment Operator Keywords with Modes ---
    print("--- Generating Assignment Operator Keyword Variants (Mode Test) ---")
    arr str assignmentOpsGenerated
    arr str defaultOperatorSymbols := ["=", "+=", ".=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^="]
    
    print("Mode 0 (Randomized):")
    assignmentOpsGenerated := GenerateAllAssignmentOperators(0)
    Loop, % assignmentOpsGenerated.size() {
        print("  " . defaultOperatorSymbols[A_Index] . " -> '" . assignmentOpsGenerated[A_Index] . "'")
    }
    assignmentOpsGenerated := GenerateAllAssignmentOperators() ; Another randomized call
    Loop, % assignmentOpsGenerated.size() {
        print("  " . defaultOperatorSymbols[A_Index] . " -> '" . assignmentOpsGenerated[A_Index] . "' (2nd random call)")
    }
    
    print("Mode 1 (Defaults):")
    assignmentOpsGenerated := GenerateAllAssignmentOperators(1)
    Loop, % assignmentOpsGenerated.size() {
        print("  " . defaultOperatorSymbols[A_Index] . " -> '" . assignmentOpsGenerated[A_Index] . "'")
    }
    
    print("Mode 2 (Random Sane):")
    assignmentOpsGenerated := GenerateAllAssignmentOperators(2)
    Loop, % assignmentOpsGenerated.size() {
        print("  " . defaultOperatorSymbols[A_Index] . " -> '" . assignmentOpsGenerated[A_Index] . "'")
    }
    
    print("Mode 3 (Gibberish):")
    assignmentOpsGenerated := GenerateAllAssignmentOperators(3)
    Loop, % assignmentOpsGenerated.size() {
        print("  " . defaultOperatorSymbols[A_Index] . " -> '" . assignmentOpsGenerated[A_Index] . "'")
    }
    print("-------------------------------------")


    ; --- GenerateRandomizedStates Output (Unchanged) ---
    arr str outArrFromStates
    outArrFromStates := GenerateRandomizedStates()
    print("--- Output from GenerateRandomizedStates (Unchanged Function) ---")
    Loop, % outArrFromStates.size() {
        print("State " . STR(A_Index) . ": " . outArrFromStates[A_Index])
    }
    print(";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;")
