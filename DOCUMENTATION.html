<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub-Style Markdown with Ace Editor</title>

    <!-- Link to markdown-it library -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@12.0.4/dist/markdown-it.min.js"></script>
    
    <!-- Ace Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/theme-monokai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/mode-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/mode-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/mode-html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/mode-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.9.6/mode-json.min.js"></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <style>
        /* Dark Mode Styles */
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            padding-left: 30px;
            padding-right: 30px;
            margin: 0;
            word-wrap: break-word;
        }

        h1, h2, h3, h4, h5, h6 {
            color: #ffffff;
            position: relative;
        }

        /* Container for the markdown content */
        #markdown-output {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 30px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Header Styling */
        h1 {
            font-size: 2.5em;
            border-bottom: 2px solid #444;
            padding-bottom: 10px;
        }

        h2 {
            color: #ffffff;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        h3 {
            color: #81a1c1;
            margin-top: 20px;
        }

        /* Links */
        a {
            color: #1e90ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* External link icon */
        a.external-link:after {
            content: " \2197";
            display: inline-block;
            margin-left: 4px;
            font-size: 0.8em;
        }
        
        /* Header anchor links that show on hover */
        .header-anchor {
            opacity: 0;
            font-size: 0.8em;
            margin-left: 8px;
            color: #666;
            transition: opacity 0.2s ease-in-out;
        }
        
        h1:hover .header-anchor,
        h2:hover .header-anchor,
        h3:hover .header-anchor,
        h4:hover .header-anchor,
        h5:hover .header-anchor,
        h6:hover .header-anchor {
            opacity: 1;
            color: #1e90ff;
        }

        /* Ace Editor Styling */
        .ace-editor-container {
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .ace-editor {
            width: 100%;
            border-radius: 8px;
            /* Height will be set dynamically based on content */
        }
        
        .ace-editor-header {
            background-color: #333;
            color: #fff;
            padding: 8px 15px;
            font-family: monospace;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }
        
        .ace-editor-language {
            font-weight: bold;
            color: #82aaff;
        }

        /* Copy Button Styling */
        .copy-button {
            background-color: #2a2a2a;
            border: none;
            color: #ccc;
            border-radius: 4px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
        }
        
        .copy-button:hover {
            background-color: #3a3a3a;
            color: #fff;
        }
        
        .copy-button i {
            margin-right: 4px;
        }
        
        .copy-success {
            background-color: #28a745 !important;
            color: white !important;
        }

        /* Inline code */
        p code, li code {
            background-color: #2b2b2b;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: Consolas, 'Courier New', monospace;
        }

        /* Table Styling */
        table {
            width: 100%;
            margin: 20px 0;
            border-collapse: collapse;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border: 1px solid #444;
        }

        th {
            background-color: #333;
        }

        tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        tr:hover {
            background-color: #444;
        }
        
        /* Fix for internal links */
        :target {
            scroll-margin-top: 20px;
            animation: highlight 2s ease;
        }
        
        @keyframes highlight {
            from { background-color: #333333; }
            to { background-color: transparent; }
        }
    </style>
</head>
<body>

    <!-- Markdown content written in normal syntax -->
<div id="markdown-content" style="display:none;">


# HTVM Documentation


1. [Introduction](#introduction-to-htvm)  
Understand why HTVM is the future of programming.

2. [OSP (Ordinal Struct Programming)](#osp-ordinal-struct-programming)  
Learn about OSP (Ordinal Struct Programming) a new way to use Structs.

3. [How Your Language Looks Like](#how-your-language-looks-like)  
Get to know how HTVM code is structured and its syntax style.

4. [Programming Blocks](#programming-blocks)  
HTVM introduces **programming blocks** that allow you to code in the target language seamlessly in your code. This feature is designed to handle cases where HTVM itself can't achieve something directly or when you'd prefer to rely on another language for specific tasks.

5. [Variables](#variables)  
Learn how to declare and use variables in HTVM for storing and manipulating data.

6. [Functions](#functions)  
Explore how to define and use functions for modular and reusable code.

7. [Arrays](#arrays)  
Dive into working with arrays, one of the most essential data structures in HTVM.

8. [Loops](#loops)  
Master the looping structures available in HTVM, such as the standard loop and infinite loops.

9. [Comments](#comments)  
Add clarity to your code by using comments to document and explain your code.

10. [Error Handling](#error-handling)  
Understand how to manage errors and handle exceptions in HTVM to make your programs more robust.

11. [Include](#include)  
Discover how to include external files and resources in your HTVM project for enhanced functionality.

12. [Commands](#commands)  
Commands in HTVM are a simplified way to perform actions, similar to functions, but with a more compact, direct, and concise syntax for better efficiency.

13. [All Syntax](#all-syntax)  
This is all of your syntax.

14. [Built-in Functions](#built-in-functions)  
Explore the wide range of built-in functions categorized for ease of use.

---

## Introduction to HTVM

[Go back](#htvm-documentation) 

HTVM is a revolutionary tool designed to replace traditional programming. With HTVM, you can create your own programming language directly [here](https://themaster1127.github.io/HTVM/).


HTVM offers **extensive syntax customization**, giving you the freedom to tailor the language structure to your own preferences. Almost all of these customizations can be converted into 15 languages, providing flexibility while keeping things simple.

## Customization Features

### Code Block Delimiters

You can **customize the block delimiters**, which define the start and end of code blocks. You can use:

- Curly braces `{}` (default).
- **Other characters**, words, or even single letters, as long as the opening and closing delimiters are different from each other.

### Indentation Styles

You have the ability to choose between multiple **indentation styles**:

- **Pythonic indentation style**: This removes the need for block delimiters like curly braces, relying on indentation to define code blocks.
- **Lua indentation style**: Uses the customizable `end` keyword to close code blocks.

Both styles are fully customizable, and you can define your own keyword for closing blocks (such as `end`, or any other word).

### Toggleable Semicolons

Semicolons are **toggleable** in HTVM. By default, semicolons are not required to terminate statements, but you can enable the use of semicolons if you prefer them in your syntax. It's completely up to you whether or not to use them in your code.

### Parentheses Customization

For **conditional statements** like `if`, `else if`, and `while` loops, you can choose to **use or omit parentheses** around conditions. This customization allows you to streamline your code and make it more intuitive according to your preferences.

### Customizable Operators

HTVM allows you to **customize operators** to make your code more readable or suit your style. For example, instead of using `==` for equality, you can change it to a keyword like `is`. This means you can write more natural, human-readable code, such as:

- `if var1 is 5` (instead of `if var1 == 5`).

This flexibility extends across various operators, giving you full control over how your conditions and operations are structured.


## More Customization Options in HTVM

HTVM offers even **more customization** for your syntax and style. Here's a breakdown of additional features:

### Type Definition Styles

You can choose between **PostFix** or **Prefix** style for type definitions, similar to TypeScript:

- **PostFix**: Define the variable first, then the type after the colon (`var1: int`).
- **Prefix**: Define the type first, then the variable (`int var1`).

You can toggle between these styles depending on which one fits your preferred syntax better.

### Array Syntax Customization

HTVM lets you customize the array syntax by choosing between two options:

- **Regular braces** (`[]`): The default style for arrays.
- **Curly braces** (`{}`): If you prefer this style, you can toggle it on.

It's fully flexible, so you can use whichever syntax feels right for your code.

### Customizable Operators

HTVM extends **operator customizability** even further, allowing you to adjust a wide range of operators:

- **All operators**: You can customize **all operators**, including logical, comparison, and even **bitwise operators**.
- **Assignment operators**: You can customize assignment operators, such as `=`, to whatever you prefer (e.g., `is`, `set`, or any other single word).

However, remember that you are only allowed to use **one word** for customization—no spaces in operator names.

### Customizable Comments

Comments are also fully customizable:

- **Single-line comments**: Change the single-line comment syntax to whatever you like (e.g., `//`, `#`, or any word).
- **Multi-line comments**: Customize the syntax for multi-line comments, allowing for multiple words or characters if necessary.

### Custom Escape Characters

Escape characters can now be **customized**:

- **Escape character**: You are no longer limited to using just the backslash (`\`). You can choose any single character you want as your escape character—such as the backtick (`` ` ``) or something entirely different.

### Loop Index Customization

You can **change the index for regular loops**. By default, HTVM uses **zero-based indexing** for loops. However, you can change this for certain languages:

- **AutoHotKey and Lua**: By default, both of these languages use **one-based indexing** for arrays and loops.
- **Other languages**: It's important to note that **changing loop indices may cause issues** with some languages, as not all languages support customizable loop indexes. **Use caution** when making changes to this setting, especially when working with languages like Python, JavaScript, or C++.

HTVM allows for this change, but it’s recommended to keep the default zero-based indexing unless you’re specifically creating **meme languages** where the index may be something unconventional (like `-69` or `420`).

### Key Considerations for Indexing

- For **AutoHotKey** and **Lua**, the index starts at **one** by default.
- For **other languages**, **zero-based indexing** is the norm, so be mindful of this when converting to other languages.
  
If you are creating custom languages or experimenting with unconventional indexing, keep these limitations in mind to avoid potential issues when converting to other languages.

---


## Further Customization in HTVM

HTVM offers **even more customization options**, allowing you to tailor the language to your preferences, especially when it comes to types and arrays.

### Custom Type Names

HTVM allows you to **customize type names** to anything you like. For example:

- **Basic Types**: Instead of using the traditional `int`, you can use `number`, `i`, or any other word you prefer. The same goes for types like `double`, `char`, `boolean`, `float`, and more.
- **Integer Sizes**: You can change types like `int16` to `i16` or any naming convention you prefer.
  
**Important:** While you can use **multiple words** for type names, be cautious about potential conflicts in the parser. For instance, using common words that might be parsed as something else could lead to issues. Always ensure that the type names are unique and won't interfere with other syntax elements.

The available types you can customize include:

- **Void**: You can rename `void` to whatever you want.
- **Integers**: `int`, `int8`, `int16`, `int32`, `int64`, etc.
- **Unsigned Integers**: `uint8`, `uint16`, `uint32`, `uint64` (Note: be cautious when converting unsigned integers to Java, as Java doesn’t support them).
- **Floating Point**: `double`, `float`.
- **Character**: `char`.
- **String**: `string`.
- **Boolean**: `boolean`.

---

### Array Types Customization

In HTVM, you can customize the **array types** as well:

- **Four main array types**:
  - `arr str`: For arrays of strings.
  - `arr int`: For arrays of integers.
  - `arr float`: For arrays of floating-point numbers.
  - `arr bool`: For arrays of booleans.
  
- **Dynamic Arrays**: For dynamic-type languages, you can use the generic `array` keyword, but it defaults to a string array when converted to static type languages. This provides a flexible way to define arrays in your code.
  
**Note on Static vs. Dynamic Types**: In **static-type languages**, arrays are strictly defined, so if you use the `array` keyword, it will default to a **string array**. For **dynamic languages**, the array type is more flexible.

---

### Array Methods Customization

HTVM allows you to customize array methods with ease. These methods work by appending a dot (`.`) after the array, followed by the method name:

- **append**: Adds an element to the end of the array.
- **pop**: Removes the last element from the array.
- **size**: Retrieves the size (length) of the array.
- **insert**: Inserts an element at a specific index (not by value).
- **remove**: Removes an element at a specific index (not by value).
- **indexOf**: Finds the index of a value in the array.

These methods can be customized with different names or functionality if needed, making it easier to manipulate arrays according to your needs.

---

### Important Considerations

- **Java and Unsigned Integers**: Be careful when converting unsigned integers (`uint8`, `uint16`, etc.) to **Java**, as Java does not support unsigned integers. HTVM will **NOT** warn you when attempting this conversion.
- **Array Methods**: Ensure that you define methods like `insert` and `remove` clearly to avoid confusion with other types of array manipulations. Using the dot (`.`) ensures consistency and clarity in how methods are applied to arrays.

---

## Extensive Customization in HTVM

HTVM offers **wide-ranging customization options** to ensure the language suits your preferences, especially when it comes to keywords and functionality. You can customize several aspects of the language, ranging from basic variable declarations to control structures and even language-specific keywords.

### Customizing Keywords

HTVM allows you to customize many fundamental keywords that are used across different programming languages:

- **Variable Declarations**: Customize `var`, `let`, and `const` keywords. These are primarily used in **JavaScript** and **TypeScript**. 
  - The `const` keyword is supported in most languages, but in languages that don't have constants (e.g., **Python**, **AutoHotKey**, **Lua** and some more), it will be ignored, and the variable will be created as usual.
  
- **Boolean Keywords**: Change the `true` and `false` keywords to something else like `yeah` and `nah`. This customization provides flexibility in how logical values are represented.
  
- **Null Keyword**: You can also customize the `null` keyword, though be cautious—some languages do not support `null` in the same way (e.g., **Python**, **C++**, **AutoHotKey** and some more). For languages that don't support `null`, the value will simply be ignored or treated as an empty value.
  
- **End Keyword**: You can change the `end` keyword to something else. This is typically used for denoting the end of code blocks in various languages and is customizable in HTVM.

- **Global Keyword**: 
  - The `global` keyword works only in **Python** and **AutoHotKey**. It allows passing a global variable into a function and modifying it. In other languages, the `global` keyword will be ignored, but the variable will still be created.
  - You can also customize the `global` keyword to something else, keeping the functionality intact within supported languages.

---

### Main Label and Main Function Customization

HTVM allows you to **customize the main function label**. The main label refers to the starting point of your program, especially for languages like **C++** and many more but in **JavaScript** and **TypeScript** it's a bit different:

- **Main Label**: 
  - This is a customizable label where your main function is typically located. You can define a single word or even multiple words as the main label. The parser will ensure that the code below the label is treated as the main function's content. 
  - The main label is optional, and it’s simply a label—there’s no need to wrap the code in a block unless the language requires it (e.g., **Python** doesn’t need a `main` function, so the code will be placed directly beneath it).
  
- **Main Function**:
  - In **JavaScript** and **TypeScript**, you can toggle between an **async main function** and a regular one.
  - The language will default to creating asynchronous functions for all function definitions, but you can customize this behavior with the **async** keyword (which is also customizable to other terms if you prefer). Also, if you don’t use the main label keyword, the HTVM parser will assume that you haven't created any functions, and all the code will be placed in the main function if the target language has a main function.

---

### Function Customization

HTVM allows you to **customize various function-related keywords** to suit your needs:

- **Async Functions**: 
  - By default, all functions in HTVM are asynchronous. You can toggle this behavior or use the **asynchronous** keyword, which is customizable.
  - The **await** keyword can also be modified to something else (e.g., `wait`) to fit your naming preferences.
  
- **Loop Customization**: 
  - The loop syntax can be customized with terms like `A_Index` and `A_LoopField` to resemble **AutoHotKey**-style loops. These keywords provide a cleaner, more intuitive loop structure for those familiar with AutoHotKey.

---

### Important Considerations

- **Customizing Keywords**: When you customize keywords (e.g., `const`, `true`, `false`, `null`), ensure that they don’t conflict with existing language constructs. The parser will handle many of these customizations, but be aware of limitations in certain languages.
  
- **Global Variables**: The `global` keyword is supported in **Python** and **AutoHotKey**, but it will be ignored in other languages like **JavaScript** or **C++**. Ensure you understand how this will behave across different languages.

- **Async Functions in JavaScript/TypeScript**: This is especially useful for **JavaScript** and **TypeScript** but can be customized to suit your project’s needs.

---

HTVM provides a **high level of flexibility** for customizing how the language operates, allowing you to adapt it to the specific needs of your project. Whether you're working with variable declarations, loop structures, or customizing language-specific keywords, HTVM makes it easier to code in a way that feels natural to you.

---

## Advanced Customizations in HTVM

HTVM offers **advanced customizations** that allow you to control everything from ternary operators to error handling and even modularity with `include`. This flexibility makes it possible to tailor the language to your coding style and needs.

### Ternary Operator Customization

HTVM lets you customize the **ternary operator**:

- By default, HTVM uses the regular **C-style ternary operator** (`condition ? true : false`). This works in most languages, but certain languages (like **Go**) do not support this syntax.
- For languages that use a different syntax for ternary operators, HTVM will handle the conversion automatically, converting it to the appropriate format.
  - For example, **Python** uses the `condition if true else false` syntax.
  - HTVM will ensure that the ternary operator is properly converted, but if the target language does not support ternary operators, HTVM will generate a message and prevent execution in languages like **Go** where it won’t run. This ensures that you avoid runtime errors from unsupported syntax.

### Error Handling Customization

HTVM allows you to **customize error handling** as well:

- The `try`, `catch`, `finally`, and `throw` keywords are customizable, enabling you to tailor them to your preference.
- When using **throw**, you can customize the function name for the error message. This is how it works:
  - Type `throw`, followed by the function name (which is customizable), open parentheses, and inside the parentheses, you can pass a string that represents the error message.
  - Example:
    ```htvm
    throw ErrorMsg("Something went wrong!")

    ```
- **Conversion to Other Languages**:
  - HTVM converts error handling to most languages, but **Lua** and **Go** are exceptions. In those languages, the error handling structure is not supported, and HTVM will generate a string that alerts you about the lack of support.
  - HTVM does not provide error handling within itself. Instead, it relies on the target language to handle errors since HTVM assumes your code is flawless, and any issues should be identified by the language you're transpiling to.

### Include Keyword Customization

HTVM also supports **modularity** through the `include` keyword:

- The `include` keyword allows you to include other HTVM files at the top of your code.
- This is useful for organizing your code across multiple files or for reusing common functionality across different projects.
  - Example:
    ```htvm
    include "utility_functions.htvm"

    ```
- The `include` keyword is fully customizable, so you can change it to something else if preferred.

---

### Key Takeaways:

- **Ternary Operator**: Customizable to fit different syntaxes across languages, with automatic conversion. However, unsupported in **Go** and it will hardcode a message instead of running.
  
- **Error Handling**: Customizable for the `try`, `catch`, `finally`, and `throw` keywords, and the function name for error messages can also be customized. HTVM does not handle errors itself but relies on the target language’s error handling. However, unsupported languages like **Go** and **Lua** will hardcode a message instead of running.

- **Include**: Supports modularity by including external HTVM files, and the keyword itself is customizable.

These advanced customizations further enhance HTVM's flexibility, allowing you to adjust error handling, ternary operators, and file management to fit your needs. With these tools, HTVM can be tailored to suit your specific coding style and make your development process more efficient.

---

## Programming Blocks in HTVM

HTVM introduces **programming blocks** that allow you to **mix languages** seamlessly in your code. This feature is designed to handle cases where HTVM itself can't achieve something directly or when you'd prefer to rely on another language for specific tasks.

### How Programming Blocks Work

1. **Opening a Programming Block**: You can open a programming block for a specific target language with the following syntax:
    - One line to open the programming block.
    - Inside the block, you can write in the target language.
    - You close the block on a new line after your code.

Example:
```htvm
; This is a JavaScript programming block. It will stay intact and included in the JS output.
___js start
// this is now JavaScript code
console.log("==========================")
___js end

```

2. **Incorporating Blocks into HTVM Code**:
    - When you write in HTVM, you can seamlessly insert target-language code using programming blocks.
    - For example, if you're converting to **JavaScript**, you can open a **JavaScript programming block**, and the code inside will be converted directly to JavaScript and placed in the converted code without alteration.
    - If the HTVM code contains loops or other structures, the programming block code stays intact in the appropriate place during conversion.

3. **Multiple Programming Blocks**: You can use **multiple programming blocks** for different target languages, but they will be context-sensitive:
    - **For JavaScript**: The **Python programming block** will be ignored during conversion.
    - **For Python**: The **JavaScript programming block** will be ignored.
    - In other words, only the relevant programming block for the target language will be included in the final code.

Example:
- **JavaScript block** in HTVM:
```htvm
; Open JavaScript block
___js start
console.log("Hello, world!");
___js end
; End JavaScript block

```
- **Python block** in HTVM:
```htvm
; Open Python block
___py start
print("Hello, world!")
___py end
; End Python block

```
When converting to **JavaScript**, the Python block will disappear, and only the JavaScript block will be included.

4. **Reverse Programming Blocks**:
    - You can also open an **HTVM programming block** within other target language code (e.g., C++). The block will then be converted into HTVM-compatible code.
    - For example, if you're writing in C++ and need to use HTVM-specific functionality, you can insert an HTVM block, and it will be transpiled into C++ when you convert the code.
    - The process works by specifying the **target file** (e.g., `main.cpp`), and the HTVM block inside it will be converted based on the file's extension.

5. **Universal Programming Block**:
    - If two languages share the same syntax for a particular construct, HTVM allows you to use a **universal programming block**. This block can handle situations where HTVM cannot achieve the desired behavior but the syntax matches in multiple languages.
    - This is useful when the target languages have compatible syntax for specific code constructs but HTVM doesn't support them directly.

6. **Conversion and Functionality**:
    - During conversion, HTVM ensures that only the relevant programming block is preserved based on the target language. Unused blocks are omitted.
    - When converting code, HTVM will automatically include any necessary built-in functions or libraries for the target language, displaying them in the console.


### Key Advantages of Programming Blocks:

- **Flexibility**: Allows mixing HTVM with other languages for complex or specialized tasks.
- **Modularity**: Enables using language-specific libraries or features when HTVM cannot do the job.
- **Customizability**: Supports a wide range of languages, with options to adjust and adapt as needed.
- **Seamless Conversion**: Code stays in place, and HTVM ensures proper language-specific syntax is followed.

---

### Key Takeaways:
- **Programming blocks** allow writing code in another language directly within HTVM, which will be preserved during conversion to that language.
- Multiple programming blocks can be used, but only the relevant block will be included based on the target language.
- **Reverse programming blocks** allow you to insert HTVM code into other target language code.
- The **universal programming block** enables handling languages with similar syntax for specific constructs.


#### **And More...**  
- Go to [HTVM's website](https://themaster1127.github.io/HTVM) to explore all the syntax customizability and create your own language.

### **The Power of HTVM – Beyond Anything Else**  
This isn’t just some hobby project. **HTVM Version 2 took many months just for the parser.** And that was with prior experience from HTVM Version 1 and all the work put into previous languages like HT++, HTH, and HTpy. Every single language had to be carefully mapped out—loops, if-statements, try/catch blocks, functions, variables, types—**every detail had to be considered, tested, and tweaked.**  

And here’s the thing: **HTVM doesn’t just output to one language at a time—it can compile to multiple languages simultaneously.** That means you can write a single HTVM file and have it generate both JavaScript and Python code at the same time. That alone is something **almost no other tool in the world can do.**  

---

### **Programming Blocks – Total Control Over Your Code**  
And then we have **Programming Blocks.** These allow you to **write native code for the target language directly inside HTVM files**. So if you’re converting to JavaScript and need something that HTVM doesn’t handle natively, you can just open a **JavaScript Programming Block**, write JavaScript inside it, and it will only be included when compiling to JavaScript.  

But it gets even crazier—**you can have multiple programming blocks for different languages in the same file.** That means you can mix HTVM, JavaScript, Python, and C++ **all in one place** and still have everything work correctly.  

And if that wasn’t enough, there are **Reverse Programming Blocks**—which allow for even more insane levels of customization. Even if nobody uses them, **HTVM is so complete that the feature is still there.**  

---

### **The Future of Programming**  
HTVM **isn’t just a transpiler—it’s the future of programming.**  

This is a system that allows **anyone** to create their own syntax, define how they want their language to behave, and then generate fully functional code in fifteen different programming languages. No more being stuck with a single syntax or workflow—**HTVM lets you build programming your way.**  

Think about it. If you had to manually convert HTVM to fifteen different languages, it would take months just for a single feature. But **HTVM automates that entire process**—**once your syntax is defined, your language works across all targets instantly.**  

### **HTVM – The Future of Programming**  
This level of customization **doesn’t exist anywhere else.** No other system gives you this much control over how your language looks and feels. You’re not just writing code—you’re **designing your own programming experience.**  

HTVM isn’t just powerful—it’s **insane.** This is how programming should be.

**HTVM doesn’t force you into a fixed way of coding—it lets you create your own language and then outputs it into real programming languages.**  

HTVM **isn’t just another programming tool. It’s a revolution.**

---

## OSP (Ordinal Struct Programming)

[Go back](#htvm-documentation)

OSP (Ordinal Struct Programming) is HTVM's built-in approach for organizing data and related procedures using hierarchical namespaces and explicit path-based access. It focuses on **ordinal** positioning – meaning the unique location of structures within the defined hierarchy (`alliance`, `crew`). This feature offers an alternative for structuring code, particularly for those who prefer direct data manipulation and clear, absolute referencing over features like inheritance or encapsulation found in traditional OOP.

### What is a `struct` in HTVM OSP?

At its core, a `struct` in HTVM OSP is similar to structs in languages like C: it's a way to **group related data fields together under a single name**.

-   **Definition:** You define a struct using the `struct` keyword.
-   **Properties:** Inside a struct, you define its data fields using the `prop` keyword. Each `prop` holds a piece of data (like an integer, string, boolean, or even an array).
-   **Access:** Crucially, you *always* access struct properties using their **full, absolute path** starting from the top level (or the struct name if defined standalone). For example: `MyAlliance.MyCrew.MyStruct.myProp`.
-   **Global Nature:** Structs defined in OSP are globally accessible from any point in the code below their definition, using their full path.

```htvm
; Example of a simple, standalone struct
struct Configuration {
    prop str theme := "dark"
    prop int fontSize := 12
    prop bool spellCheck := true
}
; Accessing its properties later
; Access using the struct name as the path
print(Configuration.theme)
; Modifying a property
Configuration.fontSize := 14

```

### Optional Hierarchy: `alliance` and `crew`

While you can define simple `struct`s directly, OSP provides optional hierarchical keywords (`alliance` and `crew`) for better organization, especially in larger projects:

-   **`alliance`**: The top-level organizational container.
-   **`crew`**: A sub-level container within an `alliance` (or potentially nested within other crews, though nesting isn't shown in examples).

**Why use hierarchy?**

-   **Organization:** Group related structs and procedures together logically (e.g., all UI elements in a `GUI` crew, all vehicle data in a `Vehicles` crew).
-   **Avoiding Name Collisions:** If you had two different concepts both needing a `struct` named `Settings`, you could place them in different crews (e.g., `Audio.Settings` and `Video.Settings`) allowing them to coexist without conflict. Using `alliance` and `crew` acts like creating namespaces.

Most of the time, for simpler data organization, you might just need standalone `struct`s. Use `alliance` and `crew` when you need the extra structure to avoid naming hurdles and keep related components neatly grouped.

```htvm
alliance Game {
    crew Audio {
        ; This is Game.Audio.Settings
        struct Settings {
            prop int volume := 80
        }
    }
    crew Video {
        ; This is Game.Video.Settings - no collision!
        struct Settings {
            prop str resolution := "1920x1080"
        }
    }
}
; Access using the full path
print(Game.Audio.Settings.volume)
print(Game.Video.Settings.resolution)

```

### Procedures (`proc`)

Procedures are functions defined within the OSP hierarchy (`alliance` or `crew`) using the `proc` keyword. They are intended to perform actions related to the structs within their hierarchy.

-   **Association:** Defining a `proc` inside an `alliance` or `crew` links it semantically to that part of the hierarchy.
-   **Global Access:** Like structs, `proc`s are globally accessible via their full path (e.g., `MyAlliance.MyCrew.myProc`).
-   **Context (`this` Keyword):** Procedures can optionally accept a special parameter named `this` to understand *which* struct (identified by its path string) initiated the call.

### The `this` Keyword (Procedure Context)

The `this` keyword in OSP (Ordinal) is **different** from `this` in traditional OOP.

-   **Purpose:** It serves as an **optional input parameter for `proc`s**. When a `proc` is called with a struct's path string, `this` holds that **literal string value** inside the `proc`.
-   **Usage:** It allows a `proc` to perform different actions based on *which* struct path was passed to it. This is typically checked using simple string comparison (`if (this == "MyAlliance.MyCrew.MyStruct")`).
-   **Mechanism:** You must explicitly pass the **full path of the struct as a string** when calling the `proc` if you intend for that `proc` to use the `this` context.
-   **Limitation:** This string-based approach is explicit but requires careful maintenance. If you rename a `struct` or change the hierarchy, you **must** update all the corresponding string literals used in `proc` calls and within the `proc`'s `if/else if` checks. It doesn't automatically track the struct itself.

```htvm
alliance Movable {
    crew Vehicles {
        struct Car {
            prop int fuel := 100
        }
        struct Bike {
            prop int energy := 100
        }
        ; Proc using 'this' to know which struct called it
        ; 'this' will hold "Movable.Vehicles.Car" or "Movable.Vehicles.Bike"
        proc void checkStatus(this) {
            if (this = "Movable.Vehicles.Car") {
                ; Still use full path for access
                print("Checking Car fuel: " . Movable.Vehicles.Car.fuel)
            }
            else if (this = "Movable.Vehicles.Bike") {
                ; Still use full path
                print("Checking Bike energy: " . Movable.Vehicles.Bike.energy)
            }
            else {
                print("Unknown vehicle type passed to checkStatus: " . this)
            }
        }
    }
}
main
; Calling the proc with the context string
Movable.Vehicles.checkStatus("Movable.Vehicles.Car")
Movable.Vehicles.checkStatus("Movable.Vehicles.Bike")

```

### Key Rules Recap

1.  **Full Path Access:** Always use the full, absolute path to access `struct` properties (e.g., `Alliance.Crew.Struct.prop`).
2.  **`this` is Context String:** The `this` keyword, when used in a `proc`, holds the *path string* passed during the call. It's only valid inside `proc`s and requires explicit string comparison for conditional logic.

### Arrays in Structs

Arrays can be defined as properties within structs just like any other data type:

```htvm
struct name {
    prop arr str prop1
    prop arr str prop2
    prop arr str prop3
    prop arr str prop4
}

```

### Summary of OSP (Ordinal Struct Programming)

-   **Organizes** code using optional `alliance`/`crew` hierarchies and `struct` data containers.
-   **Emphasizes** explicit, **ordinal** (position-based) access via mandatory **full paths**.
-   Uses `struct` for data aggregation and `proc` for associated procedures within the hierarchy.
-   Offers an optional `this` keyword for `proc`s to receive the **calling struct's path as a string**, enabling context-specific actions via string comparison.
-   Provides **global accessibility** for all defined structs and procs via their full paths.
-   Serves as an **alternative structure** within HTVM, focusing on explicitness and hierarchy, potentially avoiding certain OOP complexities but introducing verbosity and reliance on string paths for context.

---

## Note:

### Never use underscores when naming things in OSP. Otherwise, you can use them, but be cautious because underscores can be unstable.

---

#### Example of OSP (Ordinal Struct Programming)

```htvm
alliance Movable {
    crew Vehicles {
        struct Car {
            prop int door := 4
            prop int fuel := 100
            prop bool hasFUEL := true
        }
        struct Bike {
            prop bool hasGears := true
            prop int energy := 100
            prop bool hasENERGY := true
        }
        proc void move(this) {
            global Movable.Vehicles.Car.fuel
            global Movable.Vehicles.Car.hasFUEL
            global Movable.Vehicles.Bike.energy
            global Movable.Vehicles.Bike.hasENERGY
            if (this = "Movable.Vehicles.Car") {
                if (Movable.Vehicles.Car.fuel > 0) {
                    print("The car is driving.")
                    Movable.Vehicles.Car.fuel := Movable.Vehicles.Car.fuel - 10
                }
                else {
                    print("The car is out of fuel.")
                    Movable.Vehicles.Car.hasFUEL := false
                }
            }
            else if (this = "Movable.Vehicles.Bike") {
                if (Movable.Vehicles.Bike.energy > 0) {
                    print("The bike is pedaling.")
                    Movable.Vehicles.Bike.energy := Movable.Vehicles.Bike.energy - 5
                }
                else {
                    print("The bike is out of energy.")
                    Movable.Vehicles.Bike.hasENERGY := false
                }
            }
        }
    }
    crew settings {
        struct GeneralSettings {
            prop str difficulty := "normal"
            prop int volume := 50
            prop str resolution := "1920x1080"
        }
        struct AudioSettings {
            prop int masterVolume := 70
            prop int musicVolume := 50
            prop int sfxVolume := 40
        }
        struct DisplaySettings {
            prop bool fullscreen := true
            prop str aspectRatio := "16:9"
        }
    }
    crew actions {
        ; General Settings Procs
        proc void resetGeneralSettings(this) {
            Movable.settings.GeneralSettings.difficulty := STR("normal")
            Movable.settings.GeneralSettings.volume := 50
            Movable.settings.GeneralSettings.resolution := STR("1920x1080")
            print("General settings reset to default.")
        }
        proc void printGeneralSettings(this) {
            print("General Settings:")
            print("Difficulty: " . Movable.settings.GeneralSettings.difficulty)
            print("Volume: " . STR(Movable.settings.GeneralSettings.volume))
            print("Resolution: " . Movable.settings.GeneralSettings.resolution)
        }
        ; Audio Settings Procs
        proc void resetAudioSettings(this) {
            Movable.settings.AudioSettings.masterVolume := 70
            Movable.settings.AudioSettings.musicVolume := 50
            Movable.settings.AudioSettings.sfxVolume := 40
            print("Audio settings reset to default.")
        }
        proc void printAudioSettings(this) {
            print("Audio Settings:")
            print("Master Volume: " . STR(Movable.settings.AudioSettings.masterVolume))
            print("Music Volume: " . STR(Movable.settings.AudioSettings.musicVolume))
            print("SFX Volume: " . STR(Movable.settings.AudioSettings.sfxVolume))
        }
        ; Display Settings Procs
        proc void resetDisplaySettings(this) {
            Movable.settings.DisplaySettings.fullscreen := true
            Movable.settings.DisplaySettings.aspectRatio := STR("16:9")
            print("Display settings reset to default.")
        }
        proc void printDisplaySettings(this) {
            print("Display Settings:")
            print("Fullscreen: " . STR(Movable.settings.DisplaySettings.fullscreen))
            print("Aspect Ratio: " . Movable.settings.DisplaySettings.aspectRatio)
        }
    }
    crew array {
        struct name {
            prop arr str prop1
            prop arr str prop2
            prop arr str prop3
            prop arr str prop4
        }
    }
}
main
; Test vehicle movement
while (Movable.Vehicles.Car.hasFUEL = true) and (Movable.Vehicles.Bike.hasENERGY = true) {
    Movable.Vehicles.move("Movable.Vehicles.Car")
    Movable.Vehicles.move("Movable.Vehicles.Bike")
    print("=====================================")
}
; Test settings manipulation
Movable.settings.GeneralSettings.difficulty := STR("hard")
Movable.settings.GeneralSettings.volume := 80
Movable.settings.GeneralSettings.resolution := STR("2560x1440")
Movable.settings.AudioSettings.masterVolume := 90
Movable.settings.AudioSettings.musicVolume := 60
Movable.settings.AudioSettings.sfxVolume := 50
Movable.settings.DisplaySettings.fullscreen := false
Movable.settings.DisplaySettings.aspectRatio := STR("21:9")
Movable.actions.printGeneralSettings()
Movable.actions.printAudioSettings()
Movable.actions.printDisplaySettings()
Movable.actions.resetGeneralSettings()
Movable.actions.resetAudioSettings()
Movable.actions.resetDisplaySettings()
Movable.actions.printGeneralSettings()
Movable.actions.printAudioSettings()
Movable.actions.printDisplaySettings()
; Test array manipulation
Movable.array.name.prop1.add("1text1")
Movable.array.name.prop1.add("1text2")
Movable.array.name.prop1.add("1text3")
Movable.array.name.prop2.add("2text1")
Movable.array.name.prop2.add("2text2")
Movable.array.name.prop2.add("2text3")
Movable.array.name.prop3.add("3text1")
Movable.array.name.prop3.add("3text2")
Movable.array.name.prop3.add("3text3")
Movable.array.name.prop4.add("4text1")
Movable.array.name.prop4.add("4text2")
Movable.array.name.prop4.add("4text3")
; Loop over and print
Loop, % Movable.array.name.prop1.size() {
    print(Movable.array.name.prop1[A_Index])
}
Loop, % Movable.array.name.prop2.size() {
    print(Movable.array.name.prop2[A_Index])
}
Loop, % Movable.array.name.prop3.size() {
    print(Movable.array.name.prop3[A_Index])
}
Loop, % Movable.array.name.prop4.size() {
    print(Movable.array.name.prop4[A_Index])
}

```

OSP (Ordinal Struct Programming) provides a structured, path-based approach to organizing data and procedures within HTVM, emphasizing explicit referencing.

---

### How Your Language Looks Like

[Go back](#htvm-documentation)

Get to know how HTVM code is structured and its syntax style. HTVM uses a clean, human-readable syntax that focuses on simplicity and ease of use. You can define your own syntax, making HTVM incredibly flexible and tailored to your needs.

Your language uses curly braces for indentation, square brackets for array definitions, parentheses around conditions in control flow statements (e.g., if, else if, while loops, like `if (condition)` or `while (condition)`), prefix type for variable definitions (similar to C-style type declaration, e.g., `int var1 = 5`).

Here is how it looks like:

```htvm
; This is how your language looks like.
; Here's how types will appear if you only define them:
int varName1
str varName2
bool varName3
float varName4
int8 varName5
int16 varName6
int32 varName7
int64 varName8
; Alternatively, you can define them like this:
int varName9 := 34
; Here is how to define a function with static types if you convert to C++.
; However, it will still work even if you are not converting to C++; types will be stripped away.
func void funcName1(int paramVar1, str paramVar2 := "", bool paramVar3 := false, float paramVar4 := 1.5) {
    ; This is how the global keyword works if we convert to Python.
    ; But even if we don't, it will just be removed, so you can add it if you want to convert to Python as well.
    global varName5
    ; Here's how if, else if, and else statements will look:
    if (varName1 = paramVar1) {
        print("varName1 is equal to paramVar1")
    }
    else if (varName1 != paramVar1 or varName1 <= paramVar1) {
        print("varName1 is less than or equal to paramVar1")
    }
    else {
        print("varName1 is NOT less than or equal to paramVar1 or something else")
    }
    ; this is how the return keyword will look like in your lang
    return
}
; This is where the main function will start. It's just a label, so don't worry.
main
funcName1(varName9)
; this is how a while loop works in your lang
bool var1 := false
while (var1 = false) {
    print("we are inside the while loop")
    var1 := true
}
print("we are outside the while loop")
; this is how to use a loop whit arrays
arr str array123 := ["hey"]
array123.add("hello")
array123.add("how")
array123.add("are")
array123.add("you")
array123.add("doing")
Loop, % array123.size() {
    print("iteration: " . STR(A_Index))
    print("Item: " . array123[A_Index])
}
print("this is how the escape char looks like `nthis is a new line")
'''1
this is a comment block
this is a comment block
'''2
; this is how to use an AutoHotKey like Loop
Loop, 10 {
    if (A_Index % 2 = 0) {
        continue
    }
    print(A_Index)
}
; this is how to use an AutoHotKey like infinite Loop
Loop {
    if (A_Index = 5) {
        break
    }
    else {
        print(A_Index)
    }
}
; this is how to use an AutoHotKey like Loop, parse
str someText := "hello how are you doing`ntoday we are good."
Loop, Parse, someText, " ", `n {
    print(A_LoopField)
}
; Error Handling
try {
    throw ErrorMsg("Something went wrong!")
}
catch (e) {
    print(e)
}
finally {
    print("Finally block executed")
}

```

### Advanced String Features

HTVM supports powerful string definition methods, including formatted strings (f-strings) and multiline strings for easier text handling.

*   **F-Strings (`f"..."`)**: Allow embedding variables and expressions directly within strings.
*   **Multiline Strings (`mls`...`mle`)**: Define strings that span multiple lines, preserving formatting (like newlines and indentation) exactly as written. Ideal for raw text, templates, or ASCII art.
*   **Multiline F-Strings (`fmls`...`mle`)**: Combine the benefits of multiline strings and f-strings, allowing embedded variables and expressions within a multiline block.

Here's how you can use them:

```htvm
; === Regular F-String Example ===
int calculation := 10 + 5
str message := f"The result is: {calculation}. Double is: {calculation * 2}"
print("Regular F-String:")
print(message)
print("=========================")
; === Multiline String (Raw) Example ===
str ascii_cat := mls
 /\_/\
( o.o )
 > ^ <
mle
print("Multiline String (Raw):")
print(ascii_cat)
print("=========================")
; === Multiline F-String Example ===
str userName := "Alice"
int items := 3
float price := 19.99
str order_summary := fmls
Order Summary for: {userName}
Items purchased: {items}
Total cost: ${items * price}
Thank you for your order!
Newlines and indentation are preserved.
mle
print("Multiline F-String:")
print(order_summary)
print("=========================")

```

#### Summary: The Power of Advanced Strings

These advanced string features (`f`, `mls`, `fmls`) significantly enhance HTVM's usability and power. They eliminate the need for cumbersome string concatenation and complex formatting logic.

*   **Readability**: Code becomes much cleaner and easier to read, especially when dealing with templates, long text blocks, or dynamic content generation.
*   **Simplicity**: Constructing complex strings with embedded variables or preserving exact formatting is now straightforward and intuitive.
*   **Expressiveness**: HTVM becomes even more expressive, allowing you to focus on the logic rather than wrestling with string manipulation quirks.

This level of string handling flexibility is a testament to HTVM's design philosophy: providing powerful, convenient tools that adapt to the programmer's needs, ultimately making development faster and more enjoyable. It's another step towards making HTVM the future of simplified, yet powerful, programming.

---


### Programming Blocks

[Go back](#htvm-documentation)

Programming blocks in HTVM allow you to write code directly in the target language when HTVM itself cannot handle certain tasks. These blocks give you the flexibility to insert language-specific code into your HTVM project without disrupting the overall flow. There are two main use cases for programming blocks: single-language programming blocks and multi-language programming blocks.

#### **Single-Language Programming Block**

A single-language programming block allows you to write code directly in the target language. If you're converting HTVM code to, say, C++, you can open a programming block and write C++ code inside. This block will only be valid in the context of converting to C++ and will disappear when converting to another language.

**Example:**

```htvm
; Open a programming block for C++
___cpp start
// Write C++ code here
___cpp end

```

#### **Multiple-Language Programming Block**

HTVM also supports multiple-language programming blocks, where you can write code in different languages for the same functionality. For instance, if you're converting to both C++ and JavaScript, you can write separate blocks for each language but ensure the code behaves similarly in both.

**Example:**

```htvm
; Open a programming block for C++
___cpp start
// Write C++ code here
___cpp end
; Open a programming block for JavaScript
___js start
// Write JavaScript code here
___js end

```

When using multi-language blocks, the syntax and implementation might differ, but the core functionality should remain the same. This is a great way to ensure consistency across multiple target languages.

#### **Warning About AI-Generated Code**

**WARNING:** Be cautious when using AI-generated code. While AI can help speed up development, relying too heavily on it can be dangerous. You must understand the code you're incorporating into your project. **MAKE SURE YOU KNOW WHAT YOU'RE DOING BEFORE USING AI**. 

If you don't have a solid understanding of the concepts you're asking the AI to handle, it can harm your learning process. **It could also negatively affect your development as a programmer.** Are you truly understanding the code you’re working with, or just relying on AI to do the heavy lifting for you?

Use AI to *assist*, not replace your learning process. **Be careful and make sure you understand every line of code** before integrating it into your project. This is essential for becoming a proficient programmer.

#### **Reverse Programming Blocks**

Reverse programming blocks in HTVM allow you to write HTVM code in another file, which the HTVM compiler can recognize. These reverse blocks are helpful when you need to convert code written in HTVM into a target language while automatically including the necessary libraries and built-in functions.

The syntax for reverse programming blocks is the same as for regular programming blocks, but you'll write HTVM code inside files of supported languages (e.g., `.cpp`, `.js`, etc.). Once you pass both the source file (e.g., `main.cpp`) and the HTVM instruction file to HTVM, the compiler will automatically replace the HTVM code with the appropriate target language code.

HTVM will also ensure that all necessary libraries and built-in functions are included. It will automatically show you which libraries need to be included at the top of the file and which built-in functions you must import if they're not already part of the language's standard library.

**Example of reverse programming block:**

1. Create a `.cpp` file (or any supported language file).
2. Open the HTVM programming block using the syntax below:
- To open - `___inhtvm start`
- To close - `___inhtvm end`

3. Pass both the `.cpp` file and the HTVM instruction file to HTVM.

HTVM will:

- Replace the HTVM code with C++ (or the corresponding language).
- Display the libraries and built-in functions that need to be included.

---


### Variables

[Go back](#htvm-documentation)

Learn how to declare and use variables in HTVM for storing and manipulating data. HTVM makes working with variables straightforward by providing flexible types and easy handling of data.


### **Variables in HTVM**  

A variable is a way to store and reference data in your code. In HTVM, you can use different variable types depending on your needs. Here are all the variable types supported by HTVM:  

| Type         | Description |
|-------------|------------|
| `int`       | Regular integer (size depends on the target language) |
| `int8`      | 8-bit signed integer |
| `int16`     | 16-bit signed integer |
| `int32`     | 32-bit signed integer |
| `int64`     | 64-bit signed integer |
| `uint8`     | 8-bit unsigned integer |
| `uint16`    | 16-bit unsigned integer |
| `uint32`    | 32-bit unsigned integer |
| `uint64`    | 64-bit unsigned integer |
| `float`     | Floating-point number (usually 32-bit) |
| `double`    | Double-precision floating-point number |
| `char`      | Single character |
| `string`    | Text string |
| `bool`      | Boolean (`true` or `false`) |

> **Note:** We won't mention arrays here because they have a separate section under.

---

### **HTVM Variable Example**  

Here’s a simple example of declaring and printing variables in HTVM:  

```htvm
int myInt := 42
int8 mySmallInt := -5
uint16 myPositiveInt := 500
float myFloat := 3.14
double myDouble := 2.718
char myChar := 'A'
str myText := "Hello, HTVM!"
bool myBool := true
; print all variables
print(myInt)
print(mySmallInt)
print(myPositiveInt)
print(myFloat)
print(myDouble)
print(myChar)
print(myText)
print(myBool)

```

This will correctly convert to the target language with the appropriate syntax.

---

### **Static vs. Dynamic Typing in HTVM**  

HTVM itself is **neither statically typed nor dynamically typed**. It simply converts code to the target language, which may be either.  

| **Language**  | **Typing** |
|--------------|------------|
| JavaScript   | Dynamic    |
| Python       | Dynamic    |
| Lua          | Dynamic    |
| Ruby         | Dynamic    |
| Groovy       | Dynamic    |
| TypeScript   | Static     |
| C++          | Static     |
| Go (Golang)  | Static     |
| C#           | Static     |
| Java         | Static     |
| Kotlin       | Static     |
| Nim          | Static     |
| Swift        | Static     |
| Dart         | Static     |
| AutoHotKey   | Dynamic    |

- **For static languages**, you **must** use types; otherwise, the conversion will result in invalid code.
- **For dynamic languages**, you **can** use types, but HTVM will **strip them away** automatically.
- **HTVM does not provide type safety** – it will not warn you about type mismatches. You'll find out only when running the target language.

---

#### **`let` and `var` Keywords**

The `let` and `var` keywords in HTVM are mainly useful when converting to languages that support these keywords, like **JavaScript** and **TypeScript**. These keywords are used to define mutable variables, but outside of those specific languages, you can ignore them, as HTVM will convert them appropriately based on the target language.

---

### **The `const` Keyword**  

HTVM supports the `const` keyword, but it **does not enforce it** in any way. It simply converts it to the target language if the language supports `const`.  

| **Language**  | **Supports `const`?** |
|--------------|--------------------|
| JavaScript   | ✅ Yes |
| TypeScript   | ✅ Yes |
| C++          | ✅ Yes |
| Go (Golang)  | ✅ Yes |
| C#           | ✅ Yes |
| Java         | ✅ Yes |
| Kotlin       | ✅ Yes |
| Swift        | ✅ Yes |
| Dart         | ✅ Yes |
| Python       | ❌ No (ignored) |
| Lua          | ❌ No (ignored) |
| Ruby         | ❌ No (ignored) |
| Groovy       | ❌ No (ignored) |
| Nim          | ✅ Yes |
| AutoHotKey   | ❌ No (ignored) |

HTVM **does not check** whether you're violating `const`. If a language doesn’t support `const`, HTVM **removes it** without warning.

Example:  

```htvm
const int x := 10

```

- If converting to **C++**, this becomes `const int x = 10;`
- If converting to **Python**, this becomes `x = 10` (no `const`).
- If converting to **Java**, this becomes `final int x = 10;`
- ... etc.

---

### **Programming Blocks & Variable Scope**  

HTVM allows **programming blocks**, where you write code directly in a target language. These blocks **do not convert** – they remain as-is.

#### **Variable Accessibility in Programming Blocks**
- **HTVM variables can be accessed inside programming blocks.**
- **Modifications inside a block persist after the block.**
- **Programming blocks are not scoped – they are part of the converted language.**
- **However, different programming languages do not share scope.**  

Example (Converting to Python):  

```htvm
int myNumber := 5
___py start
myNumber += 10
___py end
; Will print 15 in Python
print(myNumber)

```

This converts to:  

```python
myNumber = 5
myNumber += 10  # Python block stays intact
print(myNumber)  # 15
```

---

### **Multiple Programming Blocks & Limitations**  

#### **Single Language Conversion**
If you are converting to just **one language**, everything works as expected. Variables declared in HTVM can be used inside the programming block and modified.

#### **Multiple Language Conversion**
If you are converting to **multiple languages**, each programming block is isolated per language.  
- **You cannot access variables across different language blocks.**  
- You must **manually maintain the same logic** in each block.  

Example (Invalid cross-language access):  

```htvm
int sharedNumber := 20
___cpp start
sharedNumber += 5;
___cpp end
___py start
print(sharedNumber)  # ❌ This won't work because Python can't access C++ variables
___py end

```

To fix this, you need to **manually synchronize values** in each programming block.

---

### **Unsigned Integers & Java**  

- **Java does not support unsigned integers** (`uint8`, `uint16`, etc.).
- If you try to use them, **HTVM will not warn you**, but Java might throw errors.
- **Avoid using unsigned integers when converting to Java.**  

Example of bad practice:  

```htvm
uint32 myUnsigned := 500

```

- **Works in C++** (`uint32_t myUnsigned = 500;`)
- **Might fail in Java since unsigned ints are converted to signed ones**

---

### **Summary**

- HTVM has multiple **variable types**, including integers, floats, chars, strings, and booleans.
- HTVM **converts to both static and dynamic languages** but does not enforce type safety.
- The `const` keyword is supported but **ignored** in languages that don’t use it.
- **Programming blocks do not convert** – they stay in the target language.
- **Variables persist inside programming blocks** but do not transfer between different language blocks.
- **Java does not support unsigned integers**, so try to avoid them when converting to Java.

---


### Functions

[Go back](#htvm-documentation)

Explore how to define and use functions for modular and reusable code. Functions in HTVM can be written easily, and the language supports efficient handling of function calls, parameters, and returns.

### **HTVM Functions**  

Functions in HTVM allow you to create reusable pieces of code. A function is defined using the `func` keyword, followed by the return type, the function name, and its parameters.

#### **Defining a Function**

```htvm
func int add(int a, int b) {
    return a + b
}

```

```htvm
func str addStringPlusInt(str a, int b) {
    return a . STR(b)
}

```

```htvm
func void greet() {
    print("Hello, world!")
}

``` 

Optional parameters example:

```htvm
str varName5 := "hi"
func str funcName1(int paramVar1, str paramVar2 := "", bool paramVar3 := false, float paramVar4 := 1.5) {
    ; This is how the global keyword works if we convert to Python.
    ; But even if we don't, it will just be removed, so you can add it if you want to convert to Python as well.
    global varName5
    ; this is how the return keyword will look like in your lang
    return STR(paramVar1)
}
; This is where the main function will start. It's just a label, so don't worry.
main
print(funcName1(5))

```

If you are converting to a dynamically typed language, the types will be stripped away automatically. However, for statically typed languages, you must include them.  

#### The `main` Function

In HTVM, the `main` function is required if you are using functions. It is defined as a simple label at the beginning of the program. If you do not include the `main` function, HTVM will insert it automatically at the top of the code. However, if you define any functions and do not include the `main` label, the program will not work as expected.

The `main` label is where the execution starts in languages that use a main function (like C++). In languages that do not require a `main` function (like Python), HTVM handles it automatically.

Here’s how it looks:

```htvm
func void greet() {
    print("Hello, world!")
}
; You can just use this label, and it's all handled for you
main
greet()

```

- The `greet` function is defined before `main`.
- The `main` function calls `greet()` to execute the code.

If you do not define the `main` label, HTVM will automatically add it at the top of the code, but **you must include it if you are using functions** to ensure everything works correctly.

### **HTVM: Flexible Function Call Syntax**

#### **Overview**  
HTVM introduces a unique and flexible function call syntax that allows developers to call functions in multiple ways while maintaining simplicity and readability. This enhancement does not change the fundamental nature of functions in HTVM—they remain regular functions rather than methods. However, HTVM allows them to be called using dot notation for convenience. No programming language supports this level of freedom—this is a new invention: a flexible and freeing way to call HTVM functions.

#### **Features**

- **Traditional Function Calls**  
  Functions can be called using the standard syntax:  
  ```htvm
  StrLower(var1)
  Trim(var1)
  ```

- **Dot Notation for Function Calls**  
  HTVM allows functions to be called using dot notation for enhanced readability and convenience:  
  ```htvm
  var1.StrLower()
  var1.Trim()
  ```

- **Optional Parentheses**  
  When a function does not require additional parameters, parentheses can be omitted:  
  ```htvm
  var1.StrLower
  var1.Trim
  ```

- **Chained Function Calls**  
  Functions can be chained together using dot notation:  
  ```htvm
  var1.StrLower().Trim()
  ```

  Since parentheses are optional, the same operation can be written as:  
  ```htvm
  var1.StrLower.Trim
  ```

  It is also possible to mix both styles:  
  ```htvm
  var1.StrLower().Trim
  ```

- **Seamless Transpilation**  
  HTVM automatically converts these function calls into standard function calls during conversion. This ensures that the underlying implementation remains consistent while providing developers with flexibility in how they write their code.

#### **Examples**

### **Standard Function Calls**  
```htvm
StrLower(var1)
Trim(var1)
```

### **Dot Notation Function Calls**  
```htvm
var1.StrLower()
var1.Trim()
```

### **Dot Notation Without Parentheses**  
```htvm
var1.StrLower
var1.Trim
```

### **Chained Function Calls**  
```htvm
var1.StrLower().Trim()
```

### **Mixed Parentheses Usage**  
```htvm
var1.StrLower().Trim
```

### **Full Example with OSP**

```htvm
crew someCrew {
    struct someStruct {
        prop str someText := ""
    }
    proc str someProc(this) {
        print(this)
        return this
    }
}
main
"hqwesr".print
"hqwesr".print(
"hqwesr".print()
print("hawesd")
str var1 := " helLO "
var1 := Trim(StrLower(var1))
var1 := var1.StrLower.Trim
var1 := var1.StrLower(.Trim(
var1 := var1.StrLower(.Trim
var1 := var1.StrLower.Trim(
var1 := var1.StrLower().Trim()
var1 := var1.StrLower().Trim
var1 := var1.StrLower.Trim()
someCrew.someStruct.someText := var1
; for OSP you need to use () they are not optional unless it's not at the beginning of the line like this:
if (someCrew.someStruct.someText.someCrew.someProc = "hello") {
    print("hi")
}
; or
; We can't use someCrew.someStruct.someText.someCrew.someProc(
; We need to use () since it's not at the beginning of the line.
if (someCrew.someStruct.someText.someCrew.someProc() = "hello") {
    print("hi")
}
; or
if (someCrew.someProc(someCrew.someStruct.someText) = "hello") {
    print("hi")
}
; otherwise, if it's at the beginning of the line we need to use () for OSP
someCrew.someStruct.someText.someCrew.someProc()
; or you can use only 1 ( for extra fast typing
someCrew.someStruct.someText.someCrew.someProc(
; or
someCrew.someProc(someCrew.someStruct.someText)
; WARNING: If you are not calling it at the beginning of the line
; and you are inside an if statement or other places,
; don't use only 1 ( use both ().

```

---

#### This only works with HTVM built-in functions and user-defined functions.  
When using the `varName.funcName` format, HTVM will only convert it to a regular function call (`funcName(varName)`) **if** the function is either a built-in function in HTVM or explicitly defined by the user.

HTVM **does not care** whether the function is built-in in the target language (e.g. Python). If the function is not recognized by HTVM, it will not be converted — even if it's valid in the output language.

For example:
```py
strVar.upper()
```
- If `upper` is not a built-in HTVM function or user-defined in your code, HTVM will **not** convert this into `upper(strVar)` for Python.  
- It will stay as `strVar.upper()` or may cause unexpected output depending on the target.

---

#### **Conclusion**  
This feature enhances HTVM's usability by providing developers with multiple ways to call functions. While function calls remain standard behind the scenes, the optional dot notation and support for omitting parentheses make the syntax more intuitive, readable, and faster to write — especially in casual or repetitive scenarios.

---


### Arrays

[Go back](#htvm-documentation)

Dive into working with arrays, one of the most essential data structures in HTVM. Arrays are simple to declare and manipulate, enabling you to store and process collections of data easily.

### **Arrays in HTVM**

Arrays in HTVM are collections of values stored in a single variable. Arrays can hold multiple values of the same type. HTVM supports a variety of array types and offers flexibility, especially in dynamic languages. Here's an overview of how arrays work in HTVM:

---

### **Supported Array Types**  

HTVM supports the following array types:

| Type        | Description |
|-------------|------------|
| `arr int`     | Array of integers (regular size depends on the target language) |
| `arr float`   | Array of floating-point numbers |
| `arr bool`    | Array of booleans (true or false) |
| `arr str`  | Array of strings (text) |

> **Note:** In dynamic languages like JavaScript and Python, you can use arrays without explicitly defining the type. The type will be inferred or stripped out, depending on the language.

---

### **The Generic Array Type**  

In addition to the specific array types above, HTVM provides a more flexible **generic array** keyword which is `arr`. This allows you to create arrays without specifying a type. When you use this keyword:

- In **dynamically typed languages** (e.g., JavaScript, Python), HTVM will infer the type based on the values you assign.
- In **statically typed languages** (e.g., C++, Java), HTVM will convert it into a `std::vector<std::string>` / `string[]`.

This provides flexibility, but also means you lose type checking, and you’ll need to ensure the elements in the array match the expected type.

Example (Dynamic Language):
```htvm
; In (e.g., JavaScript, Python), this will be inferred as an array of integers
arr myArray := [1, 2, 3, 4]

```

---

### **Array Methods in HTVM**

| **Method**                          | **Description**                                                                                |
|-------------------------------------|------------------------------------------------------------------------------------------------|
| `.add()`    | Adds an element to the end of the array.                                                       |
| `.pop()`       | Removes and returns the last element of the array.                                             |
| `.size()`      | Returns the number of elements in the array.                                                   |
| `.insert()`    | Inserts an element at a specific index.                                                        |
| `.rm()`    | Removes the element at the specified index.                                                    |
| `.indexOf()`   | Returns the index of the first occurrence of the specified element. Returns `-1` if not found. |

---

### **Array Methods in Detail**

HTVM provides a set of useful methods to manipulate arrays in your programs. These methods follow a consistent `.method()` syntax, making it easy to interact with arrays. Below are the array methods supported in HTVM:

1. **`.add()`**  

Adds an element to the end of the array.  
Example:
```htvm
arr int myArray := [1, 2, 3]
myArray.add(4)
; myArray is now [1, 2, 3, 4]
print(myArray)

```

2. **`.pop()`**  

Removes and returns the last element of the array.  
Example:
```htvm
arr int myArray := [1, 2, 3, 4]
myArray.pop()
; myArray is now [1, 2, 3]
print(myArray)

```

3. **`.size()`**  

Returns the number of elements in the array.  
Example:
```htvm
arr int myArray := [1, 2, 3]
; returns 3
print(myArray.size())

```

4. **`.insert()`** 
 
Inserts an element at a specific index. The index is the first argument, and the element to insert is the second argument.  
Example:
```htvm
arr int myArray := [1, 2, 3]
myArray.insert(1, 4)
; myArray is now [1, 4, 2, 3]
print(myArray)

```

5. **`.rm()`**  

Removes the element at the specified index.  
Example:
```htvm
arr int myArray := [1, 2, 3, 4]
myArray.rm(2)
; myArray is now [1, 2, 4]
print(myArray)

```

6. **`.indexOf()`**  

Returns the index of the first occurrence of the specified element. If the element is not found, it returns `-1`.  
Example:
```htvm
arr int myArray := [1, 2, 3, 2]
print(myArray.indexOf(2))
; returns 1

```

---

### **Example of Using Array Methods in HTVM**

```htvm
arr int myArray := [1, 2, 3]
myArray.add(4)
; Removes the element at index 1
myArray.rm(1)
; Inserts 5 at index 1
myArray.insert(1, 5)
; Output: [1, 5, 3, 4]
print(myArray)

```

In the example above, you can see how various methods like `.add()`, `.rm()`, and `.insert()` are used in sequence to manipulate the array.

---

### **Summary of Array Methods**

- **`.add()`**: Adds an element to the end of the array.
- **`.pop()`**: Removes and returns the last element of the array.
- **`.size()`**: Returns the size of the array.
- **`.insert(index, element)`**: Inserts an element at the specified index.
- **`.rm(index)`**: Removes the element at the specified index.
- **`.indexOf(element)`**: Finds the index of the first occurrence of the specified element.

---

### **Arrays in Programming Blocks**  

Just like variables, arrays can be accessed and modified inside **programming blocks**. Programming blocks in HTVM are directly written in the target language and do not undergo conversion. The following behaviors apply to arrays inside programming blocks:

- **Arrays persist across blocks**, meaning changes made to an array within a block are retained when the block ends.
- **Arrays are not scoped**—they are part of the target language’s code.
- **Different programming languages do not share arrays across blocks**, just like variables.

Example (Converting to Python):

```htvm
arr int myArray := [1, 2, 3]
___py start
myArray.append(4)  # Modifying the array inside the Python block
___py end
; Will print: [1, 2, 3, 4] if converted to python otherwise it will print [1, 2, 3]
print(myArray)

```

This will convert to:

```python
myArray = [1, 2, 3]
myArray.append(4)  # Python block stays intact
print(myArray)  # Output: [1, 2, 3, 4]
```

---

### **No Type Checking for Arrays**  

HTVM **does not perform type checking** for arrays. It will **not warn you** if you accidentally try to mix types within an array or if you make other mistakes related to array types. You will only notice errors during runtime in the target language.

Example:

```htvm
; In JavaScript, this will be an array with mixed types, but HTVM won't warn you
arr int myArray := [1, "two", 3]

```

In **JavaScript**, this would become:

```javascript
let myArray = [1, "two", 3];  // Valid in JavaScript, but mixed types
```

However, you might get unexpected results in a **statically typed language**, like **C++**.

---

### **No `const` Arrays**  

HTVM does not support **constant arrays** or array immutability like some languages might (e.g., `const` arrays in JavaScript). If you want to have immutable arrays, you will need to **use programming blocks** and ensure the logic prevents modification.

Example:

```htvm
arr int myArray := [1, 2, 3]
___cpp start
myArray.push_back(4);  // In C++, this works, but HTVM does not enforce immutability
___cpp end
; If we print this in HTVM, we will get:
;
; When converting to C++, we can't just print the array directly. However, in some other languages,
; we don't need to loop over the array to print it.
Loop, % myArray.size() {
    print(myArray[A_Index])
}
; If you convert this to any language other than C++ (cpp), it will print:
; 1
; 2
; 3

```

If you want immutability or similar behavior, you must handle it manually within programming blocks or by controlling logic in your code.

---

### **Arrays in Multiple Language Conversions**  

When converting to **multiple languages**, arrays function similarly to variables in programming blocks. However, you cannot directly **share arrays between different language blocks**. Each block is isolated in its respective language, so any array manipulations within one block will not affect another block.

Example (Invalid cross-language access):

```htvm
arr int myArray := [1, 2, 3]
___cpp start
myArray.push_back(4);  // Modifies the array in C++
___cpp end
___py start
# It will print [1, 2, 3]
print(myArray)  # ❌ This will not work because Python can't access the C++ array. 
# Since the C++ block is gone, it will only print [1, 2, 3].
___py end
; If converted to Python, it will print: [1, 2, 3]
; If converted to C++, it will print: [1, 2, 3, 4]
; If converted to another language, it will print: [1, 2, 3]
print(myArray)

```

You’ll need to manually synchronize arrays between programming blocks if needed.

---

### **Summary**  

- HTVM supports **integer arrays**, **floating-point arrays**, **boolean arrays**, and **string arrays**.
- **Array Methods in HTVM**
- HTVM offers a **generic array type**, which is flexible but removes type checking in dynamic languages.
- **Arrays in programming blocks persist**, but they are not scoped across blocks.
- **No type checking** is performed on arrays, so errors related to mismatched types will not be caught until runtime.
- **No support for constant arrays**—you need to manage immutability yourself using programming blocks.
- **Arrays cannot be shared across different language blocks** in multiple language conversions.

#### ⚠️ WARNING: We can't use nested arrays or multiline arrays (like arrays inside arrays or 2D/3D arrays). To achieve that, use a programming block.

---







### Loops

[Go back](#htvm-documentation)

### **Understanding Loops in HTVM**

HTVM supports multiple types of loops, inspired by AutoHotKey (AHK) syntax. These loops are designed to be simple and efficient, offering flexibility for various tasks. Let’s explore the **Regular Loop**, **Loop Parse**, **Infinite Loop**, and the **while** loop.

**Regular Loop** = `Loop,`

**Loop Parse** = `Loop, Parse,`

**Infinite Loop** = `Loop`

**While** loop = `while`

**continue** = `continue`

**break** = `break`

**A_Index** = `A_Index`

**A_LoopField** = `A_LoopField`


### **1. Regular Loop**

The `Loop,` keyword in HTVM is the simplest and most common type of loop. It runs a specified number of iterations, and you can use the `A_Index` keyword to track the current iteration number.

#### Example:

```htvm
; Regular loop example
Loop, 10 {
    if (A_Index % 2 = 0) {
        ; Skip even numbers
        continue
    }
    ; Output only odd numbers from 1 to 9
    print(A_Index)
}

```

In this loop, `A_Index` is used to track the current iteration number. The `continue` keyword is used to skip even numbers, so only odd numbers will be printed.

---

### **2. Loop Parse**

The `Loop, Parse,` is similar to AutoHotKey’s loop parsing method, where you can iterate over a string or text with different delimiters. In HTVM, `A_LoopField` is used to access the current field (or token) in the string being parsed.

#### **Example 1: Delimited by Space (" ")**

```htvm
; Loop Parse with space delimiter
str someText := "hello how are you doing today"
Loop, Parse, someText, " " {
    ; Output each word in the string separated by spaces
    print(A_LoopField)
}

```

In this example, the loop iterates over each word in the string `someText`, which is delimited by spaces. The `A_LoopField` holds the current word from the string.

#### **Example 2: Delimited by New Line**

```htvm
; Loop Parse with new line delimiter
str multiLineText := "line 1`nline 2`nline 3"
Loop, Parse, multiLineText, `n {
    ; Output each line of text
    print(A_LoopField)
}

```

Here, the loop splits the text by new lines, and `A_LoopField` holds each line individually.

#### **Example 3: Delimited by Carriage Return**

```htvm
; Loop Parse with carriage return delimiter
str textWithCarriageReturn := "line 1`rline 2`rline 3"
Loop, Parse, textWithCarriageReturn, `r {
    ; Output each line separated by carriage returns
    print(A_LoopField)
}

```

In this case, the text is delimited by carriage returns, and each line is printed separately.

#### **Example 4: Delimited by Both Space and New Line**

```htvm
; Loop Parse with space and new line delimiters
str mixedText := "hello world`nhow are you doing today"
Loop, Parse, mixedText, " ", `n {
    ; Output each word or line separated by spaces or new lines
    print(A_LoopField)
}

```

This example uses both a space and a new line as delimiters to split the string into tokens.

#### **Example 5: No delimited**

```htvm
; Loop Parse each character when using no delimiters
str word := "master"
Loop, Parse, word {
    ; Output each character
    print(A_LoopField)
}

```

This example uses no delimiters to parse each character.

---

### **3. Infinite Loop**

HTVM also supports infinite loops using the `Loop` keyword without a defined number of iterations. The loop will continue running until a `break` condition or manual termination occurs. The `continue` keyword can be used inside the infinite loop to skip the current iteration and continue with the next one.

#### Example (Infinite Loop):

```htvm
; Infinite Loop example
Loop {
    if (A_Index = 5) {
        ; Exit the loop when A_Index is 5
        break
    }
    else {
        ; Print the current value of A_Index
        print(A_Index)
    }
}

```

Here, the loop runs indefinitely, printing the current value of `A_Index`. When `A_Index` reaches 5, the loop breaks. You can also use `continue` to skip iterations as needed.

---

### **4. While Loop**

The `while` loop in HTVM works like a typical while loop in other languages. It continues to execute the loop body as long as the specified condition evaluates to true.

#### Example (While Loop):

```htvm
; While loop example
bool var1 := false
while (var1 = false) {
    print("we are inside the while loop")
    var1 := true
}
print("we are outside the while loop")

```

In this example, the `while` loop runs once because the condition is initially true, then changes `var1` to true, causing the loop to terminate.

---

### **Array Example in Loop**

HTVM also allows arrays, which can be used in loops for more complex tasks. Here’s an example that iterates over an array:

```htvm
; Array example in loop
arr123 := ["apple", "banana", "cherry"]
Loop, % arr123.size() {
    ; Output each element in the array
    print(arr123[A_Index])
}

```

In this case, the loop iterates through each element of the array `arr123` using `A_Index` to reference the array's index.

---

### **Variable Example in Loop**

With HTVM, you can also use variables to control loops. Here's an example:

```htvm
; Loop example with variable range
var1 := 5
Loop, % var1 {
    ; Output the current iteration
    print(A_Index)
}

```

This example shows how HTVM allows you to use variables like `var1` to control the number of iterations in the loop, with `A_Index` printing the current iteration number.

---

### **Key Notes:**
- **`A_Index`**: Used in all loops except for `while` loops.
- **`A_LoopField`**: Used only in `Loop, Parse,` to reference the current field.
- **`continue`**: Can be used in any loop to skip the current iteration and continue with the next one. When converting to Lua, place the `::continue` at the end of the loop, just before it ends.

---

### **Lua Conversion**

For the **Loop,**, **Loop, Parse,**, and **Loop** types, the Lua conversion looks like this:

```htvm
; Regular loop example
Loop, 10 {
    if (A_Index % 2 = 0) {
        continue
    }
    ; Output only odd numbers from 1 to 9
    print(A_Index)
    ::continue
}
print("=====================")
; Infinite loop example
Loop {
    if (A_Index % 2 = 0) {
        continue
    }
    ; Output only odd numbers from 1 to 9
    print(A_Index)
    if (A_Index = 9) {
        break
    }
    ::continue
}
print("=====================")
; Loop, Parse loop example
str var1 := "hello whats up bro how are you doing"
Loop, Parse, var1, " " {
    if (A_LoopField = "bro") {
        continue
    }
    ; 3 will never print
    print(A_Index)
    ::continue
}

```

In Lua, the conversion for these loops would use the `goto` statement to achieve the continue behavior. Here's how it would look in Lua:

```lua
function infinite_HTVM_Lua_Loop_HTVM()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end

function LoopParseFunc(varString, delimiter1, delimiter2)
    local items = {}
    delimiter1 = delimiter1 or ""
    delimiter2 = delimiter2 or ""
    -- Changed: Don't escape the delimiters since we want them literal
    -- Just use them directly in the pattern
    if delimiter1 == "" and delimiter2 == "" then
        for i = 1, #varString do
            table.insert(items, varString:sub(i, i))
        end
    else
        -- Changed: Simplified pattern to directly match \n and \r
        local pattern = delimiter1 .. delimiter2
        for item in varString:gmatch("([^" .. pattern .. "]+)") do
            table.insert(items, item)
        end
    end
    return items
end

-- Regular loop example
for A_Index1 = 0 + 1 , 10 + 0 do
    if (A_Index1 % 2 == 0) then
        goto continue0
    end
    -- Output only odd numbers from 1 to 9
    print(A_Index1)
    ::continue0::
end

print("=====================")

-- Infinite loop example
for A_Index2 in infinite_HTVM_Lua_Loop_HTVM() do
    if (A_Index2 % 2 == 0) then
        goto continue1
    end
    -- Output only odd numbers from 1 to 9
    print(A_Index2)
    if (A_Index2 == 9) then
        break
    end
    ::continue1::
end

print("=====================")

-- Loop, Parse loop example
var1 = "hello whats up bro how are you doing"
items3 = LoopParseFunc(var1, " ")
for A_Index3 , A_LoopField3 in ipairs(items3) do
    A_LoopField3 = items3[A_Index3 - 0]
    if (A_LoopField3 == "bro") then
        goto continue2
    end
    -- 3 will never print
    print(A_Index3)
    ::continue2::
end
```

This approach with `::continue` is used only for the 3 types of loops but NOT the `while` loop.

> **Note:** Lua does not support a native `continue` statement. To mimic this behavior, we use a labeled `goto`—specifically `goto continue`—followed by a `::continue::` label at the end of the loop.  
> This approach is **only required when converting to Lua**. If you're using HTVM with JavaScript, Python etc... as the target language, there's **no need to write or worry about `::continue`**—it's automatically ignored or excluded in those environments.

---

### **Conclusion**

In HTVM, we have three main types of loops:

1. **Regular Loop** - `Loop,` - Simple iteration over a specified number of times.
2. **Loop Parse** - `Loop, Parse,` - Iterates over fields in a string or text, with customizable delimiters.
3. **Infinite Loop** - `Loop` - A loop that runs indefinitely until broken manually or a condition is met.
4. **While Loop** - `while` - A standard loop that runs while a condition is true.

Each of these loops is intuitive and makes it easy to handle a variety of looping needs. Make sure to use `A_Index` and `A_LoopField` where appropriate, and use the `continue` keyword to control loop flow. When converting to Lua, remember to add `::continue` just before the loop ends.

---



### Comments

[Go back](#htvm-documentation)

## **Comments in HTVM**

Comments are essential for writing clear and maintainable code. They allow you to document your code without affecting how it runs. In HTVM, there are different types of comments: **Standalone Comments**, **Multi-line Comments**, **Inline Comments**, and **Comments in Programming Blocks**. Here's how each of them works:

---

### **Standalone Comments:**

**Standalone comments** are written on their own line and **will convert** properly when transforming to **other HTVM languages** or any target programming languages. These comments are perfect for leaving explanations or notes that need to be preserved across conversions.

```htvm
; ✅ This comment will convert to any HTVM language or target language conversion.
```

**💡 Tip:** Standalone comments are **ideal** when you need your notes to **convert** correctly across different languages and maintain clarity for others who may work with your code.

---

### **Multi-line Comments:**

**Multi-line comments** are used for writing longer explanations or comments that span multiple lines. They must **always start and end on their own lines**—you cannot place extra text before or after the opening and closing markers. Inside multi-line comments, you can write as much text as you want.

```htvm
'''1
This is a multi-line comment.
It will be preserved in all conversions.
'''2
```

#### **⚠️ Important Rules:**
- The opening of a multi-line comment **must always be on its own line**. 
- The closing of a multi-line comment **must always be on its own line**.
- **🚨 WARNING**: If you write **code** inside multi-line comments, that code **MAY get converted** during language conversion! ❗️
  - The code **won’t run**, but **it could still appear in the final code**! 
  - This means that if you have code inside multi-line comments, **be extra cautious**. If you don’t want the code to be accidentally included or converted, consider using **regular standalone comments** instead.

**💡 Tip:** If you want the code inside multi-line comments to be **preserved** and not accidentally converted during the conversion process, **use regular standalone comments** instead of multi-line comments for code explanation. **Regular standalone comments** are safer for maintaining the integrity of your code.

**⚠️ You can't use multiline comments inside a `Gui` code block.**

---

### **Inline Comments:**

**Inline comments** are written on the same line as your code. They’re useful for short explanations but **will disappear** when converting to **another HTVM language** or to other programming languages (e.g., **Python**, **JavaScript**, **C++**, **etc.**). This makes them **not recommended**, especially if you're working with code that will be converted, as they might carry important context that others won’t be able to see.

```htvm
print("some text") ; ❌ is comment will disappear when converting to another HTVM language or any target language.
```

**⚠️ Important:** **Avoid** using inline comments whenever possible. Inline comments **will disappear** even when converting to another HTVM language. This is because they won’t be included in the converted code. If you rely on these comments for important context, it’s better to avoid using them. **Not recommended**, unless you know exactly what you’re doing, as it can lead to the loss of important information when others view or convert your code.

> *Note:* When converting code that includes Multiline Comments with commented-out code, the code will be converted into the target language as well. This ensures that even commented-out code is reflected in the converted language, making it easier for others to understand or reuse. This can be especially useful when converting to another HTVM language. For example, if someone is reading your code and has converted it to their own HTVM language, any commented-out code will be converted into their language, allowing them to read and understand what you intended to comment out. But only inside multiline comments will the code be converted into the target language.
>
> Regular Standalone Comments will also be converted, but only the comment keyword will be converted—nothing inside them will be converted. Only code inside Multiline Comments will be converted into the target language.
>
> But don’t worry, that code will not run because it’s just text, though it will be converted. This means you can use Multiline Comments to explain something without needing to include any code. Just plain text will work as well.

---

### **Comments in Programming Blocks:**

**Comments in programming blocks** must use the correct syntax for the target language. This is a **must**, not a best practice. You have to use the correct comment syntax based on the target language (e.g., **Python**, **JavaScript**, **C++**, **etc.**) inside their respective programming blocks.

```py
# This is a Python comment inside a Python programming block.
```

**⚠️ Important:** When working with **programming blocks**, make sure that you use the correct comment **syntax for that programming block language**. Otherwise, you may encounter issues in the code. Make sure you know which **characters** or **keywords** are used for comments in that language (for example, **#** for Python or **//** for JavaScript) to avoid mistakes.

---





### Error Handling

[Go back](#htvm-documentation)

Understand how to manage errors and handle exceptions in HTVM to make your programs more robust. HTVM provides simple ways to catch and handle errors, helping you write more stable and reliable code.

---







### Include

[Go back](#htvm-documentation)

Discover how to include external files and resources in your HTVM project for enhanced functionality. The **include** feature in HTVM allows you to integrate additional code or libraries into your project seamlessly.

---



### Commands

[Go back](#htvm-documentation)

Commands in HTVM are a simplified way to perform actions, similar to functions, but with a more compact, direct, and concise syntax for better efficiency. Commands help streamline your code and reduce unnecessary complexity.

### Commands in HTVM

**What is a Command?**  
In HTVM, commands are simple, intuitive building blocks that you use to perform actions in your code. They are inspired by AutoHotKey commands, but in HTVM, they automatically convert into function calls, making the process seamless. These commands are designed to be straightforward and concise, so you don’t need to worry about the underlying complexity of function definitions. When you write a command, HTVM handles converting it into an appropriate function call behind the scenes, allowing you to focus on logic rather than syntax.

Each command can accept one or more parameters, depending on its functionality, and follows a consistent format for easy readability and use.

### Structure of a Command  
A basic command looks like this:

```htvm
command, parameter1, parameter2, ...
```

Commands support multiple parameters and follow a simple, comma-separated format. Behind the scenes, these commands are transformed into corresponding function calls, which execute the desired actions with minimal keystrokes.

**⚠️ Disclaimer:**  
This command syntax is structured and follows a defined format: a command name followed by a comma, then a space, then the next value, and so on — like `text, text, text`. It is different from how GUI definitions work in HTVM. GUI syntax is far more flexible and allows you to do insane stuff, while commands follow this more controlled, predictable pattern.

#### Rules

We can have `OUTVAR` which means it will be `OUTVAR = funcName(...)`
So if we have `commandName, OUTVAR, someParam` that will equal `OUTVAR = commandName(someParam)` 

If we have `INVAR` which means it will be `funcName(INVAR ...)`
So if we have `commandName, INVAR, someParam` that will equal `commandName(INVAR, someParam)` 

If we have `INOUTVAR` which means it will be `INOUTVAR = funcName(INOUTVAR ...)`
So if we have `commandName, INOUTVAR, someParam` that will equal `INOUTVAR = commandName(INOUTVAR, someParam)` 

If we have `'` which means it will be `funcName(someParam ...)`
So if we have `commandName, someParam` that will equal `commandName("someParam")` 
Basically, it means it will wrap it in double quotes ("").

If we have `lineTranspile` it means it will do a replace.  
So if we have `someText, lineTranspile, replacementText`,  
that means if you put on a single line alone: `someText`,  
that will simply be replaced with `replacementText`.  
And if we have ~~~ in the replacement, it will be replaced with actual new lines.

Example:
If we define `greetUser, lineTranspile, print("Hello!")~~~print("Welcome to HTVM.")`  
Then this:

```htvm
greetUser
```

Will become:

```htvm
print("Hello!")
print("Welcome to HTVM.")
```

> ⚠️ **Important**: You **cannot** use the following characters inside commands: `,` `|` `%` — these are reserved and will break the parsing.

> If we have `'`, it means the param will be wrapped in double quotes. You **don’t actually type `'` in your code** — it’s just used here in the command definition to mark that param.

### Available Commands  
Here are all the available commands in this HTVM language:



```htvm
StringTrimLeft, OUTVAR, INVAR, param1
```



```htvm
StringTrimRight, OUTVAR, INVAR, param1
```



```htvm
Random, OUTVAR, param1, param2
```



```htvm
Sleep, INVAR
```



```htvm
FileRead, OUTVAR, 'param1
```



```htvm
FileAppend, INVAR, 'param1
```



```htvm
FileDelete, 'INVAR
```



```htvm
Sort, INOUTVAR, 'param1
```



```htvm
MsgBox, 'param1
```



This was all of them.

### Customizing Commands in HTVM  
You can configure and customize the syntax of commands—along with the rest of your HTVM language—on the [HTVM Syntax Configurator website](#https://themaster1127.github.io/HTVM/web-ui/). That’s where you define how your custom HTVM language behaves, including how commands are recognized and structured.

### Summary  
This is a comprehensive guide to the commands in HTVM. With the goal of reducing keystrokes and inspired by AutoHotKey, HTVM provides an intuitive way to program with less effort.  
To configure and customize your HTVM language, visit the [HTVM Syntax Configurator website](#https://themaster1127.github.io/HTVM/web-ui/). There you can adjust the commands, see how to define them, and other elements to create your own language and fit your coding needs.

### HTVM Philosophy  
HTVM is built on the idea of simplifying the coding experience through **minimal keystrokes**. It’s not about being lazy—it’s about being efficient. Traditional programming languages often burden the developer with excessive syntax, repetitive structures, and unnecessary complexity.

HTVM flips that by giving you clean, readable code that does more with less. While some may argue that AI can write code for you, HTVM emphasizes control and creativity—two things that get lost when you offload everything to an AI. Besides, coding is fun. You should be able to enjoy it without the clutter.  

HTVM is trying to make you code with **fewer keystrokes**. Commands are a direct reflection of this philosophy—they let you express complex logic in just a few words, automatically converting into efficient function calls with minimal effort.

---



### All Syntax

[Go back](#htvm-documentation)

#### Here is all of the syntax in this language:

<pre>
| kewWordName                                   | Syntax                               |
|-----------------------------------------------|-----------------------------------|
|  langToConvertTo  | cpp        |
|  langFileExtension  | htvm        |
|  commands  | StringTrimLeft,OUTVAR,INVAR,param1 \| StringTrimRight,OUTVAR,INVAR,param1 \| Random,OUTVAR,param1,param2 \| Sleep,INVAR \| FileRead,OUTVAR,'param1 \| FileAppend,INVAR,'param1 \| FileDelete,'INVAR \| Sort,INOUTVAR,'param1 \| MsgBox,'param1        |
|  keyWordAlliance  | alliance        |
|  keyWordCrew  | crew        |
|  keyWordProc  | proc        |
|  keyWordStruct  | struct        |
|  keyWordProp  | prop        |
|  keyWordThis  | this        |
|  keyWordInclude  | import        |
|  keyWordCodeInTheTranspiledLangStart  | ___start        |
|  keyWordCodeInTheTranspiledLangEnd  | ___end        |
|  keyWordCodeInTheTranspiledLangStartCPP  | ___cpp start        |
|  keyWordCodeInTheTranspiledLangEndCPP  | ___cpp end        |
|  keyWordCodeInTheTranspiledLangStartPY  | ___py start        |
|  keyWordCodeInTheTranspiledLangEndPY  | ___py end        |
|  keyWordCodeInTheTranspiledLangStartJS  | ___js start        |
|  keyWordCodeInTheTranspiledLangEndJS  | ___js end        |
|  keyWordCodeInTheTranspiledLangStartGO  | ___go start        |
|  keyWordCodeInTheTranspiledLangEndGO  | ___go end        |
|  keyWordCodeInTheTranspiledLangStartLUA  | ___lua start        |
|  keyWordCodeInTheTranspiledLangEndLUA  | ___lua end        |
|  keyWordCodeInTheTranspiledLangStartCS  | ___cs start        |
|  keyWordCodeInTheTranspiledLangEndCS  | ___cs end        |
|  keyWordCodeInTheTranspiledLangStartJAVA  | ___java start        |
|  keyWordCodeInTheTranspiledLangEndJAVA  | ___java end        |
|  keyWordCodeInTheTranspiledLangStartKT  | ___kt start        |
|  keyWordCodeInTheTranspiledLangEndKT  | ___kt end        |
|  keyWordCodeInTheTranspiledLangStartRB  | ___rb start        |
|  keyWordCodeInTheTranspiledLangEndRB  | ___rb end        |
|  keyWordCodeInTheTranspiledLangStartNIM  | ___nim start        |
|  keyWordCodeInTheTranspiledLangEndNIM  | ___nim end        |
|  keyWordCodeInTheTranspiledLangStartAHK  | ___ahk start        |
|  keyWordCodeInTheTranspiledLangEndAHK  | ___ahk end        |
|  keyWordCodeInTheTranspiledLangStartSWIFT  | ___swift start        |
|  keyWordCodeInTheTranspiledLangEndSWIFT  | ___swift end        |
|  keyWordCodeInTheTranspiledLangStartDART  | ___dart start        |
|  keyWordCodeInTheTranspiledLangEndDART  | ___dart end        |
|  keyWordCodeInTheTranspiledLangStartTS  | ___ts start        |
|  keyWordCodeInTheTranspiledLangEndTS  | ___ts end        |
|  keyWordCodeInTheTranspiledLangStartGROOVY  | ___groovy start        |
|  keyWordCodeInTheTranspiledLangEndGROOVY  | ___groovy end        |
|  keyWordCodeInTheTranspiledLangStartHTVM  | ___htvm start        |
|  keyWordCodeInTheTranspiledLangEndHTVM  | ___htvm end        |
|  keyWordCodeInHTVMstart  | ___inhtvm start        |
|  keyWordCodeInHTVMend  | ___inhtvm end        |
|  keyWordCurlyBraceOpen  | {        |
|  keyWordCurlyBraceClose  | }        |
|  keyWordNull  | null        |
|  keyWordTrue  | true        |
|  keyWordFalse  | false        |
|  keyWordVoid  | void        |
|  keyWordDouble  | double        |
|  keyWordChar  | char        |
|  keyWordUint8  | uint8        |
|  keyWordUint16  | uint16        |
|  keyWordUint32  | uint32        |
|  keyWordUint64  | uint64        |
|  keyWordINT  | int        |
|  keyWordSTR  | str        |
|  keyWordBOOL  | bool        |
|  keyWordFLOAT  | float        |
|  keyWordINT8  | int8        |
|  keyWordINT16  | int16        |
|  keyWordINT32  | int32        |
|  keyWordINT64  | int64        |
|  keyWordIF  | if        |
|  keyWordElseIf  | else if        |
|  keyWordElse  | else        |
|  keyWordWhileLoop  | while        |
|  keyWordLoopInfinite  | Loop        |
|  keyWordLoop  | Loop,        |
|  keyWordLoopParse  | Loop, Parse,        |
|  keyWordContinue  | continue        |
|  keyWordBreak  | break        |
|  keyWordFunc  | func        |
|  keyWordAwait  | await        |
|  keyWordAsync  | async        |
|  keyWordThrow  | throw        |
|  keyWordErrorMsg  | ErrorMsg        |
|  keyWordTry  | try        |
|  keyWordCatch  | catch        |
|  keyWordFinally  | finally        |
|  keyWordReturnStatement  | return        |
|  keyWordArrayAppend  | .add        |
|  keyWordArrayPop  | .pop        |
|  keyWordArraySize  | .size        |
|  keyWordArrayInsert  | .insert        |
|  keyWordArrayRemove  | .rm        |
|  keyWordArrayIndexOf  | .indexOf        |
|  keyWordArrayDefinition  | arr        |
|  keyWordArrayOfIntegersDefinition  | arr int        |
|  keyWordArrayOfStringsDefinition  | arr str        |
|  keyWordArrayOfFloatingPointNumbersDefinition  | arr float        |
|  keyWordArrayOfBooleansDefinition  | arr bool        |
|  keyWordVar  | var        |
|  keyWordLet  | let        |
|  keyWordConst  | const        |
|  keyWordEnd  | end        |
|  keyWordGlobal  | global        |
|  keyWordComment  | ;        |
|  keyWordCommentOpenMultiLine  | `'`'`'`1        |
|  keyWordCommentCloseMultiLine  | `'`'`'`2        |
|  keyWordEscpaeChar  | `        |
|  keyWordMainLabel  | main        |
|  keyWordConcat  | .        |
|  keyWordAdd  | +        |
|  keyWordSub  | -        |
|  keyWordMul  | *        |
|  keyWordDiv  | /        |
|  keyWordMod  | %        |
|  keyWordExp  | **        |
|  keyWordEqual  | =        |
|  keyWordStrictEqual  | ===        |
|  keyWordNotEqual  | !=        |
|  keyWordGreater  | &gt;        |
|  keyWordLess  | &lt;        |
|  keyWordGreaterEqual  | &gt;=        |
|  keyWordLessEqual  | &lt;=        |
|  keyWordAnd  | and        |
|  keyWordOr  | or        |
|  keyWordNot  | !        |
|  keyWordBitAnd  | &amp;        |
|  keyWordBitOr  | \|        |
|  keyWordBitXor  | ^        |
|  keyWordBitNot  | ~        |
|  keyWordShiftLeft  | &lt;&lt;        |
|  keyWordShiftRight  | &gt;&gt;        |
|  keyWordShiftUnsignedRight  | &gt;&gt;&gt;        |
|  keyWordAssign  | :=        |
|  keyWordAssignAdd  | +=        |
|  keyWordAssignConcat  | .=        |
|  keyWordAssignSub  | -=        |
|  keyWordAssignMul  | *=        |
|  keyWordAssignDiv  | /=        |
|  keyWordAssignMod  | %=        |
|  keyWordAssignShiftLeft  | &lt;&lt;=        |
|  keyWordAssignShiftRight  | &gt;&gt;=        |
|  keyWordLogicalAssignShiftRight  | &gt;&gt;&gt;=        |
|  keyWordAssignBitAnd  | &amp;=        |
|  keyWordAssignBitOr  | \|=        |
|  keyWordAssignBitXor  | ^=        |
|  keyWordTernary1  | ?        |
|  keyWordTernary2  | :        |
|  keyWordInc  | ++        |
|  keyWordDec  | --        |
|  AHKlikeLoopsIndexedAt  | 0        |
|  keyWordAIndex  | A_Index        |
|  keyWordALoopField  | A_LoopField        |
|  useCurlyBraces  | on        |
|  useEnd  | off        |
|  useSemicolon  | off        |
|  useParentheses  | on        |
|  usePrefixTypeForTypeDefinition  | on        |
|  usePostfixTypeForTypeDefinition  | off        |
|  usePythonicColonSyntax  | off        |
|  useCurlyBracesSyntaxForArrayDef  | off        |
|  useInJavaScriptAlwaysUseVar  | on        |
|  useJavaScriptInAfullHTMLfile  | off        |
|  useJavaScriptAmainFuncDef  | off        |
|  useJavaScriptAllFuncsAreAsync  | on        |
|  useJavaScriptAlwaysTripleEqual  | off        |
<pre>


---


## Built-in Functions  

[Go back](#htvm-documentation) 

HTVM includes a variety of built-in functions organized into categories for convenience.

1. [Math Functions](#math-functions)
2. [String Functions](#string-functions)
3. [System Functions](#system-functions)
4. [File Functions](#file-functions)
5. [Io Functions](#io-functions)
6. [Other Functions](#other-functions)
7. [Gui Functions](#gui-functions)
8. [Backend Functions](#backend-functions)

---

## Math Functions

[Go back](#built-in-functions)

1. [ACos](#acos)
2. [ASin](#asin)
3. [ATan](#atan)
4. [Abs](#abs)
5. [Ceil](#ceil)
6. [Cos](#cos)
7. [Exp](#exp)
8. [Floor](#floor)
9. [Ln](#ln)
10. [Log](#log)
11. [Mod](#mod)
12. [Random](#random)
13. [Round](#round)
14. [Sin](#sin)
15. [Sqrt](#sqrt)
16. [Tan](#tan)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| ACos | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| ASin | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| ATan | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Abs | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Ceil | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Cos | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Exp | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Floor | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Ln | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Log | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Mod | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Random | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Round | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Sin | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Sqrt | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Tan | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

---

### ACos

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| ACos | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

ACos is a function that returns the arc cosine (inverse cosine) of a number, which must be between -1 and 1.
here is how the func looks like:
```htvm
ACos(float)
```

---
### ASin

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| ASin | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

ASin is a function that calculates the arcsine (inverse sine) of a given value, throwing an error if the value is outside the range of -1 to 1.
here is how the func looks like:
```htvm
ASin(float value)
```

---
### ATan

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| ATan | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

ATan is a function that calculates the arctangent of a number, returning the angle in radians.
here is how the func looks like:
```htvm
ATan(float)
```

---
### Abs

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Abs | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Abs is a function that returns the absolute value of the provided number.
here is how the func looks like:
```htvm
Abs(int value)
```

---
### Ceil

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Ceil | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Ceil is a function that takes a numerical value and returns the smallest integer greater than or equal to that value.
here is how the func looks like:
```htvm
Ceil(num)
```

---
### Cos

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Cos | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Cos is a function that calculates the cosine of a given angle in radians.
here is how the func looks like:
```htvm
Cos(float angle)
```

---
### Exp

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Exp | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Exp is a function that takes a numeric value and returns the value of e raised to the power of the given value using the Math.exp() function.
here is how the func looks like:
```htvm
Exp(value)
```

---
### Floor

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Floor | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Floor is a function that returns the largest integer less than or equal to a given number, or NaN if the input is not a number.
here is how the func looks like:
```htvm
Floor(num)
```

---
### Ln

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Ln | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Ln is a function that calculates the natural logarithm (base e) of a given value.
here is how the func looks like:
```htvm
Ln(int value)
```

---
### Log

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Log | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Log is a function that calculates the base 10 logarithm of a given value.
here is how the func looks like:
```htvm
Log(int value)
```

---
### Mod

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Mod | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Mod is a function that returns the remainder when the dividend is divided by the divisor.
here is how the func looks like:
```htvm
Mod(int dividend, int divisor)
```

---
### Random

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Random | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Random is a function that generates and returns a random integer between a specified minimum and maximum value, inclusive.
here is how the func looks like:
```htvm
Random(min, max)
```

---
### Round

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Round | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Round is a function that rounds a given numeric value to the nearest integer.
here is how the func looks like:
```htvm
Round(num)
```

---
### Sin

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Sin | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Sin is a function that takes an angle (in radians) and returns the sine of that angle.
here is how the func looks like:
```htvm
Sin(float)
```

---
### Sqrt

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Sqrt | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Sqrt is a function that calculates the square root of a given numeric value.
here is how the func looks like:
```htvm
Sqrt(num)
```

---
### Tan

[Go back](#math-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Tan | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Tan is a function that calculates the tangent of the given angle (in radians).
here is how the func looks like:
```htvm
Tan(float)
```

---
## String Functions

[Go back](#built-in-functions)

1. [Asc](#asc)
2. [Chr](#chr)
3. [FLOAT](#float)
4. [INT](#int)
5. [InStr](#instr)
6. [RegExMatch](#regexmatch)
7. [RegExReplace](#regexreplace)
8. [STR](#str)
9. [Sort](#sort)
10. [StrLen](#strlen)
11. [StrLower](#strlower)
12. [StrReplace](#strreplace)
13. [StrSplit](#strsplit)
14. [StrTitleCase](#strtitlecase)
15. [StringTrimLeft](#stringtrimleft)
16. [StringTrimRight](#stringtrimright)
17. [SubStr](#substr)
18. [Trim](#trim)
19. [countChars](#countchars)
20. [getUrlParams](#geturlparams)
21. [sortArr](#sortarr)
22. [sortArrByLenOnly](#sortarrbylenonly)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Asc | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Chr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| FLOAT | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| INT | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| InStr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| RegExMatch | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| RegExReplace | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| STR | Yes | Yes | Yes | Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |
| Sort | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StrLen | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StrLower | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StrReplace | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StrSplit | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StrTitleCase | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StringTrimLeft | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| StringTrimRight | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| SubStr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Trim | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| countChars | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| getUrlParams | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| sortArr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| sortArrByLenOnly | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

---

### Asc

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Asc | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Asc is a function that takes a string and returns the ASCII value of its first character, or -1 if the string is empty.
here is how the func looks like:
```htvm
Asc(str s)
```

---
### Chr

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Chr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Chr is a function that returns the character corresponding to the given Unicode code point or an empty string if the number is out of range.
here is how the func looks like:
```htvm
Chr(int number)
```

---
### FLOAT

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FLOAT | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

FLOAT is a function that converts a given value to a float and throws an error if the value cannot be converted.
here is how the func looks like:
```htvm
FLOAT(str value)
```

---
### INT

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| INT | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

INT is a function that converts a value to an integer, throwing an error if the conversion fails.
here is how the func looks like:
```htvm
INT(str value)
```

---
### InStr

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| InStr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

InStr is a function that finds the position of the substring needle within the string haystack and returns its position (1-based index), or 0 if the substring is not found.
here is how the func looks like:
```htvm
InStr(str haystack, str needle)
```

---
### RegExMatch

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| RegExMatch | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

RegExMatch is a function that returns the 1-based index of the first regex match or 0 if no match is found.
here is how the func looks like:
```htvm
RegExMatch(str haystack, str needle)
```

---
### RegExReplace

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| RegExReplace | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

RegExReplace is a function that performs a regular expression-based replacement on a string using a given pattern and replacement string.
here is how the func looks like:
```htvm
RegExReplace(str inputStr, str regexPattern, str replacement)
```

---
### STR

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| STR | Yes | Yes | Yes | Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |

STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.
here is how the func looks like:
```htvm
STR(value)
```

---
### Sort

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Sort | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Sort is a function that takes a string and optional options to sort its elements based on various criteria such as numeric, random, alphabetical, case sensitivity, and more, with support for delimiters and unique filtering.
here is how the func looks like:
```htvm
Sort(str varName, [str options = ""])
```

---
### StrLen

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StrLen | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StrLen is a function that takes a string as input and returns its length as a size_t value.
here is how the func looks like:
```htvm
StrLen(str)
```

---
### StrLower

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StrLower | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StrLower is a function that takes a string as input and converts all characters to lowercase.
here is how the func looks like:
```htvm
StrLower(string)
```

---
### StrReplace

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StrReplace | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StrReplace is a function that takes an original string, a substring to find, and a substring to replace it with, returning the modified string.
here is how the func looks like:
```htvm
StrReplace(str originalString, str find, str replaceWith)
```

---
### StrSplit

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StrSplit | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StrSplit is a function that splits an input string by a specified delimiter and returns the part at the specified index, or an empty string if the index is out of range.
here is how the func looks like:
```htvm
StrSplit(str inputStr, str delimiter, int num)
```

---
### StrTitleCase

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StrTitleCase | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StrTitleCase is a function that takes an input string and converts each word to title case, capitalizing the first letter of each word while making the rest lowercase.
here is how the func looks like:
```htvm
StrTitleCase(str inputString)
```

---
### StringTrimLeft

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StringTrimLeft | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StringTrimLeft is a function that trims a specified number of characters from the left side of a given string.
here is how the func looks like:
```htvm
StringTrimLeft(str input, int numChars)
```

---
### StringTrimRight

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| StringTrimRight | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

StringTrimRight is a function that trims a specified number of characters from the right side of a given string.
here is how the func looks like:
```htvm
StringTrimRight(str input, int numChars)
```

---
### SubStr

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| SubStr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

SubStr is a function that extracts a substring from a given string, starting from a specified position and for a specified length, adjusting for edge cases like null inputs or missing parameters.
here is how the func looks like:
```htvm
SubStr(str, int startPos, int length [= str.length - startPos + 1])
```

---
### Trim

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Trim | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Trim is a function that removes leading and trailing whitespace from the input string.
here is how the func looks like:
```htvm
Trim(string)
```

---
### countChars

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| countChars | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

countChars is a function that counts the occurrences of a specific character (`theChar`) in a given string.
here is how the func looks like:
```htvm
countChars(str string, str theChar)
```

---
### getUrlParams

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| getUrlParams | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

getUrlParams is a function that extracts and decodes parameter values from the URL query string, returning a combined string of values separated by '&'.
here is how the func looks like:
```htvm
getUrlParams()
```

---
### sortArr

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| sortArr | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

sortArr is a function that takes an array, removes any duplicate values using a Set, and returns the array sorted in ascending order.
here is how the func looks like:
```htvm
sortArr(arr str stringArray)
```

---
### sortArrByLenOnly

[Go back](#string-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| sortArrByLenOnly | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

sortArrByLenOnly is a function that sorts an array of strings by length in descending order
here is how the func looks like:
```htvm
sortArrByLenOnly(arr str array)
```

---
## System Functions

[Go back](#built-in-functions)

1. [BuildInVars](#buildinvars)
2. [ExitApp](#exitapp)
3. [HTVM_getLang_HTVM](#htvm_getlang_htvm)
4. [Sleep](#sleep)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| BuildInVars | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| ExitApp | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| HTVM_getLang_HTVM | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| Sleep | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

---

### BuildInVars

[Go back](#system-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| BuildInVars | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

BuildInVars is a function that retrieves various system-related values or states, including screen dimensions, timestamps, key presses, and more, based on the specified variable name.
here is how the func looks like:
```htvm
BuildInVars(str varName)
```

---
### ExitApp

[Go back](#system-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| ExitApp | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

ExitApp is a function that terminates the application immediately.
here is how the func looks like:
```htvm
ExitApp()
```

---
### HTVM_getLang_HTVM

[Go back](#system-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| HTVM_getLang_HTVM | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

HTVM_getLang_HTVM is a func that returns the current language of HTVM as a string
here is how the func looks like:
```htvm
HTVM_getLang_HTVM()
```

---
### Sleep

[Go back](#system-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| Sleep | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

Sleep is a function that pauses execution for a specified number of milliseconds.
here is how the func looks like:
```htvm
Sleep(int milliseconds)
```

---
## File Functions

[Go back](#built-in-functions)

1. [FileAppend](#fileappend)
2. [FileAppendJs](#fileappendjs)
3. [FileCreateDir](#filecreatedir)
4. [FileDelete](#filedelete)
5. [FileExist](#fileexist)
6. [FileRead](#fileread)
7. [FileRemoveDir](#fileremovedir)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileAppend | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| FileAppendJs | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| FileCreateDir | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| FileDelete | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| FileExist | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| FileRead | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| FileRemoveDir | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

---

### FileAppend

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileAppend | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileAppend is a function that appends the given content to a file at the specified path and returns a boolean indicating success or failure.
here is how the func looks like:
```htvm
FileAppend(str content, str path)
```

---
### FileAppendJs

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileAppendJs | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

FileAppendJs is a function that appends content to a file by creating a Blob, generating a download link, and triggering a download with the specified filename.
here is how the func looks like:
```htvm
FileAppendJs(str content, str filename)
```

---
### FileCreateDir

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileCreateDir | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileCreateDir is a function that checks if a directory exists, and if not, it creates the directory.
here is how the func looks like:
```htvm
FileCreateDir(str directory)
```

---
### FileDelete

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileDelete | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileDelete is a function that checks if a file exists at the given path and deletes it if found, returning True if the file is deleted, otherwise False.
here is how the func looks like:
```htvm
FileDelete(str path)
```

---
### FileExist

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileExist | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileExist is a function that checks if a file or directory exists at the specified path.
here is how the func looks like:
```htvm
FileExist(str path)
```

---
### FileRead

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileRead | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileRead is a function that reads the content of a file given a path, prepends the current working directory if the path is not absolute, and returns the file content as a string.
here is how the func looks like:
```htvm
FileRead(path: str)
```

---
### FileRemoveDir

[Go back](#file-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| FileRemoveDir | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

FileRemoveDir is a function that removes a directory and its contents if the directory exists.
here is how the func looks like:
```htvm
FileRemoveDir(str directory)
```

---
## Io Functions

[Go back](#built-in-functions)

1. [GetParams](#getparams)
2. [RunCMD](#runcmd)
3. [getDataFromAPI](#getdatafromapi)
4. [input](#input)
5. [print](#print)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| GetParams | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| RunCMD | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |
| getDataFromAPI | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| input | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| print | Yes | Yes | Yes | Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |

---

### GetParams

[Go back](#io-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| GetParams | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

GetParams is a function that retrieves command line arguments, checks if they correspond to existing paths, and returns them as absolute paths in new lines, or as they are if they do not exist.
here is how the func looks like:
```htvm
GetParams()
```

---
### RunCMD

[Go back](#io-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| RunCMD | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

RunCMD is a function that executes a shell command and captures its output or errors.
here is how the func looks like:
```htvm
RunCMD(str command)
```

---
### getDataFromAPI

[Go back](#io-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| getDataFromAPI | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

getDataFromAPI is a function that asynchronously fetches JSON data from a given URL and returns it, handling errors and non-OK responses.
here is how the func looks like:
```htvm
getDataFromAPI(str url)
```

---
### input

[Go back](#io-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| input | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

input is a function that displays a prompt with the given text and returns the user's input.
here is how the func looks like:
```htvm
input(str promptText)
```

---
### print

[Go back](#io-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| print | Yes | Yes | Yes | Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |Yes |

print is a function that outputs the specified data to the console or standard output.
here is how the func looks like:
```htvm
print(str)
```

---
## Other Functions

[Go back](#built-in-functions)

1. [HTVM_v2_HTVM](#htvm_v2_htvm)
2. [MakeHotKey](#makehotkey)
3. [isWindows](#iswindows)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| HTVM_v2_HTVM | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| MakeHotKey | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |
| isWindows | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

---

### HTVM_v2_HTVM

[Go back](#other-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| HTVM_v2_HTVM | Yes | Yes | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

HTVM_v2_HTVM is a func that will help me make HTVM v2 DONT USE IT!!!

---
### MakeHotKey

[Go back](#other-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| MakeHotKey | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

MakeHotKey is a function that listens for a specific key combination (hotkey) and triggers a callback when the hotkey is pressed. It handles modifiers like Ctrl, Shift, and Alt, as well as specific keys such as arrows and backspace. The callback function is invoked with the hotkey in either uppercase or lowercase, depending on the Shift modifier.
here is how the func looks like:
```htvm
MakeHotKey(str hotkey, function callback)
```

---
### isWindows

[Go back](#other-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| isWindows | Yes | Yes | No | No |No |No |No |No |No |No |No |No |No |No |No |

isWindows is a function that checks if the current operating system is Windows by comparing the system name to "windows".
here is how the func looks like:
```htvm
isWindows()
```

---
## Gui Functions

[Go back](#built-in-functions)

1. [MsgBox](#msgbox)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| MsgBox | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

---

### MsgBox

[Go back](#gui-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| MsgBox | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

MsgBox is a function that displays a message box with customizable text, title, buttons, and icons, handling various options based on the provided value and timeout.
here is how the func looks like:
```htvm
MsgBox(str text, str [title = " "], int [value = 0], int [timeout = null])
```

---
## Backend Functions

[Go back](#built-in-functions)

1. [callBackend](#callbackend)

---

**HTVM built-in functions are designed to work mostly across C++, Python, JavaScript, Go, Lua, C#, Java, Kotlin, Ruby, Nim, AutoHotKey, Swift, Dart, TypeScript and Groovy with availability varying depending on language-specific capabilities, libraries, and syntax. Some functions are supported in JavaScript but not in Python or C++ and others and many other combinations, while others are available in all or some languages.**

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| callBackend | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

---

### callBackend

[Go back](#backend-functions)

**HTVM build-in functions availability.**

| Functions | C++   | Python | JavaScript | Go   | Lua   | C#   | Java   | Kotlin | Ruby  | Nim   | AutoHotKey | Swift | Dart  | TypeScript | Groovy |
|-----------|-------|--------|------------|------|-------|------|--------|--------|-------|-------|------------|-------|-------|------------|--------|
| callBackend | No | No | Yes | No |No |No |No |No |No |No |No |No |No |No |No |

callBackend is a function that fetches data from a specified endpoint using a provided HTTP method (default is POST), sends the textData as a string, and parses the response based on its content type.
here is how the func looks like:
```htvm
callBackend(endpoint, textData, [method = "POST"])
```

---


</div>

    <br><br>

    <!-- A div to display the rendered HTML -->
    <div id="markdown-output"></div>

    <script>
        // Initialize Markdown-it with HTML enabled and proper heading IDs
        var md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true
        });
        
        function changeFaviconAtTheBeginning(faviconUrl) {
        // Create a new favicon link element
        const newFavicon = document.createElement("link");
        newFavicon.rel = "icon";
        newFavicon.href = faviconUrl;

        // Get the current favicon element (if exists)
        const existingFavicon = document.querySelector('link[rel="icon"]');

        // Replace the current favicon with the new one
        if (existingFavicon) {
          // If a favicon exists, replace it
          document.head.removeChild(existingFavicon); // Remove the existing favicon
        }

        // Append the new favicon to the head
        document.head.appendChild(newFavicon);
      }

      // Call the function with the desired favicon URL
      changeFaviconAtTheBeginning("https://i.ibb.co/Jpty1B8/305182938-1a0efe63-726e-49ca-a13c-d0ed627f2ea7.png");

      function showCustomMessageBox(options, title, text, value, timeout) {
        return new Promise((resolve) => {
          // Define default options for the message box
          let defaultOptions = {
            title: title || "", // Default title is empty
            text: text || "Press OK to continue.", // Default text if not provided
            showCancelButton: false, // Default is to not show Cancel button
            showDenyButton: false, // Default is to not show Deny button
            confirmButtonText: "OK", // Default text for OK button
            focusConfirm: true, // Default focus on OK button
          };

          let numOriginal = value;

          let num = numOriginal;

          let done1 = 0;

          let done2 = 0;

          let done3 = 0;

          let AIndex = 0;

          for (AIndex = 1; AIndex <= 1; AIndex++) {
            // this is about if you add always on top in a msgbox it will be removed in js cuz its kinda useless...
            // becouse if you like adding always on top in ahk in js we dont realy do it so yeah
            if (num >= 262144) {
              num = num - 262144;
              numOriginal = numOriginal - 262144;
            }

            if (num >= 256 && num < 500) {
              num = num - 256;

              done3 = 256;
            }

            if (num >= 512) {
              num = num - 512;

              done3 = 512;
            }

            if (num == 0) {
              done1 = 0;

              break;
            }

            if (num <= 6) {
              done1 = num;

              break;
            }

            if (num >= 64 && num < 64 * 2) {
              done2 = 64;

              if (num == 64) {
                done1 = 0;

                break;
              } else {
                done1 = num - 64;

                break;
              }
            }

            if (num >= 48 && num < 63) {
              done2 = 48;

              if (num == 48) {
                done1 = 0;

                break;
              } else {
                done1 = num - 48;

                break;
              }
            }

            if (num >= 32 && num < 47) {
              done2 = 32;

              if (num == 32) {
                done1 = 0;

                break;
              } else {
                done1 = num - 32;

                break;
              }
            }

            if (num >= 16 && num < 30) {
              done2 = 16;

              if (num == 16) {
                done1 = 0;

                break;
              } else {
                done1 = num - 16;

                break;
              }
            }
          }

          let doneAdded = done1 + done2 + done3;

          if (doneAdded !== numOriginal) {
            // displayMessage("The calc was wrong!");
          } else {
            // displayMessage("num was: " + numOriginal + "\ndone1: " + done1 + "\ndone2: " + done2 + "\ndone3: " + done3);
          }

          // Parse the value to determine the options for the message box
          if (done1 === 1) defaultOptions.showCancelButton = true; // OK/Cancel in ahk but here it will show Ok/Cancel wiat its same haha

          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 2) {
          //     defaultOptions.showCancelButton = true; // Abort/Retry/Ignore
          //     defaultOptions.showDenyButton = true;
          //   }
          if (done1 === 3) {
            defaultOptions.showCancelButton = true; // Yes/No/Cancel in ahk but here it will show Ok/No/Cancel
            defaultOptions.showDenyButton = true;
          }
          if (done1 === 4) {
            // defaultOptions.showCancelButton = true;
            defaultOptions.showDenyButton = true; // Yes/No in ahk but here it will show Ok/No
          }
          if (done1 === 5) {
            defaultOptions.showCancelButton = true; // Retry/Cancel in ahk but here it will show Ok/Cancel tip you can write in the Msgbox press ok to retry
          }
          // not gonna work if you can make it work i will appreciate
          //   if (done1 === 6) {
          //     defaultOptions.showCancelButton = true; // Cancel/Try Again/Continue
          //     defaultOptions.showDenyButton = true;
          //   }

          if (done2 === 16) defaultOptions.icon = "error"; // Icon Hand (stop/error)
          if (done2 === 32) defaultOptions.icon = "question"; // Icon Question
          if (done2 === 48) defaultOptions.icon = "warning"; // Icon Exclamation
          if (done2 === 64) defaultOptions.icon = "info"; // Icon Asterisk (info)

          if (done3 === 256) defaultOptions.focusDeny = true; // Makes the 3rd button the default
          if (done3 === 512) defaultOptions.focusCancel = true; // Makes the 2nd button the default

          // Set timeout if provided
          if (timeout) {
            defaultOptions.timer = timeout * 1000; // Convert timeout to milliseconds
          }

          // Merge default options with provided options
          Object.assign(defaultOptions, options);

          // Display the message box with the constructed options
          Swal.fire(defaultOptions).then((result) => {
            if (result.isConfirmed) {
              resolve("OK");
            } else if (result.isDenied) {
              resolve("No");
            } else {
              resolve("Cancel");
            }
          });
        });
      }

      var lastKeyPressed = "";

      function trackLastKeyPressed() {
        document.addEventListener("keydown", function (event) {
          lastKeyPressed = event.key;
          // console.log(lastKeyPressed);
        });
      }

      function getLastKeyPressed() {
        return lastKeyPressed;
      }

      // Call the trackLastKeyPressed function to start tracking key presses
      trackLastKeyPressed();

      let lastInputTime = Date.now(); // Initialize with current timestamp
      let startTimestamp = Date.now(); // Initialize with current timestamp

      // Event listener to track user activity
      function resetIdleTimer() {
        lastInputTime = Date.now(); // Update last input time
      }

      document.addEventListener("mousemove", resetIdleTimer);
      document.addEventListener("keypress", resetIdleTimer);

      // Function to calculate time since last input event
      function A_TimeIdle() {
        return Date.now() - lastInputTime; // Calculate time difference
      }

      function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}

function print(value) {
    console.log(value)
}

// Convert value to string
function STR(value) {
    if (value === null || value === undefined) {
        return ""; // Return a string for null or undefined
    } else if (typeof value === 'number') {
        return value.toString();
    } else if (typeof value === 'boolean') {
        return value ? "1" : "0";
    } else if (typeof value === 'string') {
        return value; // Return the string as is
    } else {
        // Handle any unexpected types gracefully
        return String(value); // Convert any other type to a string
    }
}

function Chr(number) {
    // Return the character corresponding to the Unicode code point, or an empty string if out of range
    return (number >= 0 && number <= 0x10FFFF) ? String.fromCharCode(number) : "";
}

function SubStr(str, startPos, length = -1) {
    // If str is null or undefined, return an empty string
    if (str === null || str === undefined) {
        return "";
    }
    let strLen = str.length;
    
    // Handle negative starting positions (C++ style)
    if (startPos < 1) {
        startPos = strLen + startPos;
        if (startPos < 0) startPos = 0;
    } else {
        startPos -= 1; // Convert to 0-based index (C++ style)
    }
    // Handle length (C++ style)
    if (length < 0) {
        length = strLen - startPos; // Length to end of string
    } else if (startPos + length > strLen) {
        length = strLen - startPos; // Adjust length to fit within the string
    }
    // Extract the substring
    return str.substr(startPos, length);
}

function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}

function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}

function StrLower(string) {
    return string.toLowerCase();
}

function StrSplit(inputStr, delimiter, num) {
    const parts = inputStr.split(delimiter);
    return (num > 0 && num <= parts.length) ? parts[num - 1] : "";
}

// Function to sort and remove duplicates
function sortArr(inputArray) {
    // Remove duplicates using Set and sort the array
    return [...new Set(inputArray)].sort();
}

function countChars(string, theChar) {
    let count = 0;
    for (let char of string) {
        if (char === theChar) {
            count++;
        }
    }
    return count;
}


//

function StrTitleCase(inputString) {
    return inputString.split(' ')  // Split the string into words
        .map(word => {
            if (word) {  // Avoid empty words (multiple spaces)
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();  // Capitalize first letter
            }
            return word;  // If it's an empty string (spaces), keep it as is
        })
        .join(' ');  // Join the words back together with spaces
}

function HTVM_getLang_HTVM() {
    return "js";
}

function HTVM_Append(arr, value) {
    arr.push(value);
}

function HTVM_Size(arr) {
    return arr.length;
}

      // Function to calculate tick count in milliseconds
      function A_TickCount() {
        return Date.now() - startTimestamp;
      }

      function GuiControl(action, id, param1, param2, param3, param4) {
        const element = document.getElementById(id);
        if (element) {
          // Handle DOM elements
          if (action === "move") {
            // Set position and size
            element.style.left = param1 + "px";
            element.style.top = param2 + "px";
            element.style.width = param3 + "px";
            element.style.height = param4 + "px";
          } else if (action === "focus" && (element instanceof HTMLInputElement || element instanceof HTMLElement)) {
            // Focus on the element
            element.focus();
          } else if (action === "text") {
            // Set new text content
            element.textContent = param1;
          } else if (action === "hide") {
            // Hide the element
            element.style.display = "none";
          } else if (action === "show") {
            // Show the element
            element.style.display = "";
          } else if (action === "enable") {
            // Enable the element
            element.disabled = false;
          } else if (action === "disable") {
            // Disable the element
            element.disabled = true;
          } else if (action === "font") {
            // Set font size
            element.style.fontSize = param1 + "px";
          } else if (action === "destroy") {
            // Remove the element from the DOM
            element.parentNode.removeChild(element);
          } else if (action === "color") {
            // Set color
            element.style.color = param1;
          } else if (action === "picture") {
            // Change the image source
            if (element instanceof HTMLImageElement) {
              element.src = param1;
            } else {
              console.error("Element is not an <img> tag, cannot change picture.");
            }
          } else if (action === "textide") {
            // Set value for Ace editor
            var editor = ace.edit(id); // Access the Ace editor instance using its ID
            if (editor && param1) {
              editor.session.setValue(param1);
            } else {
              console.error("Element is not an Ace editor or parameter is missing.");
            }
          }
        } else {
          // Handle canvas or non-existing element
          if (action === "move") {
            // Update position and size of the rectangle
            updateRectangle(id, param1, param2, param3, param4);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          } else if (action === "color") {
            // Update color of the rectangle
            updateRectangleColor(id, param1);
            redrawCanvas(); // Redraw the canvas with updated rectangles
          }
        }
      }

      function BuildInVars(varName) {
        switch (varName) {
          case "A_ScreenWidth":
            // Return screen width
            return window.innerWidth;
          case "A_LastKey":
            // Return screen width
            return getLastKeyPressed();
          case "A_ScreenHeight":
            // Return screen height
            return window.innerHeight;
          case "A_TimeIdle":
            // Return time idle
            return A_TimeIdle();
          case "A_TickCount":
            // Return tick count in milliseconds
            return A_TickCount();
          case "A_Now":
            // Return current local timestamp
            return new Date().toLocaleString();
          case "A_YYYY":
            // Return current year
            return new Date().getFullYear();
          case "A_MM":
            // Return current month
            return (new Date().getMonth() + 1).toString().padStart(2, "0");
          case "A_DD":
            // Return current day
            return new Date().getDate().toString().padStart(2, "0");
          case "A_MMMM":
            // Return full month name
            return new Date().toLocaleDateString(undefined, { month: "long" });
          case "A_MMM":
            // Return short month name
            return new Date().toLocaleDateString(undefined, { month: "short" });
          case "A_DDDD":
            // Return full day name
            return new Date().toLocaleDateString(undefined, { weekday: "long" });
          case "A_DDD":
            // Return short day name
            return new Date().toLocaleDateString(undefined, { weekday: "short" });
          case "A_Hour":
            // Return current hour
            return new Date().getHours().toString().padStart(2, "0");
          case "A_Min":
            // Return current minute
            return new Date().getMinutes().toString().padStart(2, "0");
          case "A_Sec":
            // Return current second
            return new Date().getSeconds().toString().padStart(2, "0");
          case "A_Space":
            // Return space character
            return " ";
          case "A_Tab":
            // Return tab character
            return "\t";

          default:
            // Handle unknown variable names
            return null;
        }
      }
      function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}

function StringTrimRight(input, numChars) {
    return (numChars <= input.length) ? input.substring(0, input.length - numChars) : input;
}

//

      function Chr(number) {
        // Check if the number is null
        if (number === null) {
          // Return an empty string
          return "";
        }

        // Check if the number is within the valid range
        if (number >= 0 && number <= 0x10ffff) {
          // Convert the number to a character using String.fromCharCode
          return String.fromCharCode(number);
        } else {
          // Return an empty string for invalid numbers
          return "";
        }
      }

let allHTVMinst = `cpp
htvm
StringTrimLeft,OUTVAR,INVAR,param1|StringTrimRight,OUTVAR,INVAR,param1|Random,OUTVAR,param1,param2|Sleep,INVAR|FileRead,OUTVAR,'param1|FileAppend,INVAR,'param1|FileDelete,'INVAR|Sort,INOUTVAR,'param1|MsgBox,'param1
alliance
crew
proc
struct
prop
this
import
___start
___end
___cpp start
___cpp end
___py start
___py end
___js start
___js end
___go start
___go end
___lua start
___lua end
___cs start
___cs end
___java start
___java end
___kt start
___kt end
___rb start
___rb end
___nim start
___nim end
___ahk start
___ahk end
___swift start
___swift end
___dart start
___dart end
___ts start
___ts end
___groovy start
___groovy end
___htvm start
___htvm end
___inhtvm start
___inhtvm end
{
}
null
true
false
void
double
char
uint8
uint16
uint32
uint64
int
str
bool
float
int8
int16
int32
int64
if
else if
else
while
Loop
Loop,
Loop, Parse,
continue
break
func
await
async
throw
ErrorMsg
try
catch
finally
return
.add
.pop
.size
.insert
.rm
.indexOf
arr
arr int
arr str
arr float
arr bool
var
let
const
end
global
;
'''1
'''2
\`
main
.
+
-
*
/
%
**
=
===
!=
>
<
>=
<=
and
or
!
&
|
^
~
<<
>>
>>>
:=
+=
.=
-=
*=
/=
%=
<<=
>>=
>>>=
&=
|=
^=
?
:
++
--
0
A_Index
A_LoopField
on
off
off
on
on
off
off
off
on
off
off
on
off`;


let allKeyWordsIn = ""; // Global variable to store the result
let allKeyWordsOut = "";
let allFunctionNamesString = ""; // Global string to store function names
async function getFunctionNames() {
    const url = 'https://raw.githubusercontent.com/TheMaster1127/HTVM/refs/heads/main/HTVM-instructions.txt';
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        
        // Split text by line and get lines starting from line 162
        const lines = text.split('\n').slice(162); // Line 162 starts at index 161
        
        // Extract function names that start with "name: "
        const functionNames = lines
            .map(line => line.trim()) // Trim each line
            .filter(line => line.startsWith("name: ")) // Only lines that start with "name: "
            .map(line => line.replace("name: ", "").trim()) // Get function name (remove "name: " part)
            .filter((value, index, self) => self.indexOf(value) === index); // Remove duplicates
        
        // Save the function names in the global variable
        allFunctionNamesString = functionNames.join('\n');
        
    } catch (error) {
        console.error('Error fetching the text file:', error);
    }
}
// Function to fetch the first 161 lines from a remote text file
async function fetchFirst161Lines(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.statusText}`);
        }
        const text = await response.text();
        return text.split('\n').slice(0, 162).join('\n');
    } catch (error) {
        console.error('Error fetching the text file:', error);
        return null;
    }
}
// Main function to handle localStorage and data retrieval
async function getAllKeyWordsIn() {
allKeyWordsIn = allHTVMinst;
}
function fixSomeBugUGH() {
    var var123Out = "";

let storedData = allHTVMinst;
allKeyWordsIn = allHTVMinst;

    var allKeyWordsIn_OUT = "";
    var allKeyWordsIn_OUT_TEMP = "";
    items1 = LoopParseFunc(allKeyWordsIn, "\n", "\r")
    for (let A_Index1 = 0; A_Index1 < items1.length + 0; A_Index1++) {
        const A_LoopField1 = items1[A_Index1 - 0];
        if (A_Index1 != 0 && A_Index1 != 1) {
            allKeyWordsIn_OUT += A_LoopField1 + "\n";
        }
    }
    allKeyWordsIn_OUT = StringTrimRight(allKeyWordsIn_OUT, 1);
    var123Out = allKeyWordsIn_OUT;
    return var123Out;
}
async function getAllKeyWords() {
    await getAllKeyWordsIn();
    await getFunctionNames();
allKeyWordsIn = allHTVMinst;
    var allKeyWordsIn_OUT = "";
    var allKeyWordsIn_OUT_TEMP = "";
    items2 = LoopParseFunc(allKeyWordsIn, "\n", "\r")
    for (let A_Index2 = 0; A_Index2 < items2.length + 0; A_Index2++) {
        const A_LoopField2 = items2[A_Index2 - 0];
        if (A_Index2 != 0 && A_Index2 != 1) {
            allKeyWordsIn_OUT += A_LoopField2 + "\n";
        }
    }
    allKeyWordsIn_OUT = StringTrimRight(allKeyWordsIn_OUT, 1);
    allKeyWordsOut = allKeyWordsIn_OUT;
}
let allFunctionNamesString2 = "";
(async function () {
    await getAllKeyWords();
    //console.log(allKeyWordsOut);
allFunctionNamesString2 = Trim(StrReplace(allFunctionNamesString, Chr(10), "|"));
//print("=============================")
//print(allFunctionNamesString2)
//print("=============================")
// Get the URL parameter 'id'

const id = 1
// Check if 'id' is present in the URL

    // Create the key for localStorage
    const storageKey = `htvm_lang_${id}_allFunctionNamesString`;
    const storageKey2 = `htvm_lang_${id}_allKeyWordsOut`;
    // Save 'allFunctionNamesString2' to localStorage
    localStorage.setItem(storageKey, allFunctionNamesString2);
    localStorage.setItem(storageKey2, allKeyWordsOut);

})();

      // Define the custom "ht" language for Ace Editor with AHK rules
      ace.define("ace/mode/htvm", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/text_highlight_rules"], function (require, exports, module) {
    var oop = require("ace/lib/oop");
    var TextMode = require("ace/mode/text").Mode;
    var TextHighlightRules = require("ace/mode/text_highlight_rules").TextHighlightRules;
    var HTVMHighlightRules = function() {
        
        //console.log(new URLSearchParams(window.location.search).get('id'));
let allFunctionNamesString3 = "";
let allKeyWordsOut3 = "";

const id = 1
// Check if 'id' is present in the URL

    // Create the key for localStorage
    const storageKey = `htvm_lang_${id}_allFunctionNamesString`;
    const storageKey2 = `htvm_lang_${id}_allKeyWordsOut`;
    // Retrieve 'allFunctionNamesString' from localStorage
    allFunctionNamesString3 = localStorage.getItem(storageKey);
    if (localStorage.getItem("htvm_lang_" + id))
    {
        allKeyWordsOut3 = fixSomeBugUGH();
    }
    else
    {
        allKeyWordsOut3 = localStorage.getItem(storageKey2);    
    }

var builtInCommands_temp = "";
var htvmKeywords_temp = "";
var staticTypes_temp = "";
var builtInVars_temp = "";
var operators_temp = "";
var arrayMethods_temp = "";
var programmingBlocksAndImport_temp = "";
var htvm_trueFalseGlobalNull_temp = "";
var htvm_comment_temp = "";
var htvm_commentOpen1_temp = "";
var htvm_commentClose2_temp = "";
items3 = LoopParseFunc(allKeyWordsOut3, "\n", "\r")
for (let A_Index3 = 0; A_Index3 < items3.length + 0; A_Index3++) {
    const A_LoopField3 = items3[A_Index3 - 0];
    if (Trim(A_LoopField3) != "") {
        if (A_Index3 == 0) {
            items4 = LoopParseFunc(A_LoopField3, "|")
            for (let A_Index4 = 0; A_Index4 < items4.length + 0; A_Index4++) {
                const A_LoopField4 = items4[A_Index4 - 0];
                items5 = LoopParseFunc(A_LoopField4, ",");
                for (let A_Index5 = 0; A_Index5 < items5.length + 0; A_Index5++) {
                    const A_LoopField5 = items5[A_Index5 - 0];
                    builtInCommands_temp += Trim(A_LoopField5) + "|";
                }
            }
        }
        if (A_Index3 == 1 || A_Index3 == 2 || A_Index3 == 3 || A_Index3 == 4 || A_Index3 == 5 || A_Index3 == 64 || A_Index3 == 65 || A_Index3 == 66 || A_Index3 == 67 || A_Index3 == 68 || A_Index3 == 69 || A_Index3 == 70 || A_Index3 == 71 || A_Index3 == 72 || A_Index3 == 73 || A_Index3 == 74 || A_Index3 == 75 || A_Index3 == 76 || A_Index3 == 78 || A_Index3 == 79 || A_Index3 == 80 || A_Index3 == 81 || A_Index3 == 93 || A_Index3 == 94 || A_Index3 == 95 || A_Index3 == 96) {
            htvmKeywords_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 77) {
            allFunctionNamesString3 += "|" + Trim(A_LoopField3);
        }
        if (A_Index3 >= 49 && A_Index3 <= 63) {
            staticTypes_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 88 && A_Index3 <= 92) {
            staticTypes_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 145 || A_Index3 == 146 || A_Index3 == 6) {
            builtInVars_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 103 && A_Index3 <= 126) {
            operators_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 140 && A_Index3 <= 141) {
            operators_temp += A_LoopField3 + "|";
        }
        if (A_Index3 >= 82 && A_Index3 <= 87) {
            arrayMethods_temp += Trim(StrReplace(A_LoopField3, ".", "")) + "|";
        }
        if (A_Index3 >= 7 && A_Index3 <= 43) {
            programmingBlocksAndImport_temp += A_LoopField3 + "|";
        }
        if (A_Index3 == 98) {
            htvm_comment_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 99) {
            htvm_commentOpen1_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 100) {
            htvm_commentClose2_temp = Trim(A_LoopField3);
        }
        if (A_Index3 == 46 || A_Index3 == 47 || A_Index3 == 48 || A_Index3 == 97) {
            htvm_trueFalseGlobalNull_temp += A_LoopField3 + "|";
        }
    }
}
builtInCommands_temp = StringTrimRight(builtInCommands_temp, 1);
htvmKeywords_temp = StringTrimRight(htvmKeywords_temp, 1);
staticTypes_temp = StringTrimRight(staticTypes_temp, 1);
builtInVars_temp = StringTrimRight(builtInVars_temp, 1);
operators_temp = StringTrimRight(operators_temp, 1);
arrayMethods_temp = StringTrimRight(arrayMethods_temp, 1);
programmingBlocksAndImport_temp = StringTrimRight(programmingBlocksAndImport_temp, 1);
htvm_trueFalseGlobalNull_temp = StringTrimRight(htvm_trueFalseGlobalNull_temp, 1);
var htvmKeywords = htvmKeywords_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInCommands = builtInCommands_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInFunctions = allFunctionNamesString3.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var staticTypes = staticTypes_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var builtInVars = builtInVars_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var arrayMethods = arrayMethods_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var programmingBlocksAndImport = programmingBlocksAndImport_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var htvm_trueFalseGlobalNull = htvm_trueFalseGlobalNull_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
var htvm_operators = operators_temp.replace(/[^A-Za-z0-9_|\s]/g, '').replace(/^\d+/g, '').replace(/\|+/g, '|').replace(/^(\|)+|(\|)+$/g, '');
        
        
        var htvm_comment = htvm_comment_temp;
        // Escape special characters in the comment symbol (just in case)
        var escapedComment = htvm_comment.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var htvm_commentOpen1 = htvm_commentOpen1_temp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        var htvm_commentClose2 = htvm_commentClose2_temp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        this.$rules = {
            start: [
                { token: "comment", regex: escapedComment + ".*$" },
                { token: "comment.block", regex: new RegExp(htvm_commentOpen1), next: "comment_block" },
                { token: "keyword", regex: "\\b(?:" + htvmKeywords + ")\\b" },
                { token: "command", regex: "\\b(?:" + builtInCommands + ")(?=\\,)" },
                { token: "functions", regex: "\\b(?:" + builtInFunctions + ")(?=\\()" },
                { token: "BuildInFunc", regex: "\\b(?:" + builtInVars + ")\\b" },
                { token: "arrayMethods", regex: "\\.(?:" + arrayMethods + ")\\b" },
                { token: "static_types", regex: "\\b(?:" + staticTypes + ")\\b" },
                { token: "programmingBlocksAndImport", regex: "\\b(?:" + programmingBlocksAndImport + ")\\b" },
                { token: "operators", regex: "\\b(?:" + htvm_operators + ")\\b" },
                { token: "trueANDfalse", regex: "\\b(?:" + htvm_trueFalseGlobalNull + ")\\b" },
                { token: "variables", regex: "\\b[a-zA-Z_][a-zA-Z0-9_]*\\b" },
                { token: "constant.numeric", regex: "\\b[0-9]+\\b" },
                { token: "braces_Open", regex: "\\{" },
                { token: "braces_Close", regex: "\\}" },
              { token: "string", regex: '".*?"' },
              // Multi-line comments
              {
                token: "comment.block", // Token for multi-line comments
               regex: new RegExp(htvm_commentOpen1),
                next: "comment_block",
              },
            ],
            comment_block: [
              {
                token: "comment.block",
                regex: new RegExp(htvm_commentClose2),
                next: "start", // Go back to the start state
              },
              {
                token: "comment.block",
                regex: /.*/, // Any other content within the comment
              },
            ],
          };
        };
 oop.inherits(HTVMHighlightRules, TextHighlightRules);

        var HTMode = function () {
          this.HighlightRules = HTVMHighlightRules;
        };
        oop.inherits(HTMode, TextMode);

        exports.Mode = HTMode;
      });

// Custom renderer for code blocks to use Ace Editor

// Custom renderer for code blocks to use Ace Editor

var defaultCodeRenderer = md.renderer.rules.fence;
md.renderer.rules.fence = function(tokens, idx, options, env, self) {
    var token = tokens[idx];
    var language = token.info.trim() || 'text';
    var code = token.content;
    
    // Generate a unique ID for the editor
    var editorId = 'ace-editor-' + idx;
    var codeId = 'code-content-' + idx;
    var buttonId = 'copy-button-' + idx;
    
    // Create container for the ace editor
    var html = '<div class="ace-editor-container">\n';
    html += '<div class="ace-editor-header">';
    
    // Add copy button before language
    html += '<div style="display: flex; align-items: center;">';
    html += '<button id="' + buttonId + '" class="copy-button" data-code-id="' + codeId + '">';
    html += '<i class="fas fa-copy"></i> Copy</button>';
    html += '<span class="ace-editor-language">' + language + '</span>';
    html += '</div>';
    
    html += '<span><i class="fas fa-code"></i></span></div>\n';
    
    // Create a pre element to hold the code initially
    html += '<pre id="' + editorId + '" class="ace-editor">' + escapeHtml(code) + '</pre>\n';
    html += '<div id="' + codeId + '" style="display: none;">' + escapeHtml(code) + '</div>\n';
    html += '</div>\n';
    
    // Store the code and language for later use with Ace
    setTimeout(function() {
        initAceEditor(editorId, code, language);
    }, 100);
    
    return html;
};
        
// Function to initialize the Ace editor
function initAceEditor(editorId, code, language) {
    var editor = ace.edit(editorId);
    editor.setTheme("ace/theme/monokai");
    
    // Map markdown language names to Ace mode names
    var modeMap = {
        'javascript': 'javascript',
        'js': 'javascript',
        'html': 'html',
        'css': 'css',
        'python': 'python',
        'py': 'python',
        'json': 'json',
        'htvm': 'htvm'
        // Add more mappings as needed
    };
    
    // Set the correct mode based on language
    var mode = modeMap[language.toLowerCase()] || 'text';
    editor.session.setMode("ace/mode/" + mode);
    
    // Set full code content directly to maintain formatting
    editor.setValue(code);
    editor.clearSelection();
    
    // Make editor read-only
    editor.setReadOnly(true);
    
    // Disable wrap mode to preserve formatting
    editor.getSession().setUseWrapMode(false);
    
    // Additional editor settings
    editor.setShowPrintMargin(false);
    editor.setHighlightActiveLine(true);
    editor.setOptions({
        fontSize: "14px",
    });
    
    // Calculate the exact number of lines
    var lineCount = editor.session.getLength();
    
    // Get the actual line height from the renderer
    var lineHeight = editor.renderer.lineHeight;
    
    // Calculate exact height with a tiny buffer
    var exactHeight = (lineCount * lineHeight);
    
    // Set the editor height to exactly fit the content
    document.getElementById(editorId).style.height = exactHeight + "px";
    
    // Final resize to update the editor view
    editor.resize();
}

// Helper function to escape HTML
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

        
        // Get the markdown content (from the hidden div)
        var markdownText = document.getElementById("markdown-content").innerText;

        // Convert markdown to HTML
        var htmlContent = md.render(markdownText);

        // Output the rendered HTML to the markdown-output div
        document.getElementById("markdown-output").innerHTML = htmlContent;
        
        // Process all headings to add anchor links
        document.querySelectorAll('#markdown-output h1, #markdown-output h2, #markdown-output h3, #markdown-output h4, #markdown-output h5, #markdown-output h6').forEach(function(heading) {
            // Generate ID if none exists
            if (!heading.id) {
                heading.id = heading.textContent.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]/g, '');
            }
            
            // Create an anchor element
            var anchor = document.createElement('a');
            anchor.className = 'header-anchor';
            anchor.href = '#' + heading.id;
            anchor.innerHTML = '<i class="fas fa-link"></i>';
            
            // Add click event to update URL without refreshing page
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                history.pushState(null, null, this.getAttribute('href'));
                // Scroll to the element
                document.getElementById(heading.id).scrollIntoView({
                    behavior: 'smooth'
                });
            });
            
            // Add the anchor to the heading
            heading.appendChild(anchor);
        });
        
        // Process all links in the rendered markdown
        document.querySelectorAll('#markdown-output a:not(.header-anchor)').forEach(function(link) {
            // Check if it's an internal anchor link
            if (link.getAttribute('href').startsWith('#')) {
                // Add click event to update URL without refreshing page
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    var targetId = this.getAttribute('href').substring(1);
                    history.pushState(null, null, this.getAttribute('href'));
                    // Scroll to the element
                    document.getElementById(targetId).scrollIntoView({
                        behavior: 'smooth'
                    });
                });
            } else {
                // It's an external link
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
                link.classList.add('external-link');
            }
        });
        
        // Set up clipboard functionality for copy buttons after DOM is fully loaded
        document.addEventListener('DOMContentLoaded', function() {
            setupCopyButtons();
        });
        
        // Also set up copy buttons after the markdown is rendered
        setTimeout(function() {
            setupCopyButtons();
        }, 200);
        
        // Function to set up copy buttons
        function setupCopyButtons() {
            document.querySelectorAll('.copy-button').forEach(function(button) {
                button.addEventListener('click', function() {
                    // Store the current button ID
                    var buttonId = this.id;
                    var codeId = this.getAttribute('data-code-id');
                    var codeElement = document.getElementById(codeId);
                    var codeText = codeElement.textContent;
                    
                    // Create a temporary textarea element to copy from
                    var textarea = document.createElement('textarea');
                    textarea.value = codeText;
                    textarea.setAttribute('readonly', '');
                    textarea.style.position = 'absolute';
                    textarea.style.left = '-9999px';
                    document.body.appendChild(textarea);
                    
                    // Select and copy the text
                    textarea.select();
                    document.execCommand('copy');
                    
                    // Remove the temporary element
                    document.body.removeChild(textarea);
                    
                    // Visual feedback - only for this specific button
                    var originalText = this.innerHTML;
                    this.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    this.classList.add('copy-success');
                    
                    // Reset button after 5 seconds
                    var buttonElement = this;
                    setTimeout(function() {
                        // Only reset if it hasn't been changed again
                        if (buttonElement.classList.contains('copy-success')) {
                            buttonElement.innerHTML = originalText;
                            buttonElement.classList.remove('copy-success');
                        }
                    }, 5000);
                });
            });
        }
        
        // Handle initial hash in URL if any
        if (window.location.hash) {
            var targetId = window.location.hash.substring(1);
            var targetElement = document.getElementById(targetId);
            if (targetElement) {
                setTimeout(function() {
                    targetElement.scrollIntoView({
                        behavior: 'smooth'
                    });
                }, 100);
            }
        }


        // Apply CSS styles for the editor

        var css = `
    .ace-monokai .ace_marker-layer .ace_active-line {
      background-color: #103010 !important;
    }
    
    .ace-monokai {
      background-color: #050505 !important;
      color: #f8f8f2;
    }
    
    .ace-monokai .ace_gutter {
      background: #204020 !important;
      color: #cbcdc3 !important;
    }
    
    .ace-monokai .ace_gutter-active-line {
      background-color: transparent !important;
    }
    
    .ace-monokai .ace_entity.ace_name.ace_tag,
    .ace-monokai .ace_keyword,
    .ace-monokai .ace_meta.ace_tag,
    .ace-monokai .ace_storage {
      color: #40a0e0 !important;
    }
    
    .ace-monokai .ace_entity.ace_name.ace_function,
    .ace-monokai .ace_entity.ace_other,
    .ace-monokai .ace_entity.ace_other.ace_attribute-name,
    .ace-monokai .ace_variable {
      color: #ff80df !important;
    }
    
    .ace-monokai .ace_comment {
      color: #40d080 !important;
      font-weight: line-through !important;
    }
    
    .ace-monokai .ace_commentOpen_Close {
      color: #40d080 !important;
      font-weight: line-through !important;
    }
    
    .ace-monokai .ace_variables {
      color: #ffffff !important;
    }
    
    .ace-monokai .ace_functions {
      color: #80dfff !important;
    }
    
    .ace-monokai .ace_keyword {
    color: #8080e0 !important; /* Customize color as needed */
    font-weight: bold !important;
    }
    .ace-monokai .ace_braces_Open {
      color: #FFFFff !important;
    }
    
    .ace-monokai .ace_braces_Close {
      color: #FFFFff !important;
    }
    
    .ace-monokai .ace_arrayMethods {
      color: #FAB820 !important;
    }
    
    .ace-monokai .ace_BuildInFunc {
      color: #ff80df !important;
    }
    
    .ace-monokai .ace_command {
      color: #40a0e0 !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_static_types {
      color: #569cd6 !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_string {
      color: #ffa0a0 !important;
      font-weight: lighter !important;
    }
    
    .ace-monokai .ace_operators {
      color: #00ffff !important;
      font-weight: lighter !important;
    }
    
    
    .ace-monokai .ace_trueANDfalse {
      color: #00ffff !important;
      font-weight: lighter !important;
    }
    
    .ace-monokai .ace_escape-char {
      color: #ff8000 !important;
      font-weight: bold !important;
    }

    .ace-monokai .ace_programmingBlocksAndImport {
      color: #F0401C !important;
      font-weight: bold !important;
    }
    
    .ace-monokai .ace_punctuation,
    .ace-monokai .ace_punctuation.ace _tag {
      color: #ffa0a0 !important;
    }
    
    *::-webkit-scrollbar {
      width: 1em;
    }
    
    *::-webkit-scrollbar-track {
      box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
    }
    
    *::-webkit-scrollbar-thumb {
      background-color: darkgrey;
      outline: 1px solid slategrey;
    }
`;

        var style = document.createElement("style");
        style.type = "text/css";
        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          style.appendChild(document.createTextNode(css));
        }
        document.head.appendChild(style);

// allHTVMinst

let allHTVMinstOLD = ""

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function reloadPage() {
    // Check if key exists in localStorage
    if (localStorage.getItem("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX") !== null) {
        // console.log("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX exists in localStorage!");
        // Retrieve data from localStorage
        allHTVMinstOLD = localStorage.getItem("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX");
        
        if (allHTVMinst != allHTVMinstOLD) {
            localStorage.setItem("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX", allHTVMinst); 
            await sleep(900); // Add a 1 second delay before the first reload
            window.location.reload();
        }    
    } else {
        // console.log("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX does not exist.");
        // Set data in localStorage
        localStorage.setItem("allHTVMinst_FIX_FIX_FIX_FIX_FIX_FIX_FIX_FIX", allHTVMinst); 
        await sleep(900); // Add a 1 second delay before the first reload
        window.location.reload();
    }
}
// Call the reloadPage function
reloadPage();

    </script>
</body>
</html>