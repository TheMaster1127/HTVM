

str str0 := "nothing"
str str00 := "nothing"
str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""
str str10 := ""
str str11 := ""
str str12 := ""
str str13 := ""
str str14 := ""

int int0 := 0
int int1 := 0
int int2 := 0
int int3 := 0
int int4 := 0
int int5 := 0
int int6 := 0
int int7 := 0

arr str argHTVMinstrMORE

int isNotHTVMfileEXTRA_INT := 0
int isNotHTVMfile2 := 0

str isNotHTVMfileEXTRA_LIB_INFO := ""
str isNotHTVMfileEXTRA_FUNCS_INFO := ""

arr str programmingBlock_InTheTranspiledLang
arr str programmingBlock_CPP
arr str programmingBlock_PY
arr str programmingBlock_JS
arr str programmingBlock_GO
arr str programmingBlock_LUA
arr str programmingBlock_CS
arr str programmingBlock_JAVA
arr str programmingBlock_KT
arr str programmingBlock_RB
arr str programmingBlock_NIM
arr str programmingBlock_AHK
arr str programmingBlock_SWIFT
arr str programmingBlock_DART
arr str programmingBlock_TS
arr str programmingBlock_SCALA
arr str programmingBlock_GROOVY
arr str programmingBlock_HTVM
arr str programmingBlock_HTVMsyntax

arr str fullLangAllOperators
arr str fullLangAllOperators_HELP

int fixExpertionLineFuncOnly := 0

str langToConvertTo := ""
str langFileExtension := ""
str commands := ""
str keyWordAlliance := ""
str keyWordCrew := ""
str keyWordMethod := ""
str keyWordDefObj := ""
str keyWordPorp := ""
str keyWordThis := ""
str keyWordInclude := ""
str keyWordIncludeInTheTranspiledLang := ""
str keyWordCodeInTheTranspiledLangStart := ""
str keyWordCodeInTheTranspiledLangEnd := ""
str keyWordCodeInTheTranspiledLangStartCPP := ""
str keyWordCodeInTheTranspiledLangEndCPP := ""
str keyWordCodeInTheTranspiledLangStartPY := ""
str keyWordCodeInTheTranspiledLangEndPY := ""
str keyWordCodeInTheTranspiledLangStartJS := ""
str keyWordCodeInTheTranspiledLangEndJS := ""
str keyWordCodeInTheTranspiledLangStartGO := ""
str keyWordCodeInTheTranspiledLangEndGO := ""
str keyWordCodeInTheTranspiledLangStartLUA := ""
str keyWordCodeInTheTranspiledLangEndLUA := ""
str keyWordCodeInTheTranspiledLangStartCS := ""
str keyWordCodeInTheTranspiledLangEndCS := ""
str keyWordCodeInTheTranspiledLangStartJAVA := ""
str keyWordCodeInTheTranspiledLangEndJAVA := ""
str keyWordCodeInTheTranspiledLangStartKT := ""
str keyWordCodeInTheTranspiledLangEndKT := ""
str keyWordCodeInTheTranspiledLangStartRB := ""
str keyWordCodeInTheTranspiledLangEndRB := ""
str keyWordCodeInTheTranspiledLangStartNIM := ""
str keyWordCodeInTheTranspiledLangEndNIM := ""
str keyWordCodeInTheTranspiledLangStartAHK := ""
str keyWordCodeInTheTranspiledLangEndAHK := ""
str keyWordCodeInTheTranspiledLangStartSWIFT := ""
str keyWordCodeInTheTranspiledLangEndSWIFT := ""
str keyWordCodeInTheTranspiledLangStartDART := ""
str keyWordCodeInTheTranspiledLangEndDART := ""
str keyWordCodeInTheTranspiledLangStartTS := ""
str keyWordCodeInTheTranspiledLangEndTS := ""
str keyWordCodeInTheTranspiledLangStartSCALA := ""
str keyWordCodeInTheTranspiledLangEndSCALA := ""
str keyWordCodeInTheTranspiledLangStartGROOVY := ""
str keyWordCodeInTheTranspiledLangEndGROOVY := ""
str keyWordCodeInTheTranspiledLangStartHTVM := ""
str keyWordCodeInTheTranspiledLangEndHTVM := ""
str keyWordCodeInHTVMstart := ""
str keyWordCodeInHTVMend := ""
str keyWordCurlyBraceOpen := ""
str keyWordCurlyBraceClose := ""
str keyWordNull := ""
str keyWordTrue := ""
str keyWordFalse := ""
str keyWordVoid := ""
str keyWordDouble := ""
str keyWordChar := ""
str keyWordUint8 := ""
str keyWordUint16 := ""
str keyWordUint32 := ""
str keyWordUint64 := ""
str keyWordINT := ""
str keyWordSTR := ""
str keyWordBOOL := ""
str keyWordFLOAT := ""
str keyWordINT8 := ""
str keyWordINT16 := ""
str keyWordINT32 := ""
str keyWordINT64 := ""
str keyWordIF := ""
str keyWordElseIf := ""
str keyWordElse := ""
str keyWordSwitch := ""
str keyWordSwitchCase := ""
str keyWordSwitchDefault := ""
str keyWordWhileLoop := ""
str keyWordLoopInfinite := ""
str keyWordLoop := ""
str keyWordLoopParse := ""
str keyWordContinue := ""
str keyWordBreak := ""
str keyWordFunc := ""
str keyWordAwait := ""
str keyWordAsync := ""
str keyWordThrow := ""
str keyWordErrorMsg := ""
str keyWordTry := ""
str keyWordCatch := ""
str keyWordFinally := ""
str keyWordReturnStatement := ""
str keyWordArrayAppend := ""
str keyWordArrayPop := ""
str keyWordArraySize := ""
str keyWordArrayInsert := ""
str keyWordArrayRemove := ""
str keyWordArrayIndexOf := ""
str keyWordArrayDefinition := ""
str keyWordArrayOfIntegersDefinition := ""
str keyWordArrayOfStringsDefinition := ""
str keyWordArrayOfFloatingPointNumbersDefinition := ""
str keyWordArrayOfBooleansDefinition := ""
str keyWordVar := ""
str keyWordLet := ""
str keyWordConst := ""
str keyWordEnd := ""
str keyWordGlobal := ""
str keyWordComment := ""
str keyWordCommentOpenMultiLine := ""
str keyWordCommentCloseMultiLine := ""
str keyWordEscpaeChar := ""
str keyWordMainLabel := ""
str keyWordConcat := ""
str keyWordAdd := ""
str keyWordSub := ""
str keyWordMul := ""
str keyWordDiv := ""
str keyWordMod := ""
str keyWordExp := ""
str keyWordEqual := ""
str keyWordStrictEqual := ""
str keyWordNotEqual := ""
str keyWordGreater := ""
str keyWordLess := ""
str keyWordGreaterEqual := ""
str keyWordLessEqual := ""
str keyWordAnd := ""
str keyWordOr := ""
str keyWordNot := ""
str keyWordBitAnd := ""
str keyWordBitOr := ""
str keyWordBitXor := ""
str keyWordBitNot := ""
str keyWordShiftLeft := ""
str keyWordShiftRight := ""
str keyWordShiftUnsignedRight := ""
str keyWordAssign := ""
str keyWordAssignAdd := ""
str keyWordAssignConcat := ""
str keyWordAssignSub := ""
str keyWordAssignMul := ""
str keyWordAssignDiv := ""
str keyWordAssignMod := ""
str keyWordAssignShiftLeft := ""
str keyWordAssignShiftRight := ""
str keyWordLogicalAssignShiftRight := ""
str keyWordAssignBitAnd := ""
str keyWordAssignBitOr := ""
str keyWordAssignBitXor := ""
str keyWordTernary1 := ""
str keyWordTernary2 := ""
str keyWordInc := ""
str keyWordDec := ""
str AHKlikeLoopsIndexedAt := ""
str keyWordAIndex := ""
str keyWordALoopField := ""
str useFuncKeyWord := ""
str useCurlyBraces := ""
str useEnd := ""
str useSemicolon := ""
str theSemicolon := ""
str theColon := ""
str useParentheses := ""
str usePrefixTypeForTypeDefinition := ""
str usePostfixTypeForTypeDefinition := ""
str usePythonicColonSyntax := ""
str useCurlyBracesSyntaxForArrayDef := "" 
str useInJavaScriptAlwaysUseVar := ""
str useJavaScriptInAfullHTMLfile := ""
str useJavaScriptAmainFuncDef := ""
str useJavaScriptAllFuncsAreAsync := ""
str useJavaScriptAlwaysTripleEqual := ""

str langToConvertTo_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str langFileExtension_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str commands_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAlliance_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCrew_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordMethod_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordDefObj_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordPorp_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordThis_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordInclude_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordIncludeInTheTranspiledLang_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStart_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartCPP_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndCPP_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartPY_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndPY_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartJS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndJS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartGO_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndGO_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartLUA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndLUA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartCS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndCS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartJAVA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndJAVA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartKT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndKT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartRB_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndRB_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartNIM_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndNIM_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartAHK_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndAHK_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartSWIFT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndSWIFT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartDART_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndDART_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartTS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndTS_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartSCALA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndSCALA_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartGROOVY_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndGROOVY_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangStartHTVM_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInTheTranspiledLangEndHTVM_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInHTVMstart_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCodeInHTVMend_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCurlyBraceOpen_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCurlyBraceClose_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordNull_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordTrue_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordFalse_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordVoid_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordDouble_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordChar_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordUint8_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordUint16_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordUint32_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordUint64_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordINT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordSTR_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBOOL_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordFLOAT_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordINT8_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordINT16_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordINT32_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordINT64_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordIF_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordElseIf_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordElse_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordSwitch_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordSwitchCase_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordSwitchDefault_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordWhileLoop_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLoopInfinite_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLoop_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLoopParse_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordContinue_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBreak_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordFunc_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAwait_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAsync_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordThrow_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordErrorMsg_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordTry_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCatch_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordFinally_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordReturnStatement_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayAppend_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayPop_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArraySize_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayInsert_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayRemove_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayIndexOf_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayOfIntegersDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayOfStringsDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayOfFloatingPointNumbersDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordArrayOfBooleansDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordVar_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLet_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordConst_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordEnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordGlobal_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordComment_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCommentOpenMultiLine_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordCommentCloseMultiLine_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordEscpaeChar_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordMainLabel_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordConcat_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAdd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordSub_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordMul_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordDiv_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordMod_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordExp_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordStrictEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordNotEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordGreater_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLess_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordGreaterEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLessEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordOr_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordNot_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBitAnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBitOr_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBitXor_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordBitNot_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordShiftLeft_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordShiftRight_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordShiftUnsignedRight_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssign_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignAdd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignConcat_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignSub_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignMul_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignDiv_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignMod_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignShiftLeft_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignShiftRight_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordLogicalAssignShiftRight_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignBitAnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignBitOr_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAssignBitXor_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordTernary1_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordTernary2_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordInc_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordDec_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str AHKlikeLoopsIndexedAt_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordAIndex_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str keyWordALoopField_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useCurlyBraces_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useEnd_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useSemicolon_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useParentheses_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str usePrefixTypeForTypeDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str usePostfixTypeForTypeDefinition_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str usePythonicColonSyntax_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useCurlyBracesSyntaxForArrayDef_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useInJavaScriptAlwaysUseVar_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useJavaScriptInAfullHTMLfile_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useJavaScriptAmainFuncDef_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useJavaScriptAllFuncsAreAsync_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"
str useJavaScriptAlwaysTripleEqual_2 := "awesdgfd-awesrs-awedsfd-aesdg-sc-zsdxfvc-sdfd"

str out_KeyWordsCommands := ""
str outTrimCode := ""
str htCode := ""

str outVarOperator := ""
int lineDone := 0
int areWeInAFuncFromInstructions := 0
int areWeInAFuncFromInstructionsLineNum := 0

str theCppVarForErrors := "jhku-dfsds-ds-d-ffdsf-sdfsfdsedsf"
str theJSvarDeclaredVarsBugFix := "|"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



func str KeyWordsCommands(str theCodeCommands, str mode, str keyWordsCommands, str langToConvertTo)
{
theCodeCommands := StrReplace(theCodeCommands, "%", "")
if (mode = "check")
{
Loop, Parse, keyWordsCommands, "|"
{
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{

if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
return "true"
}
}

if (A_Index = 1)
{
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
return "true"
}
}


}

}
;MsgBox, false
return "false"
}

int AIndex := 0
if (mode = "transpile")
{

int keyWordsCommandsNumLine := 1
Loop, Parse, keyWordsCommands, "|"
{
AIndex := A_Index
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{
if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}

if (A_Index = 1)
{
;MsgBox, %theCodeCommands% = %A_LoopField%
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}


}

}





str outConstuctTheOutFromTheCommands := ""
str outConstuctTheOutFromTheCommandsFucnName := ""
str outConstuctTheOutFromTheCommandsParams := ""
str outConstuctTheOutFromTheCommandsOutVar := ""
str outConstuctTheOutFromTheCommandsInVar := ""
int theCodeCommandNum := 1
int outConstuctTheOutFromTheCommandsLineTranspile := 0
str outConstuctTheOutFromTheCommandsLineTranspileText := ""

str semicolon := ""
if (langToConvertTo != "py")
{
semicolon := ";"
}

arr str theCodeCommand
theCodeCommands := Trim(theCodeCommands)
Loop, Parse, theCodeCommands, `,
{
theCodeCommand.add(Trim(A_LoopField))
;MsgBox, % A_LoopField
}


Loop, Parse, keyWordsCommands, "|"
{



if (keyWordsCommandsNumLine = A_Index)
{

;MsgBox, % A_LoopField

Loop, Parse, A_LoopField, `,
{




if (A_Index = 1)
{
outConstuctTheOutFromTheCommandsFucnName := A_LoopField
}
else if (A_Index = 2)
{

;MsgBox, % A_LoopField
if (A_LoopField = "lineTranspile")
{
outConstuctTheOutFromTheCommandsLineTranspile := 1
}

if (A_LoopField = "OUTVAR")
{
outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INOUTVAR")
{

outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}

}



}
else if (A_Index = 3)
{

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommandsLineTranspileText := A_LoopField
}


if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}

}
else
{

;MsgBox, % theCodeCommand[theCodeCommandNum]
if (InStr(A_LoopField, Chr(39)))
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}

}
else
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}
}
theCodeCommandNum++
}
break
}

}

StringTrimRight, outConstuctTheOutFromTheCommandsParams, outConstuctTheOutFromTheCommandsParams, 2

if (outConstuctTheOutFromTheCommandsOutVar != "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}

}

if (outConstuctTheOutFromTheCommandsOutVar = "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}
}

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsLineTranspileText
}


outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(, ", "( ")
outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(,", "(")
return outConstuctTheOutFromTheCommands





}

return "false"
}


func str HTVMmatchStrRrplace(str line, str matchString, str replaceString) {
    str lineOut := ""
    if (!InStr(line, matchString)) {
        return line
    }
    str allDelimiters := " ()[].,;:'!&|=<>+-*/^%~" . Chr(34) . Chr(9) . Chr(11)
    arr str lineArr
    Loop, Parse, line {
        lineArr.add(A_LoopField)
    }
    int matchStringLEN := StrLen(matchString)
    int replaceStringLEN := StrLen(replaceString)
    arr int allPosForReplacing
    str sildingLine := ""
    int isStart := 1
    int i1 := 0
    int hasFound := 0
    int hasFound2 := 0
    int isStartTrue := 0
    int isEndTrue := 0
    ; char1 is for text outside the start
    str char1 := ""
    ; char2 is for text inside the start
    str char2 := ""
    ; char3 is for text inside the end
    str char3 := ""
    ; char4 is for text outside the end
    str char4 := ""
    int isMatch := 0
    sildingLine := ""
    isStart := 1
    i1 := 0
    hasFound := 0
    hasFound2 := 0
    isStartTrue := 0
    isEndTrue := 0
    Loop, % lineArr.size() {
        char1 := ""
        char2 := ""
        char3 := ""
        char4 := ""
        isMatch := 0
        if (A_Index != 0) {
            isStart := 0
        }
        sildingLine := ""
        Loop, % matchStringLEN {
            if (A_Index + i1 <= lineArr.size() - 1) {
                sildingLine .= lineArr[A_Index + i1]
            }
        }
        if (StrLen(sildingLine) < matchStringLEN) {
            break
        }
        ;print("!!!!111111111!!!!!!: " . sildingLine)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;==================
        if (sildingLine = matchString) {
            hasFound := 1
            if (isStart != 1) {
                ;print("!!!!2222222222!!!!!!: " . lineArr[i1 - 1])
                char1 := lineArr[i1 - 1]
                ;print("!!!!2222222222.555555555!!!!!!: " . lineArr[i1])
                char2 := lineArr[i1]
            } else {
                isStartTrue := 1
            }
            if (i1 + matchStringLEN < lineArr.size()) {
                ;print("!!!!3333333333.5555555555!!!!!!: " . lineArr[i1 + matchStringLEN - 1])
                char3 := lineArr[i1 + matchStringLEN - 1]
                ;print("!!!!3333333333!!!!!!: " . lineArr[i1 + matchStringLEN])
                char4 := lineArr[i1 + matchStringLEN]
            } else {
                isEndTrue := 1
            }
            if (InStr(allDelimiters, char1)) or (InStr(allDelimiters, char2)) {
                isStartTrue := 1
            }
            if (InStr(allDelimiters, char3)) or (InStr(allDelimiters, char4)) {
                isEndTrue := 1
            }
            if (isStartTrue = 1) and (isEndTrue = 1) {
                isMatch := 1
            }
        }
        ;;;;;;;;;;;;;;;;;;;;===============
        if (isMatch = 1) {
            if (allPosForReplacing.size() > 0) {
                Loop, % allPosForReplacing.size() {
                    if (i1 + 1 != allPosForReplacing[A_Index]) {
                        allPosForReplacing.add(i1 + 1)
                        break
                    }
                }
            } else {
                allPosForReplacing.add(i1 + 1)
            }
        }
        i1++
    }
    str lineTEMP := ""
    lineOut := line
    ;print(allPosForReplacing)
    if (allPosForReplacing.size() > 0) {
        ; matchStringLEN
        ; replaceStringLEN
        int l2 := 0
        int currentPos := 0
        int onceEnd := 0
        Loop, % allPosForReplacing.size() {
            if (A_Index = 0) {
                currentPos := allPosForReplacing[A_Index]
            } else {
                currentPos := allPosForReplacing[A_Index] - (matchStringLEN - replaceStringLEN)
            }
            onceEnd := 0
            Loop, Parse, lineOut {
                if (A_Index + 2 > currentPos) and (A_Index + 1 < currentPos + matchStringLEN) {
                    onceEnd++
                    ;print("DDDDDDDDDDD" . STR(A_Index))
                    if (onceEnd = 1) {
                        lineTEMP .= replaceString
                    }
                } else {
                    lineTEMP .= A_LoopField
                }
            }
            lineOut := lineTEMP
            lineTEMP := ""
            ;print(lineTEMP)
            l2++
        }
    } else {
        return line
    }
    return lineOut
}

func str SubStrLastChars(str text, int numOfChars) {
    str LastOut := ""
    int NumOfChars := 0
    Loop, Parse, text {
        NumOfChars++
    }
    Loop, % numOfChars {
        NumOfChars--
    }
    Loop, Parse, text {
        if (A_Index >= NumOfChars) {
            LastOut .= A_LoopField
        }
    }
    return LastOut
}


func str ExtractDigits(str inputString)
{
str digits := ""

Loop, Parse, inputString
{
    if (RegExMatch(A_LoopField, "\d"))
    {
        digits .= A_LoopField
    }
}
return digits
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Helper function to create spaces
func str spaces(int n)
{
str s := ""
if (n != 0)
{
Loop, % n
{
s .= " "
}
}
return s
}


; Define the function to check odd spaces at the beginning
func str CheckOddLeadingSpaces(str string123)
{
; Initialize a variable to count the spaces
int spaceCount := 0

; Loop through the string one character at a time
Loop, Parse, string123
{
; Check if the current character is a space
if (A_LoopField = Chr(32))
{
spaceCount++
}
else
{
; When we hit a non-space character, break the loop
break
}
}

; Return true if the number of spaces is odd, false otherwise
str sdsfawasd := STR(Mod(spaceCount, 2) = 1)
;MsgBox, % sdsfawasd
return sdsfawasd
}

func str LTrim(str input)
{
    str result := ""
    bool foundNonSpace := false

    Loop, Parse, input
    {
        if (A_LoopField != " " or foundNonSpace)
        {
            result .= A_LoopField
            foundNonSpace := true
        }
    }

    return result
}


func str getLastChar(str strippedString)
{
str lastChar
Loop, Parse, strippedString
{
lastChar := A_LoopField
}
return lastChar
}

func str AddCurlyBraces(str pythonCode)
{
pythonCode := StrReplace(pythonCode, Chr(9), "    ")
str result := ""
int indentLevel := 0
int indent := 0
str line := ""
str stripped := ""
Loop, Parse, pythonCode, `n, `r
{
line := A_LoopField
stripped := Trim(line)
if (stripped = "")
{
result .= line . "`n"
continue
}

; Count leading spaces
indent := StrLen(line) - StrLen(LTrim(line))

; Close braces for unindents

Loop
{
if (indentLevel <= indent)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


; Add opening brace for new blocks
if (getLastChar(stripped) = ":") and (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordComment))) != StrLower(keyWordComment))
{
result .= SubStr(line, 1, -1) . " {`n"
indentLevel += 4
}
else
{
result .= line . "`n"
}
}

; Close any remaining open braces
Loop
{
if (indentLevel <= 0)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


return result
}


func str RepeatSpaces(int count)
{
str spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}


func str indent_nested_curly_braces(str input_string, int modeCurlyBracesOn)
{
int indent_size := 4
int current_indent := 0
str result := ""
str trimmed_line := ""
str resultOut := ""

str culyOpenFix := "{"
str culyCloseFix := "}"
if (langToConvertTo = langFileExtension_2)
{
culyOpenFix := Trim(keyWordCurlyBraceOpen_2)
culyCloseFix := Trim(keyWordCurlyBraceClose_2)
}



;MsgBox, % input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}
else
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}

}


if (modeCurlyBracesOn = 0)
{
str resultOut := ""
Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) != "{") and (Trim(A_LoopField) != "}")
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}
else
{
; format curly braces in a K&R style

arr str lookIntoFurture

Loop, Parse, result, `n, `r
{
lookIntoFurture.add(Trim(A_LoopField))
}
lookIntoFurture.add(" ")

str resultOut := ""
int skipNext := 0
Loop, Parse, result, `n, `r
{


skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(lookIntoFurture[A_Index + 1]) = "{")
{
resultOut .= A_LoopField . " " . culyOpenFix . "`n"
skipNext := 2
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}


}
StringTrimRight, result, resultOut, 1

arr str lookIntoFurture2

Loop, Parse, result, `n, `r
{
lookIntoFurture2.add(Trim(A_LoopField))
}
lookIntoFurture2.add(" ")


resultOut := ""
skipNext := 0
str addSpacesAtTheBegginig
Loop, Parse, result, `n, `r
{
skipNext--
if (skipNext <= 0)
{
skipNext := 0
}

if (langToConvertTo != "lua") and (langToConvertTo != "rb") and (langToConvertTo != langFileExtension_2)
{
if (Trim(A_LoopField) = "}") and (Trim(lookIntoFurture2[A_Index + 1]) = "else {")
{
skipNext := 2
addSpacesAtTheBegginig := ""
Loop, Parse, A_LoopField
{
if (A_LoopField = " ")
{
if (A_LoopField != " ")
{
break
}
addSpacesAtTheBegginig .= StrReplace(A_LoopField, "}", culyCloseFix)
}
}
resultOut .= addSpacesAtTheBegginig . culyCloseFix . " else " . culyOpenFix . "`n"
}
}


if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}


resultOut := ""
str ALoopField
Loop, Parse, result, `n, `r
{
if (CheckOddLeadingSpaces(A_LoopField) = "1")
{
StringTrimLeft, ALoopField, A_LoopField, 1
resultOut .= ALoopField . "`n"
}
else
{
resultOut .= A_LoopField . "`n"
}
}

StringTrimRight, result, resultOut, 1


str fixResultFIX := ""
if (langToConvertTo = langFileExtension_2) and (modeCurlyBracesOn = 1)
{

Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) = "}")
{
fixResultFIX .= StrReplace(A_LoopField, "}", culyCloseFix) . "`n"
}
else
{
fixResultFIX .= A_LoopField . "`n"
}
}

StringTrimRight, result, fixResultFIX, 1
}


; Return the result
return result
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]
str OSPstrArrayStrALLobjInOSP := ""
str HoldOSPdethodNamePath := ""

func str findTypeOfOSPprop(str fullARRAYstr, str FromPath)
{
str outType := ""
; if the fullARRAYstr is in this format
; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]

str outFormat := ""
str outFormatHELP1 := ""
str outFormatHELP2 := ""


Loop, Parse, fullARRAYstr, "|"
{
if (Trim(A_LoopField) != "")
{
outFormatHELP1 := StrSplit(A_LoopField, ":", 1)
outFormatHELP2 := StrSplit(A_LoopField, ":", 2)
Loop, Parse, outFormatHELP2, `,
{
outFormat .= outFormatHELP1 . "." . A_LoopField . "|"
}
}
}
StringTrimRight, outFormat, outFormat, 1


Loop, Parse, outFormat, "|"
{
if (Trim(A_LoopField) != "")
{
if (StrSplit(Trim(A_LoopField), "[", 1) = Trim(FromPath))
{
outType := StrSplit(Trim(A_LoopField), "[", 2)
StringTrimRight, outType, outType, 1
break
}

}
}




if (outType = "vector<int>")
{
outType := "std::vector<int>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<float>")
{
outType := "std::vector<float>&"
}
else if (outType = "vector<bool>")
{
outType := "std::vector<bool>&"
}
else if (outType = Trim(keyWordINT))
{
outType := "int"
}
else if (outType = Trim(keyWordSTR))
{
outType := "std::string"
}
else if (outType = Trim(keyWordFLOAT))
{
outType := "float"
}
else if (outType = Trim(keyWordBOOL))
{
outType := "bool"
}
else if (outType = Trim(keyWordINT8))
{
outType := "int8_t"
}
else if (outType = Trim(keyWordINT16))
{
outType := "int16_t"
}
else if (outType = Trim(keyWordINT32))
{
outType := "int32_t"
}
else if (outType = Trim(keyWordINT64))
{
outType := "int64_t"
}


return outType
}


func str REMOVELastSTRfromDOT(str THESTR)
{
str THESTRout := ""
if (Trim(THESTR) = "")
{
return ""
}
int count12345 := 0

Loop, Parse, THESTR, "."
{
count12345++
}


Loop, Parse, THESTR, "."
{
if (count12345 = A_Index)
{
break
}
else
{
THESTRout .= Trim(A_LoopField) . "."
}
}

StringTrimRight, THESTRout, THESTRout, 1

return THESTRout
}


;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsPY_JS(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "this__OSP__this[0]")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsLEFT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}

func str replaceTheOSPpathsRIGHT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
type := findTypeOfOSPprop(OSPstrArrayStrALLobjInOSP, ALoopField)
;MsgBox, % type

theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "std::any_cast<" . type . ">(OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_") . ")")

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


func str CheckStringPosition(str text, str target, str reference)
{

    str posReference := SubStr(text, 1, StrLen(reference))
    str posTarget := SubStr(text, 1, StrLen(target))

    ; Check if both strings are found (not using InStr)
    if (posReference != "" and posTarget != "")
    {
        ; Manually find the positions of the target and reference
        posTarget := RegExMatch(text, target)
        posReference := RegExMatch(text, reference)

        ; Compare positions of target and reference
        if (posTarget < posReference)
        {

            return "left"
        }
        else if (posTarget > posReference)
        {

return "not left"
        }
        else
        {

return "uuh"
        }
    }
    else
    {

        return "One or both strings not found."
    }

return "huh"
}


func str getIndexOfTheStrArrayStrOST(str ALoopField, str theSringOSPlineARRAYstrstrSTR)
{



Loop, Parse, theSringOSPlineARRAYstrstrSTR, "|"
{
if (Trim(StrSplit(A_LoopField, ":", 1)) = Trim(ALoopField))
{

return STR(A_Index)
}
}



return "0"
}



func str parserOSPgloabl(str theSringOSPline, str str123)
{
str str_1 := ""
str str_2 := ""
str str_3 := ""
str str_4 := ""
str str_5 := ""
str str_6 := ""

str HELPHoldOSPdethodNamePath := ""

StringTrimRight, HELPHoldOSPdethodNamePath, HoldOSPdethodNamePath, 1




Loop, Parse, theSringOSPline, "|"
{
str_1 .= Trim(StrSplit(A_LoopField, ":", 1)) . "`n"
str_5 := Trim(StrSplit(A_LoopField, ":", 1))
str_6 := Trim(StrSplit(A_LoopField, ":", 2))
Loop, Parse, str_6, `,
{
str_1 .= str_5 . "." . Trim(StrSplit(A_LoopField, "[", 1)) . "[" . STR(A_Index) . "]`n"
}

}

str_1 .= StrReplace(HELPHoldOSPdethodNamePath, "|", "`n")



str shortestLine := ""
str currentLine := ""
int currentLength := 0
int minLength := 0
str tempStr := ""

; Sorting by repeatedly finding and appending the shortest line
Loop
{
    ; Initialize variables to track the shortest line in this pass
    shortestLine := ""
    minLength := 999999

    ; Find the shortest line in str_1
    Loop, Parse, str_1, `n, `r
    {
        currentLine := A_LoopField
        currentLength := StrLen(currentLine)
        if (currentLength < minLength)
        {
            minLength := currentLength
            shortestLine := currentLine
        }
    }

    ; If no shortest line is found, break (str_1 is empty)
    if (shortestLine = "")
	{
        break
	}

    ; Add the shortest line to the sorted result
    str_2 .= shortestLine . "`n"

    ; Rebuild str_1 without the shortest line
    tempStr := ""
    Loop, Parse, str_1, `n, `r
    {
        if (A_LoopField != shortestLine)
		{
            tempStr .= A_LoopField . "`n"
		}

    }
    StringTrimRight, tempStr, tempStr, 1
    str_1 := tempStr
}

; Trim the final trailing newline from str_2
StringTrimRight, str_2, str_2, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Initialize an empty result for the reversed lines
str reversedStr := ""

; Count the number of lines
int lineCount := 0
int index := 0
int lineNum := 0

Loop, Parse, str_2, `n, `r
{
    lineCount++
}

; Reverse the order by re-parsing and appending lines in reverse order
Loop, % lineCount
{
    ; Inner loop to find the (lineCount - A_Index + 1)-th line
    index := lineCount - A_Index + 1
    currentLine := ""
    lineNum := 0

    Loop, Parse, str_2, `n, `r
    {
        lineNum++
        if (lineNum = index)
        {
            currentLine := A_LoopField
            break
        }
    }

    ; Append the line in reverse order
    reversedStr .= currentLine . "`n"
}

; Trim the final trailing newline
StringTrimRight, str_2, reversedStr, 1


; Display the sorted result
;MsgBox, % str_2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;CheckStringPosition(text, target, reference)
str ALoopField := ""
str ALoopField1 := ""

Loop, Parse, str_2, `n, `r
{

if (SubStr(A_LoopField, 1, StrLen(keyWordFunc)) != keyWordFunc)
{

if (langToConvertTo = "cpp")
{

if (Trim(A_LoopField) != "")
{


if (InStr(str123, " += "))
{
str6 := " += "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " = "))
{

str6 := " = "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " -= "))
{
str6 := " -= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " *= "))
{
str6 := " *= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " /= "))
{

str6 := " /= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else
{

str123 := replaceTheOSPpathsRIGHT(str123, A_LoopField)

}


;;;;;
}
}
else
{
if (Trim(A_LoopField) != "")
{
str123 := replaceTheOSPpathsPY_JS(str123, A_LoopField)
}
}



}
}



return str123
}



func bool isLineAconstruct(str line)
{
if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordElse)) or (StrLower(Trim(line)) = StrLower(keyWordElse . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordElse))) = keyWordCurlyBraceClose . " " . StrLower(keyWordElse))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordElse) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordElse) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordLoopInfinite)) or (StrLower(Trim(line)) = StrLower(keyWordLoopInfinite . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordLoopInfinite))) = keyWordCurlyBraceClose . " " . StrLower(keyWordLoopInfinite))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordLoopInfinite) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordLoopInfinite) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordSwitchDefault)) or (StrLower(Trim(line)) = StrLower(keyWordSwitchDefault . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordSwitchDefault))) = keyWordCurlyBraceClose . " " . StrLower(keyWordSwitchDefault))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordSwitchDefault) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordSwitchDefault) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordTry)) or (StrLower(Trim(line)) = StrLower(keyWordTry . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordTry))) = keyWordCurlyBraceClose . " " . StrLower(keyWordTry))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordTry) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordTry) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordAlliance))) = StrLower(keyWordAlliance))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordCrew))) = StrLower(keyWordCrew))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordDefObj))) = StrLower(keyWordDefObj))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordMethod))) = StrLower(keyWordMethod))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordFinally)) or (StrLower(Trim(line)) = StrLower(keyWordFinally . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordFinally))) = keyWordCurlyBraceClose . " " . StrLower(keyWordFinally))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordFinally) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordFinally) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
return true
}
return false
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


func str fixArray1234(str line)
{
str out := ""
int started := 0


Loop, Parse, line
{
if (started = 1)
{
if (StrLen(line) = A_Index + 1)
{
return out
}
out .= A_LoopField
}

if (A_LoopField = "(")
{
started := 1
}

}
return out
}

func str fixArray123(str line, str arrayMethodStr, int mode)
{
; mode 1 = Append
; mode 2 = Pop
; mode 3 = Size
; mode 4 = Insert
; mode 5 = Remove
; mode 6 = IndexOf

; HTVM_Append
; HTVM_Pop
; HTVM_Size
; HTVM_Insert
; HTVM_Remove
; HTVM_IndexOf

if (langToConvertTo != "swift")
{

if (mode = 1) 
{
return "HTVM_Append(" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 2)
{
return "HTVM_Pop(" . StrSplit(line, ".", 1) . ")"
}

if (mode = 3)
{
return "HTVM_Size(" . StrSplit(line, ".", 1) . ")"
}

if (mode = 4)
{
return "HTVM_Insert(" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 5)
{
return "HTVM_Remove(" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 6)
{
return "HTVM_IndexOf(" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}


}
else
{

if (mode = 1) 
{
return "HTVM_Append(&" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 2)
{
return "HTVM_Pop(&" . StrSplit(line, ".", 1) . ")"
}

if (mode = 3)
{
return "HTVM_Size(" . StrSplit(line, ".", 1) . ")"
}

if (mode = 4)
{
return "HTVM_Insert(&" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 5)
{
return "HTVM_Remove(&" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}

if (mode = 6)
{
return "HTVM_IndexOf(" . StrSplit(line, ".", 1) . ", " . await fixArray1234(line) . ")"
}


}


return line
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
func str arrayParserTranspiler1(str line, str arrayMethodStr, int mode)
{

if (InStr(line, arrayMethodStr) = false)
{
return line
}

str out := ""
str allDelimiters := " ()[],;:'!&|=<>+-*/^%~" . Chr(34) . Chr(9) . Chr(11)
arr str arrAll
Loop, Parse, line
{
arrAll.add(A_LoopField)
}


int i1 := 0
str tempHold := ""
int holdPos := 0

arr int holdPositions
Loop, % arrAll.size()
{
tempHold := ""
if (arrAll.size() - StrLen(arrayMethodStr) + 1 = i1)
{
break
}

Loop, StrLen(arrayMethodStr)
{
tempHold .= arrAll[A_Index + i1]
}

i1++
;print(tempHold)
if (tempHold = arrayMethodStr)
{
holdPos := i1
;print(holdPos)
holdPositions.add(holdPos)
}

}

;print("===========================================")

int holdPositionsTEMP := 0
Loop, % holdPositions.size()
{
holdPositionsTEMP := holdPositions[A_Index]
i1 := arrAll.size()
tempHold := ""
Loop, % arrAll.size()
{

if (holdPositionsTEMP >= i1 + 1)
{
if (InStr(allDelimiters, arrAll[i1]) = false) 
{
tempHold .= arrAll[i1 - 1]
}
else
{
break
}

}


i1--
}


;print(await StrLen(Trim(RegExReplace(tempHold, "[^A-Za-z0-9_]", ""))))
holdPositions[A_Index] := holdPositions[A_Index] - StrLen(Trim(RegExReplace(tempHold, "[^A-Za-z0-9_]", "")))
}



;;;;;;;;;;;;;;;;;;;


int foundFirstParenthesis := 0
int ParenthesisStackOPEN := 0
int ParenthesisStackCLOSE := 0

arr int holdPositionsEnd

holdPositionsTEMP := 0
Loop, % holdPositions.size()
{
holdPositionsTEMP := holdPositions[A_Index]
i1 := 0
tempHold := ""

foundFirstParenthesis := 0
ParenthesisStackOPEN := 0
ParenthesisStackCLOSE := 0

Loop, % arrAll.size()
{

if (holdPositionsTEMP < i1 + 1)
{

if (arrAll[i1] = "(")
{
foundFirstParenthesis := 1
}

if (arrAll[i1] = "(") and (foundFirstParenthesis = 1)
{
ParenthesisStackOPEN++
}


if (arrAll[i1] = ")") and (foundFirstParenthesis = 1)
{
ParenthesisStackCLOSE++
}
tempHold .= arrAll[i1 - 1]
if (ParenthesisStackOPEN = ParenthesisStackCLOSE) and (foundFirstParenthesis = 1)
{
tempHold .= arrAll[i1]
holdPositionsEnd.add(i1 + 1)
break
}


}


i1++
}
;print(tempHold)

}



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

int startPosReplace := 0
int endPosReplace := 0
int beenInside := 0
str holdDebug := ""
int holdDebugLen := 0
int canOut := 1

Loop, % holdPositions.size()
{

startPosReplace := holdPositions[holdPositions.size() - A_Index - 1]
endPosReplace := holdPositionsEnd[holdPositions.size() - A_Index - 1]


holdDebug := ""
beenInside := 0

holdDebugLen := 0
canOut := 1
Loop, Parse, line
{
if (A_Index + 1 >= startPosReplace) and (A_Index + 1 <= endPosReplace)
{
holdDebug .= A_LoopField
}
}

holdDebugLen := StrLen(holdDebug)

Loop, Parse, line
{
if (A_Index + 1 >= startPosReplace) and (A_Index + 1 <= endPosReplace)
{
beenInside++
}
if (beenInside = 1)
{
out .= await fixArray123(holdDebug, arrayMethodStr, mode)
canOut := 0
}
else
{

if (canOut = 0)
{
holdDebugLen--
if (holdDebugLen = 0)
{
canOut := 1
}
}

if (canOut = 1)
{
out .= A_LoopField
}


}
}

;print("|" . holdDebug . "|")

line := out
out := ""
}


return line
}

func str arrayParserTranspiler(str line)
{
; mode 1 = Append
; mode 2 = Pop
; mode 3 = Size
; mode 4 = Insert
; mode 5 = Remove
; mode 6 = IndexOf

if (langToConvertTo = langFileExtension_2)
{
line := await HTVMmatchStrRrplace(line, "." . keyWordArrayAppend . "(", "." . keyWordArrayAppend_2 . "(")
line := await HTVMmatchStrRrplace(line, "." . keyWordArrayPop . "(", "." . keyWordArrayPop_2 . "(")
line := await HTVMmatchStrRrplace(line, "." . keyWordArraySize . "(", "." . keyWordArraySize_2 . "(")
line := await HTVMmatchStrRrplace(line, "." . keyWordArrayInsert . "(", "." . keyWordArrayInsert_2 . "(")
line := await HTVMmatchStrRrplace(line, "." . keyWordArrayRemove . "(", "." . keyWordArrayRemove_2 . "(")
line := await HTVMmatchStrRrplace(line, "." . keyWordArrayIndexOf . "(", "." . keyWordArrayIndexOf_2 . "(")
}
else
{
line := await arrayParserTranspiler1(line, keyWordArrayAppend . "(", 1)
line := await arrayParserTranspiler1(line, keyWordArrayPop . "(", 2)
line := await arrayParserTranspiler1(line, keyWordArraySize . "(", 3)
line := await arrayParserTranspiler1(line, keyWordArrayInsert . "(", 4)
line := await arrayParserTranspiler1(line, keyWordArrayRemove . "(", 5)
line := await arrayParserTranspiler1(line, keyWordArrayIndexOf . "(", 6)
}

return line
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func arr str GETfullLangAllOperators()
{
arr str fullLangAllOperators
if (langToConvertTo = "cpp") 
{
    fullLangAllOperators.add("nullptr")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "py")
{
    fullLangAllOperators.add("None")
    fullLangAllOperators.add("True")
    fullLangAllOperators.add("False")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("**")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("is")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("and")
    fullLangAllOperators.add("or")
    fullLangAllOperators.add("not")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "js")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("**")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("===")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "go")
{
    fullLangAllOperators.add("nil")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN GO SINCE GO DOES NOT HAVE A TERNARY OPERATOR")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN GO SINCE GO DOES NOT HAVE A TERNARY OPERATOR")
}

if (langToConvertTo = "lua")
{
    fullLangAllOperators.add("nil")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("..")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("~=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("and")
    fullLangAllOperators.add("or")
    fullLangAllOperators.add("not")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "cs")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "java")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "kt")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("===")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("and")
    fullLangAllOperators.add("or")
    fullLangAllOperators.add("xor")
    fullLangAllOperators.add("inv")
    fullLangAllOperators.add("shl")
    fullLangAllOperators.add("shr")
    fullLangAllOperators.add("ushr")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "rb")
{
    fullLangAllOperators.add("nil")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("**")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "nim")
{
    fullLangAllOperators.add("nil")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("and")
    fullLangAllOperators.add("or")
    fullLangAllOperators.add("not")
    fullLangAllOperators.add("and")
    fullLangAllOperators.add("or")
    fullLangAllOperators.add("xor")
    fullLangAllOperators.add("not")
    fullLangAllOperators.add("shl")
    fullLangAllOperators.add("shr")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}


if (langToConvertTo = "ahk")
{
    fullLangAllOperators.add(Chr(34) . "" . Chr(34))
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add(".")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("=")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "swift")
{
    fullLangAllOperators.add("nil")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("===")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "dart")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("===")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "ts")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("**")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("===")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "scala")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("THIS OPERATOR DOES NOT EXIST IN THIS LANG SORRY FOR THIS ERROR")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("eq")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}

if (langToConvertTo = "groovy")
{
    fullLangAllOperators.add("null")
    fullLangAllOperators.add("true")
    fullLangAllOperators.add("false")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("+")
    fullLangAllOperators.add("-")
    fullLangAllOperators.add("*")
    fullLangAllOperators.add("/")
    fullLangAllOperators.add("%")
    fullLangAllOperators.add("**")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("==")
    fullLangAllOperators.add("!=")
    fullLangAllOperators.add(">")
    fullLangAllOperators.add("<")
    fullLangAllOperators.add(">=")
    fullLangAllOperators.add("<=")
    fullLangAllOperators.add("&&")
    fullLangAllOperators.add("||")
    fullLangAllOperators.add("!")
    fullLangAllOperators.add("&")
    fullLangAllOperators.add("|")
    fullLangAllOperators.add("^")
    fullLangAllOperators.add("~")
    fullLangAllOperators.add("<<")
    fullLangAllOperators.add(">>")
    fullLangAllOperators.add(">>>")
    fullLangAllOperators.add("?")
    fullLangAllOperators.add(":")
}
if (langToConvertTo = langFileExtension_2) 
{
    fullLangAllOperators.add(keyWordNull_2)
    fullLangAllOperators.add(keyWordTrue_2)
    fullLangAllOperators.add(keyWordFalse_2)
    fullLangAllOperators.add(keyWordConcat_2)
    fullLangAllOperators.add(keyWordAdd_2)
    fullLangAllOperators.add(keyWordSub_2)
    fullLangAllOperators.add(keyWordMul_2)
    fullLangAllOperators.add(keyWordDiv_2)
    fullLangAllOperators.add(keyWordMod_2)
    fullLangAllOperators.add(keyWordExp_2)
    fullLangAllOperators.add(keyWordEqual_2)
    fullLangAllOperators.add(keyWordStrictEqual_2)
    fullLangAllOperators.add(keyWordNotEqual_2)
    fullLangAllOperators.add(keyWordGreater_2)
    fullLangAllOperators.add(keyWordLess_2)
    fullLangAllOperators.add(keyWordGreaterEqual_2)
    fullLangAllOperators.add(keyWordLessEqual_2)
    fullLangAllOperators.add(keyWordAnd_2)
    fullLangAllOperators.add(keyWordOr_2)
    fullLangAllOperators.add(keyWordNot_2)
    fullLangAllOperators.add(keyWordBitAnd_2)
    fullLangAllOperators.add(keyWordBitOr_2)
    fullLangAllOperators.add(keyWordBitXor_2)
    fullLangAllOperators.add(keyWordBitNot_2)
    fullLangAllOperators.add(keyWordShiftLeft_2)
    fullLangAllOperators.add(keyWordShiftRight_2)
    fullLangAllOperators.add(keyWordShiftUnsignedRight_2)
    fullLangAllOperators.add(keyWordTernary1_2)
    fullLangAllOperators.add(keyWordTernary2_2)
}

return fullLangAllOperators
}


func arr str GETfullLangAllOperators_HELP()
{
arr str fullLangAllOperators_HELP

fullLangAllOperators_HELP.add(keyWordNull)
fullLangAllOperators_HELP.add(keyWordTrue)
fullLangAllOperators_HELP.add(keyWordFalse)
fullLangAllOperators_HELP.add(keyWordConcat)
fullLangAllOperators_HELP.add(keyWordAdd)
fullLangAllOperators_HELP.add(keyWordSub)
fullLangAllOperators_HELP.add(keyWordMul)
fullLangAllOperators_HELP.add(keyWordDiv)
fullLangAllOperators_HELP.add(keyWordMod)
fullLangAllOperators_HELP.add(keyWordExp)
fullLangAllOperators_HELP.add(keyWordEqual)
fullLangAllOperators_HELP.add(keyWordStrictEqual)
fullLangAllOperators_HELP.add(keyWordNotEqual)
fullLangAllOperators_HELP.add(keyWordGreater)
fullLangAllOperators_HELP.add(keyWordLess)
fullLangAllOperators_HELP.add(keyWordGreaterEqual)
fullLangAllOperators_HELP.add(keyWordLessEqual)
fullLangAllOperators_HELP.add(keyWordAnd)
fullLangAllOperators_HELP.add(keyWordOr)
fullLangAllOperators_HELP.add(keyWordNot)
fullLangAllOperators_HELP.add(keyWordBitAnd)
fullLangAllOperators_HELP.add(keyWordBitOr)
fullLangAllOperators_HELP.add(keyWordBitXor)
fullLangAllOperators_HELP.add(keyWordBitNot)
fullLangAllOperators_HELP.add(keyWordShiftLeft)
fullLangAllOperators_HELP.add(keyWordShiftRight)
fullLangAllOperators_HELP.add(keyWordShiftUnsignedRight)
fullLangAllOperators_HELP.add(keyWordTernary1)
fullLangAllOperators_HELP.add(keyWordTernary2)


return fullLangAllOperators_HELP
}




func str expressionParserTranspiler(str expression)
{
str fixExpertionLineFuncOnlyTEXT_func := ""
int fixExpertionLineFuncOnlyTEXT_numDelete := 0
if (fixExpertionLineFuncOnly = 1)
{
fixExpertionLineFuncOnlyTEXT_func := StrSplit(expression, "(", 1)
fixExpertionLineFuncOnlyTEXT_numDelete := StrLen(fixExpertionLineFuncOnlyTEXT_func) + 1
expression := StringTrimLeft(expression, fixExpertionLineFuncOnlyTEXT_numDelete)
}


Loop, 29
{
if (InStr(expression, fullLangAllOperators_HELP[A_Index]))
{
if (A_Index = 0) or (A_Index = 1) or (A_Index = 2)  ; Changed 'and' to 'or' to check for any of these indexes
{
expression := RegExReplace(expression, "\b" . fullLangAllOperators_HELP[A_Index] . "\b", fullLangAllOperators[A_Index])
}
else
{
if (A_Index = 19)
{

if (langToConvertTo = "py") or (langToConvertTo = "lua") or (langToConvertTo = "nim")
{
expression := RegExReplace(expression, "\b" . fullLangAllOperators_HELP[A_Index] . "\b", "not")
}
else
{
expression := RegExReplace(expression, "\b" . fullLangAllOperators_HELP[A_Index] . "\b", "!")
}

if (langToConvertTo = "py") or (langToConvertTo = "lua") or (langToConvertTo = "nim")
{
expression := RegExReplace(expression, "!([\w]+)", "not $1")
}
expression := StrReplace(expression, " not= ", " != ")
}
else
{
expression := StrReplace(expression, " " . fullLangAllOperators_HELP[A_Index] . " ", " " . fullLangAllOperators[A_Index] . " ")

if (A_Index = 28)
{
if (langToConvertTo = "py")
{
; Convert C-like ternary to Python ternary using RegExReplace
expression := RegExReplace(expression, "(.*?)\s*\?\s*(.*?)\s*:\s*(.*?)", "$2 if $1 else $3")
}
if (langToConvertTo = "nim")
{
; Convert C-like ternary to Nim ternary using RegExReplace
expression := RegExReplace(expression, "(.*?)\s*\?\s*(.*?)\s*:\s*(.*)", "if $1: $2 else: $3")
}
if (langToConvertTo = "lua")
{
; Convert C-like ternary to Lua ternary-like expression using RegExReplace
expression := RegExReplace(expression, "(.*?)\s*\?\s*(.*?)\s*:\s*(.*?)", "$1 and $2 or $3")
}
if (langToConvertTo = "scala") or (langToConvertTo = "kt")
{
; Convert C-like ternary to Kotlin/Scala ternary-like expression using RegExReplace
expression := RegExReplace(expression, "(.*?)\s*\?\s*(.*?)\s*:\s*(.*?)", "if $1 $2 else $3")
}
}

}
}



}
}


if (langToConvertTo = "ahk")
{
if (InStr(expression, keyWordAIndex))
{
expression := RegExReplace(expression, "\b" . keyWordAIndex . "\b", "A_Index")
}
if (InStr(expression, keyWordALoopField))
{
expression := RegExReplace(expression, "\b" . keyWordALoopField . "\b", "A_LoopField")
}
}


if (langToConvertTo = langFileExtension_2) 
{
if (InStr(expression, keyWordAIndex))
{
expression := RegExReplace(expression, "\b" . keyWordAIndex . "\b", keyWordAIndex_2)
}
if (InStr(expression, keyWordALoopField))
{
expression := RegExReplace(expression, "\b" . keyWordALoopField . "\b", keyWordALoopField_2)
}
}

; extra for array methods
expression := await arrayParserTranspiler(expression)

if (fixExpertionLineFuncOnly = 1)
{
expression := fixExpertionLineFuncOnlyTEXT_func . "(" . expression
}

return expression
}





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str compiler(str htCode, str allInstructionFile, str mode, str langToConvertToParam := "")
{



str instructions := allInstructionFile



Loop, Parse, allInstructionFile, `n, `r
{
if (A_Index = 0) {
		langToConvertTo := Trim(A_LoopField)
	}
	if (A_Index = 1) {
		langFileExtension := Trim(A_LoopField)
	}
	if (A_Index = 2) {
		commands := Trim(A_LoopField)
	}
	if (A_Index = 3) {
		keyWordAlliance := Trim(A_LoopField) . " "
	}
	if (A_Index = 4) {
		keyWordCrew := Trim(A_LoopField) . " "
	}
	if (A_Index = 5) {
		keyWordMethod := Trim(A_LoopField) . " "
	}
	if (A_Index = 6) {
		keyWordDefObj := Trim(A_LoopField) . " "
	}
	if (A_Index = 7) {
		keyWordPorp := Trim(A_LoopField) . " "
	}
	if (A_Index = 8) {
		keyWordThis := Trim(A_LoopField)
	}
	if (A_Index = 9) {
		keyWordInclude := Trim(A_LoopField) . " "
	}
	if (A_Index = 10) {
		keyWordIncludeInTheTranspiledLang := Trim(A_LoopField)
	}
	if (A_Index = 11) {
		keyWordCodeInTheTranspiledLangStart := Trim(A_LoopField)
	}
	if (A_Index = 12) {
		keyWordCodeInTheTranspiledLangEnd := Trim(A_LoopField)
	}
	if (A_Index = 13) {
		keyWordCodeInTheTranspiledLangStartCPP := Trim(A_LoopField)
	}
	if (A_Index = 14) {
		keyWordCodeInTheTranspiledLangEndCPP := Trim(A_LoopField)
	}
	if (A_Index = 15) {
		keyWordCodeInTheTranspiledLangStartPY := Trim(A_LoopField)
	}
	if (A_Index = 16) {
		keyWordCodeInTheTranspiledLangEndPY := Trim(A_LoopField)
	}
	if (A_Index = 17) {
		keyWordCodeInTheTranspiledLangStartJS := Trim(A_LoopField)
	}
	if (A_Index = 18) {
		keyWordCodeInTheTranspiledLangEndJS := Trim(A_LoopField)
	}
	if (A_Index = 19) {
		keyWordCodeInTheTranspiledLangStartGO := Trim(A_LoopField)
	}
	if (A_Index = 20) {
		keyWordCodeInTheTranspiledLangEndGO := Trim(A_LoopField)
	}
	if (A_Index = 21) {
		keyWordCodeInTheTranspiledLangStartLUA := Trim(A_LoopField)
	}
	if (A_Index = 22) {
		keyWordCodeInTheTranspiledLangEndLUA := Trim(A_LoopField)
	}
	if (A_Index = 23) {
		keyWordCodeInTheTranspiledLangStartCS := Trim(A_LoopField)
	}
	if (A_Index = 24) {
		keyWordCodeInTheTranspiledLangEndCS := Trim(A_LoopField)
	}
	if (A_Index = 25) {
		keyWordCodeInTheTranspiledLangStartJAVA := Trim(A_LoopField)
	}
	if (A_Index = 26) {
		keyWordCodeInTheTranspiledLangEndJAVA := Trim(A_LoopField)
	}
	if (A_Index = 27) {
		keyWordCodeInTheTranspiledLangStartKT := Trim(A_LoopField)
	}
	if (A_Index = 28) {
		keyWordCodeInTheTranspiledLangEndKT := Trim(A_LoopField)
	}
	if (A_Index = 29) {
		keyWordCodeInTheTranspiledLangStartRB := Trim(A_LoopField)
	}
	if (A_Index = 30) {
		keyWordCodeInTheTranspiledLangEndRB := Trim(A_LoopField)
	}
	if (A_Index = 31) {
		keyWordCodeInTheTranspiledLangStartNIM := Trim(A_LoopField)
	}
	if (A_Index = 32) {
		keyWordCodeInTheTranspiledLangEndNIM := Trim(A_LoopField)
	}
	if (A_Index = 33) {
		keyWordCodeInTheTranspiledLangStartAHK := Trim(A_LoopField)
	}
	if (A_Index = 34) {
		keyWordCodeInTheTranspiledLangEndAHK := Trim(A_LoopField)
	}
	if (A_Index = 35) {
		keyWordCodeInTheTranspiledLangStartSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 36) {
		keyWordCodeInTheTranspiledLangEndSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 37) {
		keyWordCodeInTheTranspiledLangStartDART := Trim(A_LoopField)
	}
	if (A_Index = 38) {
		keyWordCodeInTheTranspiledLangEndDART := Trim(A_LoopField)
	}
	if (A_Index = 39) {
		keyWordCodeInTheTranspiledLangStartTS := Trim(A_LoopField)
	}
	if (A_Index = 40) {
		keyWordCodeInTheTranspiledLangEndTS := Trim(A_LoopField)
	}
	if (A_Index = 41) {
		keyWordCodeInTheTranspiledLangStartSCALA := Trim(A_LoopField)
	}
	if (A_Index = 42) {
		keyWordCodeInTheTranspiledLangEndSCALA := Trim(A_LoopField)
	}
	if (A_Index = 43) {
		keyWordCodeInTheTranspiledLangStartGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 44) {
		keyWordCodeInTheTranspiledLangEndGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 45) {
		keyWordCodeInTheTranspiledLangStartHTVM := Trim(A_LoopField)
	}
	if (A_Index = 46) {
		keyWordCodeInTheTranspiledLangEndHTVM := Trim(A_LoopField)
	}
	if (A_Index = 47) {
		keyWordCodeInHTVMstart := Trim(A_LoopField)
	}
	if (A_Index = 48) {
		keyWordCodeInHTVMend := Trim(A_LoopField)
	}
	if (A_Index = 49) {
		keyWordCurlyBraceOpen := Trim(A_LoopField)
	}
	if (A_Index = 50) {
		keyWordCurlyBraceClose := Trim(A_LoopField)
	}
	if (A_Index = 51) {
		keyWordNull := Trim(A_LoopField)
	}
	if (A_Index = 52) {
		keyWordTrue := Trim(A_LoopField)
	}
	if (A_Index = 53) {
		keyWordFalse := Trim(A_LoopField)
	}
	if (A_Index = 54) {
		keyWordVoid := Trim(A_LoopField) . " "
	}
	if (A_Index = 55) {
		keyWordDouble := Trim(A_LoopField) . " "
	}
	if (A_Index = 56) {
		keyWordChar := Trim(A_LoopField) . " "
	}
	if (A_Index = 57) {
		keyWordUint8 := Trim(A_LoopField) . " "
	}
	if (A_Index = 58) {
		keyWordUint16 := Trim(A_LoopField) . " "
	}
	if (A_Index = 59) {
		keyWordUint32 := Trim(A_LoopField) . " "
	}
	if (A_Index = 60) {
		keyWordUint64 := Trim(A_LoopField) . " "
	}
	if (A_Index = 61) {
		keyWordINT := Trim(A_LoopField) . " "
	}
	if (A_Index = 62) {
		keyWordSTR := Trim(A_LoopField) . " "
	}
	if (A_Index = 63) {
		keyWordBOOL := Trim(A_LoopField) . " "
	}
	if (A_Index = 64) {
		keyWordFLOAT := Trim(A_LoopField) . " "
	}
	if (A_Index = 65) {
		keyWordINT8 := Trim(A_LoopField) . " "
	}
	if (A_Index = 66) {
		keyWordINT16 := Trim(A_LoopField) . " "
	}
	if (A_Index = 67) {
		keyWordINT32 := Trim(A_LoopField) . " "
	}
	if (A_Index = 68) {
		keyWordINT64 := Trim(A_LoopField) . " "
	}
	if (A_Index = 69) {
		keyWordIF := Trim(A_LoopField) . " "
	}
	if (A_Index = 70) {
		keyWordElseIf := Trim(A_LoopField) . " "
	}
	if (A_Index = 71) {
		keyWordElse := Trim(A_LoopField)
	}
	if (A_Index = 72) {
		keyWordSwitch := Trim(A_LoopField) . " "
	}
	if (A_Index = 73) {
		keyWordSwitchCase := Trim(A_LoopField) . " "
	}
	if (A_Index = 74) {
		keyWordSwitchDefault := Trim(A_LoopField)
	}
	if (A_Index = 75) {
		keyWordWhileLoop := Trim(A_LoopField) . " "
	}
	if (A_Index = 76) {
		keyWordLoopInfinite := Trim(A_LoopField)
	}
	if (A_Index = 77) {
		keyWordLoop := Trim(A_LoopField) . " "
	}
	if (A_Index = 78) {
		keyWordLoopParse := Trim(A_LoopField) . " "
	}
	if (A_Index = 79) {
		keyWordContinue := Trim(A_LoopField)
	}
	if (A_Index = 80) {
		keyWordBreak := Trim(A_LoopField)
	}
	if (A_Index = 81) {
		keyWordFunc := Trim(A_LoopField) . " "
	}
	if (A_Index = 82) {
		keyWordAwait := Trim(A_LoopField) . " "
	}
	if (A_Index = 83) {
		keyWordAsync := Trim(A_LoopField) . " "
	}
	if (A_Index = 84) {
		keyWordThrow := Trim(A_LoopField) . " "
	}
	if (A_Index = 85) {
		keyWordErrorMsg := Trim(A_LoopField)
	}
	if (A_Index = 86) {
		keyWordTry := Trim(A_LoopField)
	}
	if (A_Index = 87) {
		keyWordCatch := Trim(A_LoopField) . " "
	}
	if (A_Index = 88) {
		keyWordFinally := Trim(A_LoopField)
	}
	if (A_Index = 89) {
		keyWordReturnStatement := Trim(A_LoopField) . " "
	}
	if (A_Index = 90) {
		keyWordArrayAppend := Trim(A_LoopField)
	}
	if (A_Index = 91) {
		keyWordArrayPop := Trim(A_LoopField)
	}
	if (A_Index = 92) {
		keyWordArraySize := Trim(A_LoopField)
	}
	if (A_Index = 93) {
		keyWordArrayInsert := Trim(A_LoopField)
	}
	if (A_Index = 94) {
		keyWordArrayRemove := Trim(A_LoopField)
	}
	if (A_Index = 95) {
		keyWordArrayIndexOf := Trim(A_LoopField)
	}
	if (A_Index = 96) {
		keyWordArrayDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 97) {
		keyWordArrayOfIntegersDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 98) {
		keyWordArrayOfStringsDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 99) {
		keyWordArrayOfFloatingPointNumbersDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 100) {
		keyWordArrayOfBooleansDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 101) {
		keyWordVar := Trim(A_LoopField) . " "
	}
	if (A_Index = 102) {
		keyWordLet := Trim(A_LoopField) . " "
	}
	if (A_Index = 103) {
		keyWordConst := Trim(A_LoopField) . " "
	}
	if (A_Index = 104) {
		keyWordEnd := Trim(A_LoopField)
	}
	if (A_Index = 105) {
		keyWordGlobal := Trim(A_LoopField) . " "
	}
	if (A_Index = 106) {
		keyWordComment := Trim(A_LoopField)
	}
	if (A_Index = 107) {
		keyWordCommentOpenMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 108) {
		keyWordCommentCloseMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 109) {
		keyWordEscpaeChar := Trim(A_LoopField)
	}
	if (A_Index = 110) {
		keyWordMainLabel := Trim(A_LoopField)
	}
	if (A_Index = 111) {
		keyWordConcat := Trim(A_LoopField)
	}
	if (A_Index = 112) {
		keyWordAdd := Trim(A_LoopField)
	}
	if (A_Index = 113) {
		keyWordSub := Trim(A_LoopField)
	}
	if (A_Index = 114) {
		keyWordMul := Trim(A_LoopField)
	}
	if (A_Index = 115) {
		keyWordDiv := Trim(A_LoopField)
	}
	if (A_Index = 116) {
		keyWordMod := Trim(A_LoopField)
	}
	if (A_Index = 117) {
		keyWordExp := Trim(A_LoopField)
	}
	if (A_Index = 118) {
		keyWordEqual := Trim(A_LoopField)
	}
	if (A_Index = 119) {
		keyWordStrictEqual := Trim(A_LoopField)
	}
	if (A_Index = 120) {
		keyWordNotEqual := Trim(A_LoopField)
	}
	if (A_Index = 121) {
		keyWordGreater := Trim(A_LoopField)
	}
	if (A_Index = 122) {
		keyWordLess := Trim(A_LoopField)
	}
	if (A_Index = 123) {
		keyWordGreaterEqual := Trim(A_LoopField)
	}
	if (A_Index = 124) {
		keyWordLessEqual := Trim(A_LoopField)
	}
	if (A_Index = 125) {
		keyWordAnd := Trim(A_LoopField)
	}
	if (A_Index = 126) {
		keyWordOr := Trim(A_LoopField)
	}
	if (A_Index = 127) {
		keyWordNot := Trim(A_LoopField)
	}
	if (A_Index = 128) {
		keyWordBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 129) {
		keyWordBitOr := Trim(A_LoopField)
	}
	if (A_Index = 130) {
		keyWordBitXor := Trim(A_LoopField)
	}
	if (A_Index = 131) {
		keyWordBitNot := Trim(A_LoopField)
	}
	if (A_Index = 132) {
		keyWordShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 133) {
		keyWordShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 134) {
		keyWordShiftUnsignedRight := Trim(A_LoopField)
	}
	if (A_Index = 135) {
		keyWordAssign := Trim(A_LoopField)
	}
	if (A_Index = 136) {
		keyWordAssignAdd := Trim(A_LoopField)
	}
	if (A_Index = 137) {
		keyWordAssignConcat := Trim(A_LoopField)
	}
	if (A_Index = 138) {
		keyWordAssignSub := Trim(A_LoopField)
	}
	if (A_Index = 139) {
		keyWordAssignMul := Trim(A_LoopField)
	}
	if (A_Index = 140) {
		keyWordAssignDiv := Trim(A_LoopField)
	}
	if (A_Index = 141) {
		keyWordAssignMod := Trim(A_LoopField)
	}
	if (A_Index = 142) {
		keyWordAssignShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 143) {
		keyWordAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 144) {
		keyWordLogicalAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 145) {
		keyWordAssignBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 146) {
		keyWordAssignBitOr := Trim(A_LoopField)
	}
	if (A_Index = 147) {
		keyWordAssignBitXor := Trim(A_LoopField)
	}
	if (A_Index = 148) {
		keyWordTernary1 := Trim(A_LoopField)
	}
	if (A_Index = 149) {
		keyWordTernary2 := Trim(A_LoopField)
	}
	if (A_Index = 150) {
		keyWordInc := Trim(A_LoopField)
	}
	if (A_Index = 151) {
		keyWordDec := Trim(A_LoopField)
	}
	if (A_Index = 152) {
		AHKlikeLoopsIndexedAt := Trim(A_LoopField)
	}
	if (A_Index = 153) {
		keyWordAIndex := Trim(A_LoopField)
	}
	if (A_Index = 154) {
		keyWordALoopField := Trim(A_LoopField)
	}
	if (A_Index = 155) {
		useCurlyBraces := Trim(A_LoopField)
	}
	if (A_Index = 156) {
		useEnd := Trim(A_LoopField)
	}
	if (A_Index = 157) {
		useSemicolon := Trim(A_LoopField)
	}
	if (A_Index = 158) {
		useParentheses := Trim(A_LoopField)
	}
	if (A_Index = 159) {
		usePrefixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 160) {
		usePostfixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 161) {
		usePythonicColonSyntax := Trim(A_LoopField)
	}
	if (A_Index = 162) {
		useCurlyBracesSyntaxForArrayDef := Trim(A_LoopField)
	}
	if (A_Index = 163) {
		useInJavaScriptAlwaysUseVar := Trim(A_LoopField)
	}
	if (A_Index = 164) {
		useJavaScriptInAfullHTMLfile := Trim(A_LoopField)
	}
	if (A_Index = 165) {
		useJavaScriptAmainFuncDef := Trim(A_LoopField)
	}
	if (A_Index = 166) {
		useJavaScriptAllFuncsAreAsync := Trim(A_LoopField)
	}
	if (A_Index = 167) {
		useJavaScriptAlwaysTripleEqual := Trim(A_LoopField)
	}
}

if (argHTVMinstrMORE.size() > 0)
{
str allInstructionFile_2 := Trim(FileRead(Trim(argHTVMinstrMORE[0])))


Loop, Parse, allInstructionFile_2, `n, `r
{
	if (A_Index = 0) {
		langToConvertTo_2 := Trim(A_LoopField)
	}
	if (A_Index = 1) {
		langFileExtension_2 := Trim(A_LoopField)
	}
	if (A_Index = 2) {
		commands_2 := Trim(A_LoopField)
	}
	if (A_Index = 3) {
		keyWordAlliance_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 4) {
		keyWordCrew_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 5) {
		keyWordMethod_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 6) {
		keyWordDefObj_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 7) {
		keyWordPorp_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 8) {
		keyWordThis_2 := Trim(A_LoopField)
	}
	if (A_Index = 9) {
		keyWordInclude_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 10) {
		keyWordIncludeInTheTranspiledLang_2 := Trim(A_LoopField)
	}
	if (A_Index = 11) {
		keyWordCodeInTheTranspiledLangStart_2 := Trim(A_LoopField)
	}
	if (A_Index = 12) {
		keyWordCodeInTheTranspiledLangEnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 13) {
		keyWordCodeInTheTranspiledLangStartCPP_2 := Trim(A_LoopField)
	}
	if (A_Index = 14) {
		keyWordCodeInTheTranspiledLangEndCPP_2 := Trim(A_LoopField)
	}
	if (A_Index = 15) {
		keyWordCodeInTheTranspiledLangStartPY_2 := Trim(A_LoopField)
	}
	if (A_Index = 16) {
		keyWordCodeInTheTranspiledLangEndPY_2 := Trim(A_LoopField)
	}
	if (A_Index = 17) {
		keyWordCodeInTheTranspiledLangStartJS_2 := Trim(A_LoopField)
	}
	if (A_Index = 18) {
		keyWordCodeInTheTranspiledLangEndJS_2 := Trim(A_LoopField)
	}
	if (A_Index = 19) {
		keyWordCodeInTheTranspiledLangStartGO_2 := Trim(A_LoopField)
	}
	if (A_Index = 20) {
		keyWordCodeInTheTranspiledLangEndGO_2 := Trim(A_LoopField)
	}
	if (A_Index = 21) {
		keyWordCodeInTheTranspiledLangStartLUA_2 := Trim(A_LoopField)
	}
	if (A_Index = 22) {
		keyWordCodeInTheTranspiledLangEndLUA_2 := Trim(A_LoopField)
	}
	if (A_Index = 23) {
		keyWordCodeInTheTranspiledLangStartCS_2 := Trim(A_LoopField)
	}
	if (A_Index = 24) {
		keyWordCodeInTheTranspiledLangEndCS_2 := Trim(A_LoopField)
	}
	if (A_Index = 25) {
		keyWordCodeInTheTranspiledLangStartJAVA_2 := Trim(A_LoopField)
	}
	if (A_Index = 26) {
		keyWordCodeInTheTranspiledLangEndJAVA_2 := Trim(A_LoopField)
	}
	if (A_Index = 27) {
		keyWordCodeInTheTranspiledLangStartKT_2 := Trim(A_LoopField)
	}
	if (A_Index = 28) {
		keyWordCodeInTheTranspiledLangEndKT_2 := Trim(A_LoopField)
	}
	if (A_Index = 29) {
		keyWordCodeInTheTranspiledLangStartRB_2 := Trim(A_LoopField)
	}
	if (A_Index = 30) {
		keyWordCodeInTheTranspiledLangEndRB_2 := Trim(A_LoopField)
	}
	if (A_Index = 31) {
		keyWordCodeInTheTranspiledLangStartNIM_2 := Trim(A_LoopField)
	}
	if (A_Index = 32) {
		keyWordCodeInTheTranspiledLangEndNIM_2 := Trim(A_LoopField)
	}
	if (A_Index = 33) {
		keyWordCodeInTheTranspiledLangStartAHK_2 := Trim(A_LoopField)
	}
	if (A_Index = 34) {
		keyWordCodeInTheTranspiledLangEndAHK_2 := Trim(A_LoopField)
	}
	if (A_Index = 35) {
		keyWordCodeInTheTranspiledLangStartSWIFT_2 := Trim(A_LoopField)
	}
	if (A_Index = 36) {
		keyWordCodeInTheTranspiledLangEndSWIFT_2 := Trim(A_LoopField)
	}
	if (A_Index = 37) {
		keyWordCodeInTheTranspiledLangStartDART_2 := Trim(A_LoopField)
	}
	if (A_Index = 38) {
		keyWordCodeInTheTranspiledLangEndDART_2 := Trim(A_LoopField)
	}
	if (A_Index = 39) {
		keyWordCodeInTheTranspiledLangStartTS_2 := Trim(A_LoopField)
	}
	if (A_Index = 40) {
		keyWordCodeInTheTranspiledLangEndTS_2 := Trim(A_LoopField)
	}
	if (A_Index = 41) {
		keyWordCodeInTheTranspiledLangStartSCALA_2 := Trim(A_LoopField)
	}
	if (A_Index = 42) {
		keyWordCodeInTheTranspiledLangEndSCALA_2 := Trim(A_LoopField)
	}
	if (A_Index = 43) {
		keyWordCodeInTheTranspiledLangStartGROOVY_2 := Trim(A_LoopField)
	}
	if (A_Index = 44) {
		keyWordCodeInTheTranspiledLangEndGROOVY_2 := Trim(A_LoopField)
	}
	if (A_Index = 45) {
		keyWordCodeInTheTranspiledLangStartHTVM_2 := Trim(A_LoopField)
	}
	if (A_Index = 46) {
		keyWordCodeInTheTranspiledLangEndHTVM_2 := Trim(A_LoopField)
	}
	if (A_Index = 47) {
		keyWordCodeInHTVMstart_2 := Trim(A_LoopField)
	}
	if (A_Index = 48) {
		keyWordCodeInHTVMend_2 := Trim(A_LoopField)
	}
	if (A_Index = 49) {
		keyWordCurlyBraceOpen_2 := Trim(A_LoopField)
	}
	if (A_Index = 50) {
		keyWordCurlyBraceClose_2 := Trim(A_LoopField)
	}
	if (A_Index = 51) {
		keyWordNull_2 := Trim(A_LoopField)
	}
	if (A_Index = 52) {
		keyWordTrue_2 := Trim(A_LoopField)
	}
	if (A_Index = 53) {
		keyWordFalse_2 := Trim(A_LoopField)
	}
	if (A_Index = 54) {
		keyWordVoid_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 55) {
		keyWordDouble_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 56) {
		keyWordChar_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 57) {
		keyWordUint8_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 58) {
		keyWordUint16_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 59) {
		keyWordUint32_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 60) {
		keyWordUint64_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 61) {
		keyWordINT_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 62) {
		keyWordSTR_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 63) {
		keyWordBOOL_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 64) {
		keyWordFLOAT_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 65) {
		keyWordINT8_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 66) {
		keyWordINT16_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 67) {
		keyWordINT32_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 68) {
		keyWordINT64_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 69) {
		keyWordIF_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 70) {
		keyWordElseIf_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 71) {
		keyWordElse_2 := Trim(A_LoopField)
	}
	if (A_Index = 72) {
		keyWordSwitch_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 73) {
		keyWordSwitchCase_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 74) {
		keyWordSwitchDefault_2 := Trim(A_LoopField)
	}
	if (A_Index = 75) {
		keyWordWhileLoop_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 76) {
		keyWordLoopInfinite_2 := Trim(A_LoopField)
	}
	if (A_Index = 77) {
		keyWordLoop_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 78) {
		keyWordLoopParse_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 79) {
		keyWordContinue_2 := Trim(A_LoopField)
	}
	if (A_Index = 80) {
		keyWordBreak_2 := Trim(A_LoopField)
	}
	if (A_Index = 81) {
		keyWordFunc_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 82) {
		keyWordAwait_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 83) {
		keyWordAsync_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 84) {
		keyWordThrow_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 85) {
		keyWordErrorMsg_2 := Trim(A_LoopField)
	}
	if (A_Index = 86) {
		keyWordTry_2 := Trim(A_LoopField)
	}
	if (A_Index = 87) {
		keyWordCatch_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 88) {
		keyWordFinally_2 := Trim(A_LoopField)
	}
	if (A_Index = 89) {
		keyWordReturnStatement_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 90) {
		keyWordArrayAppend_2 := Trim(A_LoopField)
	}
	if (A_Index = 91) {
		keyWordArrayPop_2 := Trim(A_LoopField)
	}
	if (A_Index = 92) {
		keyWordArraySize_2 := Trim(A_LoopField)
	}
	if (A_Index = 93) {
		keyWordArrayInsert_2 := Trim(A_LoopField)
	}
	if (A_Index = 94) {
		keyWordArrayRemove_2 := Trim(A_LoopField)
	}
	if (A_Index = 95) {
		keyWordArrayIndexOf_2 := Trim(A_LoopField)
	}
	if (A_Index = 96) {
		keyWordArrayDefinition_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 97) {
		keyWordArrayOfIntegersDefinition_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 98) {
		keyWordArrayOfStringsDefinition_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 99) {
		keyWordArrayOfFloatingPointNumbersDefinition_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 100) {
		keyWordArrayOfBooleansDefinition_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 101) {
		keyWordVar_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 102) {
		keyWordLet_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 103) {
		keyWordConst_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 104) {
		keyWordEnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 105) {
		keyWordGlobal_2 := Trim(A_LoopField) . " "
	}
	if (A_Index = 106) {
		keyWordComment_2 := Trim(A_LoopField)
	}
	if (A_Index = 107) {
		keyWordCommentOpenMultiLine_2 := Trim(A_LoopField)
	}
	if (A_Index = 108) {
		keyWordCommentCloseMultiLine_2 := Trim(A_LoopField)
	}
	if (A_Index = 109) {
		keyWordEscpaeChar_2 := Trim(A_LoopField)
	}
	if (A_Index = 110) {
		keyWordMainLabel_2 := Trim(A_LoopField)
	}
	if (A_Index = 111) {
		keyWordConcat_2 := Trim(A_LoopField)
	}
	if (A_Index = 112) {
		keyWordAdd_2 := Trim(A_LoopField)
	}
	if (A_Index = 113) {
		keyWordSub_2 := Trim(A_LoopField)
	}
	if (A_Index = 114) {
		keyWordMul_2 := Trim(A_LoopField)
	}
	if (A_Index = 115) {
		keyWordDiv_2 := Trim(A_LoopField)
	}
	if (A_Index = 116) {
		keyWordMod_2 := Trim(A_LoopField)
	}
	if (A_Index = 117) {
		keyWordExp_2 := Trim(A_LoopField)
	}
	if (A_Index = 118) {
		keyWordEqual_2 := Trim(A_LoopField)
	}
	if (A_Index = 119) {
		keyWordStrictEqual_2 := Trim(A_LoopField)
	}
	if (A_Index = 120) {
		keyWordNotEqual_2 := Trim(A_LoopField)
	}
	if (A_Index = 121) {
		keyWordGreater_2 := Trim(A_LoopField)
	}
	if (A_Index = 122) {
		keyWordLess_2 := Trim(A_LoopField)
	}
	if (A_Index = 123) {
		keyWordGreaterEqual_2 := Trim(A_LoopField)
	}
	if (A_Index = 124) {
		keyWordLessEqual_2 := Trim(A_LoopField)
	}
	if (A_Index = 125) {
		keyWordAnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 126) {
		keyWordOr_2 := Trim(A_LoopField)
	}
	if (A_Index = 127) {
		keyWordNot_2 := Trim(A_LoopField)
	}
	if (A_Index = 128) {
		keyWordBitAnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 129) {
		keyWordBitOr_2 := Trim(A_LoopField)
	}
	if (A_Index = 130) {
		keyWordBitXor_2 := Trim(A_LoopField)
	}
	if (A_Index = 131) {
		keyWordBitNot_2 := Trim(A_LoopField)
	}
	if (A_Index = 132) {
		keyWordShiftLeft_2 := Trim(A_LoopField)
	}
	if (A_Index = 133) {
		keyWordShiftRight_2 := Trim(A_LoopField)
	}
	if (A_Index = 134) {
		keyWordShiftUnsignedRight_2 := Trim(A_LoopField)
	}
	if (A_Index = 135) {
		keyWordAssign_2 := Trim(A_LoopField)
	}
	if (A_Index = 136) {
		keyWordAssignAdd_2 := Trim(A_LoopField)
	}
	if (A_Index = 137) {
		keyWordAssignConcat_2 := Trim(A_LoopField)
	}
	if (A_Index = 138) {
		keyWordAssignSub_2 := Trim(A_LoopField)
	}
	if (A_Index = 139) {
		keyWordAssignMul_2 := Trim(A_LoopField)
	}
	if (A_Index = 140) {
		keyWordAssignDiv_2 := Trim(A_LoopField)
	}
	if (A_Index = 141) {
		keyWordAssignMod_2 := Trim(A_LoopField)
	}
	if (A_Index = 142) {
		keyWordAssignShiftLeft_2 := Trim(A_LoopField)
	}
	if (A_Index = 143) {
		keyWordAssignShiftRight_2 := Trim(A_LoopField)
	}
	if (A_Index = 144) {
		keyWordLogicalAssignShiftRight_2 := Trim(A_LoopField)
	}
	if (A_Index = 145) {
		keyWordAssignBitAnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 146) {
		keyWordAssignBitOr_2 := Trim(A_LoopField)
	}
	if (A_Index = 147) {
		keyWordAssignBitXor_2 := Trim(A_LoopField)
	}
	if (A_Index = 148) {
		keyWordTernary1_2 := Trim(A_LoopField)
	}
	if (A_Index = 149) {
		keyWordTernary2_2 := Trim(A_LoopField)
	}
	if (A_Index = 150) {
		keyWordInc_2 := Trim(A_LoopField)
	}
	if (A_Index = 151) {
		keyWordDec_2 := Trim(A_LoopField)
	}
	if (A_Index = 152) {
		AHKlikeLoopsIndexedAt_2 := Trim(A_LoopField)
	}
	if (A_Index = 153) {
		keyWordAIndex_2 := Trim(A_LoopField)
	}
	if (A_Index = 154) {
		keyWordALoopField_2 := Trim(A_LoopField)
	}
	if (A_Index = 155) {
		useCurlyBraces_2 := Trim(A_LoopField)
	}
	if (A_Index = 156) {
		useEnd_2 := Trim(A_LoopField)
	}
	if (A_Index = 157) {
		useSemicolon_2 := Trim(A_LoopField)
	}
	if (A_Index = 158) {
		useParentheses_2 := Trim(A_LoopField)
	}
	if (A_Index = 159) {
		usePrefixTypeForTypeDefinition_2 := Trim(A_LoopField)
	}
	if (A_Index = 160) {
		usePostfixTypeForTypeDefinition_2 := Trim(A_LoopField)
	}
	if (A_Index = 161) {
		usePythonicColonSyntax_2 := Trim(A_LoopField)
	}
	if (A_Index = 162) {
		useCurlyBracesSyntaxForArrayDef_2 := Trim(A_LoopField)
	}
	if (A_Index = 163) {
		useInJavaScriptAlwaysUseVar_2 := Trim(A_LoopField)
	}
	if (A_Index = 164) {
		useJavaScriptInAfullHTMLfile_2 := Trim(A_LoopField)
	}
	if (A_Index = 165) {
		useJavaScriptAmainFuncDef_2 := Trim(A_LoopField)
	}
	if (A_Index = 166) {
		useJavaScriptAllFuncsAreAsync_2 := Trim(A_LoopField)
	}
	if (A_Index = 167) {
		useJavaScriptAlwaysTripleEqual_2 := Trim(A_LoopField)
	}

}

}



if (Trim(langToConvertToParam) != "") {
    langToConvertTo := Trim(langToConvertToParam)
}


int isFullHTVMCode := 0
int isNotHTVMfile := 0

if (Trim(mode) = "full") {
    isFullHTVMCode := 1
} else {
    isFullHTVMCode := 0
}
if (Trim(mode) = "notHTVM") {
    isNotHTVMfile := 1
} else {
    isNotHTVMfile := 0
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
'''1

if (langToConvertTo = langFileExtension_2) {

}
if (langToConvertTo = "cpp") {

}
if (langToConvertTo = "py") {

}
if (langToConvertTo = "js") {

}
if (langToConvertTo = "go") {

}
if (langToConvertTo = "lua") {

}
if (langToConvertTo = "cs") {

}
if (langToConvertTo = "java") {

}
if (langToConvertTo = "kt") {

}
if (langToConvertTo = "rb") {

}
if (langToConvertTo = "nim") {

}
if (langToConvertTo = "ahk") {

}
if (langToConvertTo = "swift") {

}
if (langToConvertTo = "dart") {

}
if (langToConvertTo = "ts") {

}
if (langToConvertTo = "scala") {

}
if (langToConvertTo = "groovy") {

}
'''2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str HTVMout := ""

htCode := Trim(StrReplace(htCode, Chr(13), ""))

str code := ""

print(htCode)
code := htCode
print(mode)
print(langToConvertTo)
print("==================================")
print("==================================")
print("==================================")
print("==================================")
print("==================================")
;print(allInstructionFile)






int haveWeEverUsedAloop := 0
int lineDone := 0
str var1 := ""
str nothing := ""
int AindexcharLength := 1
str AindexcharLengthStr := ""
str theFixTextLoopNL := ""
int htCodeAcurlyBraceAddSomeVrasFixNL := 0
str htCodeLoopfixa := ""
str htCodeLoopfixa1 := ""
str str123 := ""
str out2 := ""
str myVar := ""
str lineYGI := ""
str line := ""
str line1 := ""
str line2 := ""
str line3 := ""
str itemsOut := ""
str var1out := ""
str theFixTextLoopLP := ""
int htCodeAcurlyBraceAddSomeVrasFixLP := 0
int AIndexLoopCurlyFix := 0
str sstr123 := ""
str fixLoopLokingFor := ""
int fixLoopLokingForfound := 0
str out1 := ""
int wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
int inTarget := 0
int insideBracket := 0
int netsedCurly := 0
int eldLoopNestedBADlol := 0
int readyToEnd := 0
int endBracketDOntPutThere := 0
int dontSaveStr := 0
int weAreDoneHereCurly := 0
int DeleayOneCuzOfLoopParse := 0
int fixLoopLokingForNum := 0
int insdeAnestedLoopBAD := 0
int foundTheTopLoop := 0
str out4758686d86d86d86578991a
str ALoopField := ""
str out1z := ""
int insideBracket1 := 0
int netsedCurly1 := 0
int readyToEnd1 := 0
str strstysrstsytTRIMHELP := ""
str out4758686d86dgt8r754444444 := ""
int hold := 0
str holdText := ""
int ignore := 0
str htCodeOut1234565432 := ""
str out := ""
str s := ""
int skipLeftCuleyForFuncPLS := 0




; PROGRAMMING BLOCK
; PROGRAMMING BLOCK
; PROGRAMMING BLOCK
; PROGRAMMING BLOCK



int COUNT_programmingBlock_InTheTranspiledLang := 0
int COUNT_programmingBlock_CPP := 0
int COUNT_programmingBlock_PY := 0
int COUNT_programmingBlock_JS := 0
int COUNT_programmingBlock_GO := 0
int COUNT_programmingBlock_LUA := 0
int COUNT_programmingBlock_CS := 0
int COUNT_programmingBlock_JAVA := 0
int COUNT_programmingBlock_KT := 0
int COUNT_programmingBlock_RB := 0
int COUNT_programmingBlock_NIM := 0
int COUNT_programmingBlock_AHK := 0
int COUNT_programmingBlock_SWIFT := 0
int COUNT_programmingBlock_DART := 0
int COUNT_programmingBlock_TS := 0
int COUNT_programmingBlock_SCALA := 0
int COUNT_programmingBlock_GROOVY := 0
int COUNT_programmingBlock_HTVM := 0
int COUNT_programmingBlock_HTVMsyntax := 0

str programmingBlocksTemp := ""
int inProgarmmingBlock := 0
str holdTempDataProgrammingBlockThenPutInArr := ""

Loop, Parse, code, `n, `r
{

if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEnd))
{

COUNT_programmingBlock_InTheTranspiledLang++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_InTheTranspiledLang-programmingBlock_InTheTranspiledLang-AA" . STR(COUNT_programmingBlock_InTheTranspiledLang) . "AA`n"
programmingBlock_InTheTranspiledLang.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndCPP))
{

COUNT_programmingBlock_CPP++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_CPP-programmingBlock_CPP-AA" . STR(COUNT_programmingBlock_CPP) . "AA`n"
programmingBlock_CPP.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndPY))
{

COUNT_programmingBlock_PY++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_PY-programmingBlock_PY-AA" . STR(COUNT_programmingBlock_PY) . "AA`n"
programmingBlock_PY.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndJS))
{

COUNT_programmingBlock_JS++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_JS-programmingBlock_JS-AA" . STR(COUNT_programmingBlock_JS) . "AA`n"
programmingBlock_JS.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndGO))
{

COUNT_programmingBlock_GO++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_GO-programmingBlock_GO-AA" . STR(COUNT_programmingBlock_GO) . "AA`n"
programmingBlock_GO.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndLUA))
{

COUNT_programmingBlock_LUA++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_LUA-programmingBlock_LUA-AA" . STR(COUNT_programmingBlock_LUA) . "AA`n"
programmingBlock_LUA.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndCS))
{

COUNT_programmingBlock_CS++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_CS-programmingBlock_CS-AA" . STR(COUNT_programmingBlock_CS) . "AA`n"
programmingBlock_CS.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndJAVA))
{

COUNT_programmingBlock_JAVA++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_JAVA-programmingBlock_JAVA-AA" . STR(COUNT_programmingBlock_JAVA) . "AA`n"
programmingBlock_JAVA.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndKT))
{

COUNT_programmingBlock_KT++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_KT-programmingBlock_KT-AA" . STR(COUNT_programmingBlock_KT) . "AA`n"
programmingBlock_KT.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndRB))
{

COUNT_programmingBlock_RB++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_RB-programmingBlock_RB-AA" . STR(COUNT_programmingBlock_RB) . "AA`n"
programmingBlock_RB.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndNIM))
{

COUNT_programmingBlock_NIM++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_NIM-programmingBlock_NIM-AA" . STR(COUNT_programmingBlock_NIM) . "AA`n"
programmingBlock_NIM.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndAHK))
{

COUNT_programmingBlock_AHK++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_AHK-programmingBlock_AHK-AA" . STR(COUNT_programmingBlock_AHK) . "AA`n"
programmingBlock_AHK.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndSWIFT))
{

COUNT_programmingBlock_SWIFT++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_SWIFT-programmingBlock_SWIFT-AA" . STR(COUNT_programmingBlock_SWIFT) . "AA`n"
programmingBlock_SWIFT.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndDART))
{

COUNT_programmingBlock_DART++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_DART-programmingBlock_DART-AA" . STR(COUNT_programmingBlock_DART) . "AA`n"
programmingBlock_DART.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndTS))
{

COUNT_programmingBlock_TS++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_TS-programmingBlock_TS-AA" . STR(COUNT_programmingBlock_TS) . "AA`n"
programmingBlock_TS.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndSCALA))
{

COUNT_programmingBlock_SCALA++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_SCALA-programmingBlock_SCALA-AA" . STR(COUNT_programmingBlock_SCALA) . "AA`n"
programmingBlock_SCALA.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndGROOVY))
{

COUNT_programmingBlock_GROOVY++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_GROOVY-programmingBlock_GROOVY-AA" . STR(COUNT_programmingBlock_GROOVY) . "AA`n"
programmingBlock_GROOVY.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangEndHTVM))
{

COUNT_programmingBlock_HTVM++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_HTVM-programmingBlock_HTVM-AA" . STR(COUNT_programmingBlock_HTVM) . "AA`n"
programmingBlock_HTVM.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInHTVMend))
{
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

COUNT_programmingBlock_HTVMsyntax++
StringTrimRight, holdTempDataProgrammingBlockThenPutInArr, holdTempDataProgrammingBlockThenPutInArr, 1
programmingBlocksTemp .= "programmingBlock_HTVMsyntax-programmingBlock_HTVMsyntax-AA" . STR(COUNT_programmingBlock_HTVMsyntax) . "AA`n"
programmingBlock_HTVMsyntax.add(holdTempDataProgrammingBlockThenPutInArr)
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
}
else if (inProgarmmingBlock = 1)
{
holdTempDataProgrammingBlockThenPutInArr .= A_LoopField . "`n"
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStart))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartCPP))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartPY))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartJS))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartGO))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartLUA))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartCS))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartJAVA))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartKT))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartRB))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartNIM))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartAHK))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartSWIFT))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartDART))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartTS))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartSCALA))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartGROOVY))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInTheTranspiledLangStartHTVM))
{
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
}
else if (Trim(StrLower(A_LoopField)) = StrLower(keyWordCodeInHTVMstart))
{
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
holdTempDataProgrammingBlockThenPutInArr := ""
inProgarmmingBlock := 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
}
else
{
programmingBlocksTemp .= A_LoopField . "`n"
}

}
StringTrimRight, code, programmingBlocksTemp, 1

;programmingBlock_InTheTranspiledLang
;programmingBlock_CPP
;programmingBlock_PY
;programmingBlock_JS
;programmingBlock_GO
;programmingBlock_LUA
;programmingBlock_CS
;programmingBlock_JAVA
;programmingBlock_KT
;programmingBlock_RB
;programmingBlock_NIM
;programmingBlock_AHK
;programmingBlock_SWIFT
;programmingBlock_DART
;programmingBlock_TS
;programmingBlock_SCALA
;programmingBlock_GROOVY
;programmingBlock_HTVM
;programmingBlock_HTVMsyntax

; PROGRAMMING BLOCK
; PROGRAMMING BLOCK
; PROGRAMMING BLOCK
; PROGRAMMING BLOCK

arr str lookIntoTheNextLineForFuncWhitNoKeyWord
int didWeUseMainLabel := 0
str codeOutFixAndAddMainFunc := ""
str htCodeOutFixEnd := ""
int htCodeOutFixINT := 0
int htCodeOutFixINT2 := 0

str beforeKeywordForRemoveCommentsOnTheEndOfTheLine := ""
str newStringOutCode := ""
int posForRemoveCommentsOnTheEndOfTheLine := 0
str originalStringForRemoveCommentsOnTheEndOfTheLine := ""
str OutFixDoubleQuotesInsideDoubleQuotes := ""

int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
str htCodeOUT754754 := ""
int areWEinSome34sNum := 0
int theIdNumOfThe34 := 0




arr str theIdNumOfThe34theVar

str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
arr str getAllCharForTheFurtureSoIcanAddEscapeChar

int removeNexFixkeyWordEscpaeChar := 0

if (isNotHTVMfile = 0)
{

print("============programmingBlock_CPP==================")
print("============programmingBlock_CPP==================")
if (programmingBlock_CPP.size() > 0)
{
Loop, % programmingBlock_CPP.size()
{
print(programmingBlock_CPP[A_Index])
}
}
print("============programmingBlock_CPP==================")
print("============programmingBlock_CPP==================")



Loop, Parse, code
{
theIdNumOfThe34theVar.add("")
theIdNumOfThe34theVar.add("")
}

Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
}

getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")

ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuusgfgesrheidForQQQasdsasQQQtheuhtuwaesphoutr" . Chr(34)


Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}


code := OutFixDoubleQuotesInsideDoubleQuotes

if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}




if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1) 
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)

}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}

theIdNumOfThe34theVar.add(Chr(34))



code := StrReplace(code, Chr(13), "")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


if (langToConvertTo = langFileExtension_2)
{

if (useSemicolon_2 = "on") {
    theSemicolon := ";"
} else {
    theSemicolon := ""
}



if (usePythonicColonSyntax_2 = "off") {
    theColon := ""
} else {
    theColon := ":"
}


}
else
{

if (langToConvertTo != "py") and (langToConvertTo != "nim") and (langToConvertTo != "lua") and (langToConvertTo != "rb") and (langToConvertTo != "go") and (langToConvertTo != "swift") and (useSemicolon = "off") {
    theSemicolon := ";"
} else {
    theSemicolon := ""
}



if (langToConvertTo != "py") and (langToConvertTo != "nim") and (usePythonicColonSyntax = "off") {
    theColon := ""
} else {
    theColon := ":"
}


}


Loop, Parse, code, `n, `r
{

; Define the original string
originalStringForRemoveCommentsOnTheEndOfTheLine := A_LoopField

; Find the position of the keyword in the original string
posForRemoveCommentsOnTheEndOfTheLine := InStr(originalStringForRemoveCommentsOnTheEndOfTheLine, " " . keyWordComment)

if (SubStr(Trim(A_LoopField), 1, StrLen(keyWordComment)) != keyWordComment)
{
if (posForRemoveCommentsOnTheEndOfTheLine > 0)
{


beforeKeywordForRemoveCommentsOnTheEndOfTheLine := A_LoopField


; Construct the new string with everything before the keyword
newStringOutCode .= beforeKeywordForRemoveCommentsOnTheEndOfTheLine . "`n"
}
else
{
newStringOutCode .= A_LoopField . "`n"
}
}
else
{
newStringOutCode .= A_LoopField . "`n"
}

}

StringTrimRight, code, newStringOutCode, 1
;MsgBox, % code



if (useCurlyBraces = "on")
{
if (keyWordCurlyBraceOpen != "{")
{

Loop, Parse, code, `n, `r
{
htCodeOutFixINT2 := 0
if (isLineAconstruct(Trim(A_LoopField)) = true) or (Trim(A_LoopField) = keyWordCurlyBraceOpen)
{
htCodeOutFixINT2 := 1
}

htCodeOutFixINT := 0
Loop, Parse, A_LoopField, " "
{
htCodeOutFixINT++
}

htCodeOutFixINT--
Loop, Parse, A_LoopField, " "
{
if (htCodeOutFixINT = A_Index) && (htCodeOutFixINT2 = 1)
{
htCodeOutFixINT2 := 0
htCodeOutFixEnd .= HTVMmatchStrRrplace(A_LoopField, keyWordCurlyBraceOpen, "{") . " "
}
else
{
htCodeOutFixEnd .= A_LoopField . " "
}

}
StringTrimRight, htCodeOutFixEnd, htCodeOutFixEnd, 1
htCodeOutFixEnd .= "`n"

}
StringTrimRight, code, htCodeOutFixEnd, 1

}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
htCodeOutFixEnd := ""

if (keyWordCurlyBraceClose != "}")
{

Loop, Parse, code, `n, `r
{
htCodeOutFixINT2 := 0
if (isLineAconstruct(Trim(A_LoopField)) = true) or (Trim(A_LoopField) = keyWordCurlyBraceClose)
{
htCodeOutFixINT2 := 1
}


Loop, Parse, A_LoopField, " "
{
if (htCodeOutFixINT2 = 1) or (Trim(A_LoopField) = keyWordCurlyBraceClose)
{
htCodeOutFixINT2 := 0
htCodeOutFixEnd .= HTVMmatchStrRrplace(A_LoopField, keyWordCurlyBraceClose, "}") . " "
}
else
{
htCodeOutFixEnd .= A_LoopField . " "
}

}
StringTrimRight, htCodeOutFixEnd, htCodeOutFixEnd, 1
htCodeOutFixEnd .= "`n"

}
StringTrimRight, code, htCodeOutFixEnd, 1

}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

htCodeOutFixEnd := ""
if (useEnd = "on")
{
Loop, Parse, code, `n, `r
{
if (StrLower(Trim(A_LoopField)) = StrLower(keyWordEnd))
{
htCodeOutFixEnd .= "}`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1
}

if (usePythonicColonSyntax = "off")
{
if (useEnd = "off") and (useCurlyBraces = "off")
{
htCodeOutFixEnd := ""
Loop, Parse, code, `n, `r
{
if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1

}

}



if (useCurlyBraces = "off") and (useEnd = "off")
{
code := AddCurlyBraces(code)
}



outTrimCode := ""
Loop, Parse, code, `n, `r
{
outTrimCode .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, outTrimCode, 1


; for converting c++ to js and py
;code := StrReplace(code, "{}", "[]")

str outCodeFixBraces := ""
Loop, 2
{
outCodeFixBraces := ""
Loop, Parse, code, `n, `r
{
if (InStr(Trim(A_LoopField), "{")) and (Trim(A_LoopField) != "{")
{
outCodeFixBraces .= Trim(StrReplace(Trim(A_LoopField), "{", "")) . "`n{`n"
}
else if (InStr(Trim(A_LoopField), "}")) and (Trim(A_LoopField) != "}")
{
outCodeFixBraces .= "}`n" . Trim(StrReplace(Trim(A_LoopField), "}", "")) . "`n"
}
else
{
outCodeFixBraces .= Trim(A_LoopField) . "`n"
}

}

StringTrimRight, code, outCodeFixBraces, 1
}



htCodeOutFixEnd := ""
if (usePythonicColonSyntax = "on")
{


Loop, Parse, code, `n, `r
{
if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= StringTrimRight(A_LoopField, 1) . "`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}

}

StringTrimRight, code, htCodeOutFixEnd, 1
}




;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;
fullLangAllOperators := await GETfullLangAllOperators()
fullLangAllOperators_HELP := await GETfullLangAllOperators_HELP()



if (isNotHTVMfile2 = 0)
{



Loop, Parse, code, `n, `r
{

if (StrLower(A_LoopField) = StrLower(keyWordMainLabel))
{
didWeUseMainLabel := 1
if (langToConvertTo = "cpp")
{
codeOutFixAndAddMainFunc .= "int main(int argc, char* argv[])`n{`n"
}
if (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc .= "async function main()`n{`n"
}
if (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc .= "async function main(): Promise<void>`n{`n"
}
if (langToConvertTo = "go")
{
codeOutFixAndAddMainFunc .= "func main()`n{`n"
}
if (langToConvertTo = "cs")
{
codeOutFixAndAddMainFunc .= "static void Main(string[] args)`n{`n"
}
if (langToConvertTo = "java")
{
codeOutFixAndAddMainFunc .= "public static void main(String[] args)`n{`n"
}
if (langToConvertTo = "kt")
{
codeOutFixAndAddMainFunc .= "fun main(args: Array<String>)`n{`n"
}
if (langToConvertTo = "swift")
{
codeOutFixAndAddMainFunc .= "func main()`n{`n"
}
if (langToConvertTo = "dart")
{
codeOutFixAndAddMainFunc .= "void main(List<String> arguments)`n{`n"
}
if (langToConvertTo = "scala")
{
    codeOutFixAndAddMainFunc .= "ndef main(args: Array[String]): Unit = `n{`n"
}

}
else
{
codeOutFixAndAddMainFunc .= A_LoopField . "`n"
}
}

if (didWeUseMainLabel != 1) and (langToConvertTo = "cpp")
{
codeOutFixAndAddMainFunc := "int main(int argc, char* argv[])`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc := "async function main()`n{`n" . codeOutFixAndAddMainFunc
}

if (didWeUseMainLabel != 1) and (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
    codeOutFixAndAddMainFunc := "async function main(): Promise<void>`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "go")
{
    codeOutFixAndAddMainFunc := "func main()`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "cs")
{
    codeOutFixAndAddMainFunc := "static void Main(string[] args)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "java")
{
    codeOutFixAndAddMainFunc := "public static void main(String[] args)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "kt")
{
    codeOutFixAndAddMainFunc := "fun main(args: Array<String>)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "swift")
{
    codeOutFixAndAddMainFunc := "func main()`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "dart")
{
    codeOutFixAndAddMainFunc := "void main(List<String> arguments)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "scala")
{
    codeOutFixAndAddMainFunc := "def main(args: Array[String]): Unit = `n{`n" . codeOutFixAndAddMainFunc
}

StringTrimRight, code, codeOutFixAndAddMainFunc, 1
; main loop
; main loop
}

Loop, Parse, code, `n, `r
{
lookIntoTheNextLineForFuncWhitNoKeyWord.add(A_LoopField)
}
lookIntoTheNextLineForFuncWhitNoKeyWord.add(" ")






htCode := ""
print("=======UP==========")
print(code)
print("=======DOWN==========")
Loop, Parse, code, `n, `r
{
lineDone := 0
if (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite)) or (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite . ":"))
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1

if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , value in enumerate(iter(int, 1), start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", someLimit do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit)"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit:"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop"
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< someLimit"
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to someLimit)"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit)"
}
if (langToConvertTo = langFileExtension_2)
{
if (usePythonicColonSyntax_2 = "on")
{
var1 := keyWordLoopInfinite_2 . ":"
}
else
{
var1 := keyWordLoopInfinite_2
}
}


nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
lineDone := 1
if (langToConvertTo != "ahk") and (langToConvertTo != langFileExtension_2)
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop)) and (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) != StrLower(keyWordLoop) . "% ") and (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) != StrLower(keyWordLoopParse))
{
out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop))
out2 := StrReplace(out2, ":", "")
;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ":"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop, " . line 
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< " . line . " + " . AHKlikeLoopsIndexedAt
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to " . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = langFileExtension_2)
{
if (usePythonicColonSyntax_2 = "on")
{
var1 := Trim(keyWordLoop_2) . " " . line . ":"
}
else
{
var1 := Trim(keyWordLoop_2) . " " . line
}
}

nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
if (langToConvertTo != "ahk") and (langToConvertTo != langFileExtension_2)
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) = StrLower(keyWordLoop) . "% ")
{

out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop) + 2)
out2 := StrReplace(out2, ":", "")

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ":"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop, % " . line 
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< " . line . " + " . AHKlikeLoopsIndexedAt
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to " . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = langFileExtension_2)
{

if (usePythonicColonSyntax_2 = "on")
{
var1 := Trim(keyWordLoop_2) . " % " . line . ":"
}
else
{
var1 := Trim(keyWordLoop_2) . " % " . line
}
}


nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
if (langToConvertTo != "ahk") and (langToConvertTo != langFileExtension_2)
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
var1 := StringTrimLeft(A_LoopField, StrLen(keyWordLoopParse))
out2 := StrReplace(out2, ":", "")
lineDone := 1

line1 := Trim(StrSplit(var1, ",", 1))

line1 := expressionParserTranspiler(line1)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, keyWordEscpaeChar . ","))
{
line2 := Chr(34) . "," . Chr(34)


if (langToConvertTo = "py")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}

}
else
{


if (line2 = "") and (line3 = "")
{
; nothing so only each char
if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}



}

if (line2 != "") and (line3 = "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}



}

if (line2 != "") and (line3 != "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, keyWordEscpaeChar))
{
line3 := Chr(34) . line3 . Chr(34)
}

if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}


if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
    
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}

}



itemsOut := StrReplace(itemsOut, keyWordEscpaeChar, Chr(92))



}



if (langToConvertTo = "py")
{
var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in enumerate(items" . STR(AindexcharLength) . ", start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1out := itemsOut . "`n" . "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1out := itemsOut . "`n" . "for (size_t " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".size() + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " := range(items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "lua")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in ipairs(items" . STR(AindexcharLength) . ") do"
}
if (langToConvertTo = "cs")
{
    var1out := itemsOut . "`n" . "foreach (var " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "java")
{
    var1out := itemsOut . "`n" . "for (" . keyWordALoopField . "" . STR(AindexcharLength) . " : items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "kt")
{
    var1out := itemsOut . "`n" . "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . ".withIndex())"
}
if (langToConvertTo = "rb")
{
    var1out := itemsOut . "`n" . "items" . STR(AindexcharLength) . ".each_with_index do |" . keyWordALoopField . "" . STR(AindexcharLength) . " , " . keyWordAIndex . "" . STR(AindexcharLength) . "|"
}
if (langToConvertTo = "nim")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . " | " . keyWordAIndex . "" . STR(AindexcharLength) . " += 1:"
}
if (langToConvertTo = "ahk")
{
    var1out := "Loop, Parse, " . line1 . " " . line2 . " " . line3
}
if (langToConvertTo = "swift")
{
    var1out := itemsOut . "`n" . "for (index, " . keyWordALoopField . "" . STR(AindexcharLength) . ") in items" . STR(AindexcharLength) . ".enumerated()"
}
if (langToConvertTo = "dart")
{
    var1out := itemsOut . "`n" . "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = 0; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1out := itemsOut . "`n" . "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = 0; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1out := itemsOut . "`n" . "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- items" . STR(AindexcharLength) . ".indices)"
}
if (langToConvertTo = "groovy")
{
    var1out := itemsOut . "`n" . "items" . STR(AindexcharLength) . ".eachWithIndex { " . keyWordALoopField . "" . STR(AindexcharLength) . " , " . keyWordAIndex . "" . STR(AindexcharLength) . " ->"
}



nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

;
;
theFixTextLoopLP := ""
if (langToConvertTo = "cpp")
{
theFixTextLoopLP := "std::string " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}
if (langToConvertTo = "js")
{
theFixTextLoopLP := "const " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}
if (langToConvertTo = "go")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " := items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "lua")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "cs")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "java")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "kt")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "rb")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "nim")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "ahk")
{
    theFixTextLoopLP := "`n"
}
if (langToConvertTo = "swift")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "dart")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "ts")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "scala")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "groovy")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}



htCodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
if (langToConvertTo != "ahk") and (langToConvertTo != langFileExtension_2)
{
htCodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++

if (langToConvertTo = langFileExtension_2)
{

if (usePythonicColonSyntax_2 = "on")
{
htCode .= Trim(keyWordLoopParse_2) . " " . var1 . ":`n"
}
else
{
htCode .= Trim(keyWordLoopParse_2) . " " . var1 . "`n"
}



}
else
{

htCode .= htCodeLoopfixa1 . "`n" . var1out . "`n"
}




}
else if ((SubStr(Trim(A_LoopField), -2) = ");") or (SubStr(Trim(A_LoopField), -1) = ")")) and (!(InStr(A_LoopField, "int main(int argc, char* argv[])"))) and (!(InStr(A_LoopField, "async function main()"))) and (lineDone = 0)
{
lineDone := 1
str1 := Trim(A_LoopField)

fixExpertionLineFuncOnly := 1
if (langToConvertTo = langFileExtension_2)
{
if (useSemicolon_2 = "on")
{
str2 := expressionParserTranspiler(Trim(str1)) . ";"
}
else
{
str2 := expressionParserTranspiler(Trim(str1))
}


}
else
{
if (langToConvertTo = "py") or (langToConvertTo = "nim") or (langToConvertTo = "ahk") or (langToConvertTo = "go") or (langToConvertTo = "lua") or (langToConvertTo = "kt") or (langToConvertTo = "rb") or (langToConvertTo = "swift") or (langToConvertTo = "scala") or (langToConvertTo = "groovy") 
{
if (SubStrLastChars(str1, 1) = ";")
{
StringTrimRight, str1, str1, 1
}

}



str2 := expressionParserTranspiler(Trim(str1)) . ";"
if (langToConvertTo = "py") or (langToConvertTo = "nim") or (langToConvertTo = "ahk") or (langToConvertTo = "go") or (langToConvertTo = "lua") or (langToConvertTo = "kt") or (langToConvertTo = "rb") or (langToConvertTo = "swift") or (langToConvertTo = "scala") or (langToConvertTo = "groovy") 
{
if (SubStrLastChars(str2, 1) = ";")
{
StringTrimRight, str2, str2, 1
}
}


}
fixExpertionLineFuncOnly := 0
htCode .= str2 . "`n"
}
else
{
;print("else else else " . A_LoopField)
; this is THE else
if (lineDone != 1)
{
if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
htCode .= Chr(125) . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixLP = 1) and (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixLP := 0


htCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixNL = 1) and (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixNL := 0
htCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
htCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}
}
}

}
StringTrimRight, htCode, htCode, 1



















;s
;s
;s
if (langToConvertTo != "ahk") and (langToConvertTo != langFileExtension_2)
{

;s

if (haveWeEverUsedAloop = 1)
{

StringTrimRight, htCodeLoopfixa, htCodeLoopfixa, 1

;OutputDebug, |%htCodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, htCodeLoopfixa, `n, `r
{



sstr123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(sstr123 ,"|" , 1)
out2 := StrSplit(sstr123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{

inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) and (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (weAreDoneHereCurly != 1) and (insdeAnestedLoopBAD != 1) and (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField


DeleayOneCuzOfLoopParse := 1


out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(125))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (insdeAnestedLoopBAD != 1) and (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) and (readyToEnd1 = 1) and (netsedCurly1 = 0) and (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}

out4758686d86d86d86578991a .= A_LoopField . "`n"
}


if (inTarget = 1) and (dontSaveStr != 1) and (fixLoopLokingForNum != 1) and (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\d*", "" . keyWordAIndex . "" . out1z)




out4758686d86d86d86578991a .= ALoopField . "`n"

}


if (inTarget = 1) and (InStr(A_LoopField, Chr(125))) and (readyToEnd = 1) and (netsedCurly = 0) and (weAreDoneHereCurly = 0) and (dontSaveStr != 1) and (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) and (endBracketDOntPutThere != 1) and (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) and (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (weAreDoneHereCurly != 1) and (insdeAnestedLoopBAD != 1) and (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField

DeleayOneCuzOfLoopParse := 1

out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(125))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (insdeAnestedLoopBAD != 1) and (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) and (readyToEnd1 = 1) and (netsedCurly1 = 0) and (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}


out4758686d86d86d86578991a .= A_LoopField . "`n"

}


if (inTarget = 1) and (dontSaveStr != 1) and (fixLoopLokingForNum != 1) and (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField

; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\d*", "" . keyWordAIndex . "" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordALoopField . "\d*", "" . keyWordALoopField . "" . out1z)





out4758686d86d86d86578991a .= ALoopField . "`n"

}


if ((inTarget = 1) and (InStr(A_LoopField, Chr(125))) and (readyToEnd = 1) and (netsedCurly = 0) and (weAreDoneHereCurly = 0) and (dontSaveStr != 1) and (insdeAnestedLoopBAD != 1))
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) and (endBracketDOntPutThere != 1) and (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, htCode, `n, `r
{
ignore := 0
if (SubStr(Trim(A_LoopField), 1, 4) = "for ")
{
if (hold = 1) and (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!ignore)
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
htCode := out4758686d86dgt8r754444444


}


htCodeOut1234565432 := ""
Loop, Parse, htCode, `n, `r
{
out := A_LoopField
if (!InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|"))
{
htCodeOut1234565432 .= out . "`n"
}
}


StringTrimRight, htCode, htCodeOut1234565432, 1



}














}
else
{
htCode := code
}


if (COUNT_programmingBlock_InTheTranspiledLang != 0)
{
    Loop, % COUNT_programmingBlock_InTheTranspiledLang
    {
        htCode := StrReplace(htCode, "programmingBlock_InTheTranspiledLang-programmingBlock_InTheTranspiledLang-AA" . STR(A_Index + 1) . "AA", programmingBlock_InTheTranspiledLang[A_Index])
    }
}

if (langToConvertTo = "cpp")
{
    if (COUNT_programmingBlock_CPP != 0)
    {
        Loop, % COUNT_programmingBlock_CPP
        {
            htCode := StrReplace(htCode, "programmingBlock_CPP-programmingBlock_CPP-AA" . STR(A_Index + 1) . "AA", programmingBlock_CPP[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_CPP != 0)
    {
        Loop, % COUNT_programmingBlock_CPP
        {
            htCode := StrReplace(htCode, "programmingBlock_CPP-programmingBlock_CPP-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}


if (langToConvertTo = "py")
{
    if (COUNT_programmingBlock_PY != 0)
    {
        Loop, % COUNT_programmingBlock_PY
        {
            htCode := StrReplace(htCode, "programmingBlock_PY-programmingBlock_PY-AA" . STR(A_Index + 1) . "AA", programmingBlock_PY[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_PY != 0)
    {
        Loop, % COUNT_programmingBlock_PY
        {
            htCode := StrReplace(htCode, "programmingBlock_PY-programmingBlock_PY-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}


if (langToConvertTo = "js")
{
    if (COUNT_programmingBlock_JS != 0)
    {
        Loop, % COUNT_programmingBlock_JS
        {
            htCode := StrReplace(htCode, "programmingBlock_JS-programmingBlock_JS-AA" . STR(A_Index + 1) . "AA", programmingBlock_JS[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_JS != 0)
    {
        Loop, % COUNT_programmingBlock_JS
        {
            htCode := StrReplace(htCode, "programmingBlock_JS-programmingBlock_JS-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "go")
{
    if (COUNT_programmingBlock_GO != 0)
    {
        Loop, % COUNT_programmingBlock_GO
        {
            htCode := StrReplace(htCode, "programmingBlock_GO-programmingBlock_GO-AA" . STR(A_Index + 1) . "AA", programmingBlock_GO[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_GO != 0)
    {
        Loop, % COUNT_programmingBlock_GO
        {
            htCode := StrReplace(htCode, "programmingBlock_GO-programmingBlock_GO-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "lua")
{
    if (COUNT_programmingBlock_LUA != 0)
    {
        Loop, % COUNT_programmingBlock_LUA
        {
            htCode := StrReplace(htCode, "programmingBlock_LUA-programmingBlock_LUA-AA" . STR(A_Index + 1) . "AA", programmingBlock_LUA[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_LUA != 0)
    {
        Loop, % COUNT_programmingBlock_LUA
        {
            htCode := StrReplace(htCode, "programmingBlock_LUA-programmingBlock_LUA-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "cs")
{
    if (COUNT_programmingBlock_CS != 0)
    {
        Loop, % COUNT_programmingBlock_CS
        {
            htCode := StrReplace(htCode, "programmingBlock_CS-programmingBlock_CS-AA" . STR(A_Index + 1) . "AA", programmingBlock_CS[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_CS != 0)
    {
        Loop, % COUNT_programmingBlock_CS
        {
            htCode := StrReplace(htCode, "programmingBlock_CS-programmingBlock_CS-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "java")
{
    if (COUNT_programmingBlock_JAVA != 0)
    {
        Loop, % COUNT_programmingBlock_JAVA
        {
            htCode := StrReplace(htCode, "programmingBlock_JAVA-programmingBlock_JAVA-AA" . STR(A_Index + 1) . "AA", programmingBlock_JAVA[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_JAVA != 0)
    {
        Loop, % COUNT_programmingBlock_JAVA
        {
            htCode := StrReplace(htCode, "programmingBlock_JAVA-programmingBlock_JAVA-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}


if (langToConvertTo = "js")
{
    if (COUNT_programmingBlock_JS != 0)
    {
        Loop, % COUNT_programmingBlock_JS
        {
            htCode := StrReplace(htCode, "programmingBlock_JS-programmingBlock_JS-AA" . STR(A_Index + 1) . "AA", programmingBlock_JS[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_JS != 0)
    {
        Loop, % COUNT_programmingBlock_JS
        {
            htCode := StrReplace(htCode, "programmingBlock_JS-programmingBlock_JS-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "go")
{
    if (COUNT_programmingBlock_GO != 0)
    {
        Loop, % COUNT_programmingBlock_GO
        {
            htCode := StrReplace(htCode, "programmingBlock_GO-programmingBlock_GO-AA" . STR(A_Index + 1) . "AA", programmingBlock_GO[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_GO != 0)
    {
        Loop, % COUNT_programmingBlock_GO
        {
            htCode := StrReplace(htCode, "programmingBlock_GO-programmingBlock_GO-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "lua")
{
    if (COUNT_programmingBlock_LUA != 0)
    {
        Loop, % COUNT_programmingBlock_LUA
        {
            htCode := StrReplace(htCode, "programmingBlock_LUA-programmingBlock_LUA-AA" . STR(A_Index + 1) . "AA", programmingBlock_LUA[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_LUA != 0)
    {
        Loop, % COUNT_programmingBlock_LUA
        {
            htCode := StrReplace(htCode, "programmingBlock_LUA-programmingBlock_LUA-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "cs")
{
    if (COUNT_programmingBlock_CS != 0)
    {
        Loop, % COUNT_programmingBlock_CS
        {
            htCode := StrReplace(htCode, "programmingBlock_CS-programmingBlock_CS-AA" . STR(A_Index + 1) . "AA", programmingBlock_CS[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_CS != 0)
    {
        Loop, % COUNT_programmingBlock_CS
        {
            htCode := StrReplace(htCode, "programmingBlock_CS-programmingBlock_CS-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "java")
{
    if (COUNT_programmingBlock_JAVA != 0)
    {
        Loop, % COUNT_programmingBlock_JAVA
        {
            htCode := StrReplace(htCode, "programmingBlock_JAVA-programmingBlock_JAVA-AA" . STR(A_Index + 1) . "AA", programmingBlock_JAVA[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_JAVA != 0)
    {
        Loop, % COUNT_programmingBlock_JAVA
        {
            htCode := StrReplace(htCode, "programmingBlock_JAVA-programmingBlock_JAVA-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "ts")
{
    if (COUNT_programmingBlock_TS != 0)
    {
        Loop, % COUNT_programmingBlock_TS
        {
            htCode := StrReplace(htCode, "programmingBlock_TS-programmingBlock_TS-AA" . STR(A_Index + 1) . "AA", programmingBlock_TS[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_TS != 0)
    {
        Loop, % COUNT_programmingBlock_TS
        {
            htCode := StrReplace(htCode, "programmingBlock_TS-programmingBlock_TS-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "scala")
{
    if (COUNT_programmingBlock_SCALA != 0)
    {
        Loop, % COUNT_programmingBlock_SCALA
        {
            htCode := StrReplace(htCode, "programmingBlock_SCALA-programmingBlock_SCALA-AA" . STR(A_Index + 1) . "AA", programmingBlock_SCALA[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_SCALA != 0)
    {
        Loop, % COUNT_programmingBlock_SCALA
        {
            htCode := StrReplace(htCode, "programmingBlock_SCALA-programmingBlock_SCALA-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

if (langToConvertTo = "groovy")
{
    if (COUNT_programmingBlock_GROOVY != 0)
    {
        Loop, % COUNT_programmingBlock_GROOVY
        {
            htCode := StrReplace(htCode, "programmingBlock_GROOVY-programmingBlock_GROOVY-AA" . STR(A_Index + 1) . "AA", programmingBlock_GROOVY[A_Index])
        }
    }
}
else
{
    if (COUNT_programmingBlock_GROOVY != 0)
    {
        Loop, % COUNT_programmingBlock_GROOVY
        {
            htCode := StrReplace(htCode, "programmingBlock_GROOVY-programmingBlock_GROOVY-AA" . STR(A_Index + 1) . "AA", "`n")
        }
    }
}

;;;;;;;;;;;
if (langToConvertTo = langFileExtension_2)
{
if (COUNT_programmingBlock_HTVM != 0)
{
    Loop, % COUNT_programmingBlock_HTVM
    {
        htCode := StrReplace(htCode, "programmingBlock_HTVM-programmingBlock_HTVM-AA" . STR(A_Index + 1) . "AA", programmingBlock_HTVM[A_Index])
    }
}

}
else
{
if (COUNT_programmingBlock_HTVM != 0)
{
    Loop, % COUNT_programmingBlock_HTVM
    {
        htCode := StrReplace(htCode, "programmingBlock_HTVM-programmingBlock_HTVM-AA" . STR(A_Index + 1) . "AA", "`n")
    }
}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;

str ADD_ALL_programmingBlock_HTVMsyntax := ""

if (COUNT_programmingBlock_HTVMsyntax != 0)
{
isNotHTVMfileEXTRA_INT := 1
Loop, % COUNT_programmingBlock_HTVMsyntax
{
ADD_ALL_programmingBlock_HTVMsyntax .= programmingBlock_HTVMsyntax[A_Index] . "`n"
}
StringTrimRight, ADD_ALL_programmingBlock_HTVMsyntax, ADD_ALL_programmingBlock_HTVMsyntax, 1

ADD_ALL_programmingBlock_HTVMsyntax := compiler(ADD_ALL_programmingBlock_HTVMsyntax, allInstructionFile, "full", langToConvertToParam)
isNotHTVMfileEXTRA_INT := 0

isNotHTVMfile2 := 1
    Loop, % COUNT_programmingBlock_HTVMsyntax
    {
        htCode := StrReplace(htCode, "programmingBlock_HTVMsyntax-programmingBlock_HTVMsyntax-AA" . STR(A_Index + 1) . "AA", compiler(programmingBlock_HTVMsyntax[A_Index], allInstructionFile, "full", langToConvertToParam))
    }
isNotHTVMfile2 := 0
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;





if (isNotHTVMfile = 1)
{
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("`n" . isNotHTVMfileEXTRA_LIB_INFO . "`n")

print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed")
print("`n" . isNotHTVMfileEXTRA_FUNCS_INFO . "`n")

print("`n")
print("`nYou must include all the libs from under the section and MAKE SURE your code doesn't already use them!!!")
print("LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS LIBS")
print("`nYou must copy-paste all the funcs from under the section and MAKE SURE your code doesn't already use them!!!")
print("Funcs needed Funcs needed Funcs needed Funcs needed Funcs needed`n")
print("SCROLL UP!!!!!")
print("SCROLL UP!!!!!")
print("SCROLL UP!!!!!")
print("Note: If you dont see any libs or built-in functions that you need to add, then that means you dont have to!")

return htCode
}





str fixLuaAndRuby := ""
if (langToConvertTo = langFileExtension_2)
{



if (useCurlyBraces_2 = "off") and (useEnd_2 = "off")
{
htCode := indent_nested_curly_braces(htCode, 0)
}
else
{
htCode := indent_nested_curly_braces(htCode, 1)
}




if (useEnd_2 = "on") 
{

    Loop, Parse, htCode, `n, `r
    {
        if (Trim(A_LoopField) = keyWordCurlyBraceClose_2)
        {
            fixLuaAndRuby .= StrReplace(A_LoopField, keyWordCurlyBraceClose_2, Trim(keyWordEnd_2)) . "`n"
        }
        else if (SubStrLastChars(A_LoopField, 2) = " " . keyWordCurlyBraceOpen_2)
        {
            fixLuaAndRuby .= StringTrimRight(A_LoopField, 2) . "`n"
        }
        else
        {
            fixLuaAndRuby .= A_LoopField . "`n"
        }
    }
    StringTrimRight, htCode, fixLuaAndRuby, 1
}




;;;;;;;;;;;
;;;;;;;;;;;
}
else
{
;;;;;;;;;;;
;;;;;;;;;;;


if (langToConvertTo = "py") or (langToConvertTo = "nim")
{
htCode := indent_nested_curly_braces(htCode, 0)
}
else
{
htCode := indent_nested_curly_braces(htCode, 1)
}



if (langToConvertTo = "lua") or (langToConvertTo = "rb")
{

    Loop, Parse, htCode, `n, `r
    {
        if (Trim(A_LoopField) = "}")
        {
            fixLuaAndRuby .= StrReplace(A_LoopField, "}", "end") . "`n"
        }
        else if (SubStrLastChars(A_LoopField, 2) = " {")
        {
            fixLuaAndRuby .= StringTrimRight(A_LoopField, 2) . "`n"
        }
        else
        {
            fixLuaAndRuby .= A_LoopField . "`n"
        }
    }
    StringTrimRight, htCode, fixLuaAndRuby, 1
}



}






areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0

str funcLangHolder := ""
str funcNameHolder := ""
str funcLibsHolder := ""
str funcFuncHolder := ""
str funcDescriptionHolder := ""

arr str allFuncLang
arr str allFuncNames
arr str allFuncLibs
arr str allFuncs
arr str allfuncDescription


int correctLang := 0
Loop, Parse, instructions, `n, `r
{
if (Trim(A_LoopField) = "funcEND======================funcEND==============")
{
areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
;MsgBox, % funcFuncHolder
allFuncs.add(funcFuncHolder)
}
correctLang := 0
funcFuncHolder := ""
}

if (areWeInAFuncFromInstructions = 1)
{

if (areWeInAFuncFromInstructionsLineNum = 1)
{
; name of the func
StringTrimLeft, funcLangHolder, A_LoopField, 5
if (Trim(funcLangHolder) = langToConvertTo)
{
allFuncLang.add(Trim(funcLangHolder))
correctLang := 1
}
}
if (areWeInAFuncFromInstructionsLineNum = 2)
{
; name of the func
StringTrimLeft, funcNameHolder, A_LoopField, 5
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allFuncNames.add(Trim(funcNameHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum = 3)
{
; all libs
StringTrimLeft, funcLibsHolder, A_LoopField, 5
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allFuncLibs.add(Trim(funcLibsHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum = 4)
{
; func description
StringTrimLeft, funcDescriptionHolder, A_LoopField, 12
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allfuncDescription.add(Trim(funcDescriptionHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum >= 5)
{
; the full func
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
funcFuncHolder .= A_LoopField . "`n"
}
}

;MsgBox, % A_LoopField

areWeInAFuncFromInstructionsLineNum++
}


if (Trim(A_LoopField) = "func======================func==============")
{
areWeInAFuncFromInstructions := 1
areWeInAFuncFromInstructionsLineNum := 1
correctLang := 0
}



}

;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncNames
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLibs
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLang
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncs
;~ MsgBox, ===========================================================================



if (isNotHTVMfile2 = 0)
{

if (langToConvertTo = "cpp")
{
htCode := htCode . "`n    return 0;`n}"
htCode := StrReplace(htCode, "int main(int argc, char* argv[]);", "int main(int argc, char* argv[])")
}
if (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
htCode := htCode . "`n}`nmain();"
htCode := StrReplace(htCode, "async function main();", "async function main()")
htCode := StrReplace(htCode, "function async function main()", "async function main()")
}


if (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
    htCode := htCode . "`n}`nmain();"
    htCode := StrReplace(htCode, "async function main(): Promise<void>;", "async function main(): Promise<void>")
    htCode := StrReplace(htCode, "function async function main(): Promise<void>", "async function main(): Promise<void>")
}

if (langToConvertTo = "go")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "func main();", "func main()")
}

if (langToConvertTo = "cs")
{
    htCode := htCode . "`n    }`n}"
    htCode := StrReplace(htCode, "static void Main(string[] args);", "static void Main(string[] args)")
}

if (langToConvertTo = "java")
{
    htCode := htCode . "`n    }`n}"
    htCode := StrReplace(htCode, "public static void main(String[] args);", "public static void main(String[] args)")
}

if (langToConvertTo = "kt")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "fun main(args: Array<String>);", "fun main(args: Array<String>)")
}

if (langToConvertTo = "swift")
{
    htCode := htCode . "`n}`nmain()"
    htCode := StrReplace(htCode, "func main();", "func main()")
}

if (langToConvertTo = "dart")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "void main(List<String> arguments);", "void main(List<String> arguments)")
}

if (langToConvertTo = "scala")
{
    htCode := htCode . "`n    }`n}"

}


}

str jsHTMLdownCode := "</script>`n</body>`n</html>"

int includeLibsInCppIf := 0

str allFuncsToPutAtTop := "`n"
str allLibsToPutAtTop

if (!(allFuncNames.size() <= 0))
{
Loop, % allFuncNames.size()
{
if (InStr(htCode, allFuncNames[A_Index]) . "(")
{
;MsgBox, % allFuncNames[A_Index]

allFuncsToPutAtTop .= allFuncs[A_Index] . "`n"

if (Trim(allFuncLibs[A_Index]) != "null")
{
allLibsToPutAtTop .= allFuncLibs[A_Index] . "|"
}

}
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTop, 1

str allLibsToPutAtTopTEMP
Loop, Parse, allLibsToPutAtTop, "|"
{
allLibsToPutAtTopTEMP .= A_LoopField . "`n"
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTopTEMP, 1

includeLibsInCppIf := 1

if (langToConvertTo = "cpp")
{
allLibsToPutAtTop := "#include <iostream>`n#include <sstream>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n#include <any>`n#include <optional>`n" . allLibsToPutAtTop
}

if (langToConvertTo = "cs")
{
allLibsToPutAtTop := "using System;`n" . allLibsToPutAtTop
}

Sort, allLibsToPutAtTop, U

allLibsToPutAtTop := StrReplace(allLibsToPutAtTop, "~~~", "`n")


if (isNotHTVMfileEXTRA_INT = 1)
{
isNotHTVMfileEXTRA_LIB_INFO := allLibsToPutAtTop
isNotHTVMfileEXTRA_FUNCS_INFO := allFuncsToPutAtTop
}

if (isNotHTVMfile2 = 0)
{


if (langToConvertTo = "cs") or (langToConvertTo = "java") or (langToConvertTo = "scala")
{
    htCode := "`n" . allFuncsToPutAtTop . "`n" . htCode
}
else
{

    
    if (langToConvertTo != "js")
    {
    htCode := allLibsToPutAtTop . "`n" . allFuncsToPutAtTop . "`n" . htCode
    }
    else
    {
    if (useJavaScriptInAfullHTMLfile != "on")
    {
    htCode := allLibsToPutAtTop . "`n" . allFuncsToPutAtTop . "`n" . htCode
    }
    else
    {
    htCode := "`n" . allFuncsToPutAtTop . "`n" . htCode
    }
    }
    
    }

}





if (langToConvertTo = "cs")
{
    htCode := allLibsToPutAtTop . "`nclass Program`n{`n" . htCode
}
if (langToConvertTo = "java")
{
    htCode := allLibsToPutAtTop . "`npublic class Main`n{`n" . htCode
}

if (langToConvertTo = "scala")
{
    htCode := allLibsToPutAtTop . "`nobject MainApp`n{`n" . htCode
}

if (langToConvertTo = "go")
{
    htCode := "package main`nimport (`n" . htCode
}




}




















Loop, % theIdNumOfThe34
{
if (theIdNumOfThe34 = A_Index + 1)
{
if (langToConvertTo = langFileExtension_2)
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], "\", keyWordEscpaeChar_2) . Chr(34))
}
else
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1] . Chr(34))
}

}
else
{
if (langToConvertTo = langFileExtension_2)
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), StrReplace(theIdNumOfThe34theVar[A_Index + 1], "\", keyWordEscpaeChar_2))
}
else
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidForQQQasdsasQQQtheuhturtyphoutrQQQ" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1])
}


}
}


if (langToConvertTo = langFileExtension_2)
{
htCode := StrReplace(htCode, ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes, keyWordEscpaeChar_2 . Chr(34))
}
else
{
htCode := StrReplace(htCode, ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes, Chr(92) . Chr(34))
}

htCode := StrReplace(htCode, "std::string(" . Chr(34) . Chr(34) . ";),", "std::string(" . Chr(34) . Chr(34) . "),")








str jsHTMLupCode := "<!doctype html>`n<html lang=" . Chr(34) . "en" . Chr(34) . ">`n    <head>`n        <meta charset=" . Chr(34) . "UTF-8" . Chr(34) . " />`n        <meta name=" . Chr(34) . "viewport" . Chr(34) . " content=" . Chr(34) . "width=device-width, initial-scale=1.0" . Chr(34) . " />`n        <title>HTVM</title>`n        <style>`n            body {`n                background-color: #202020;`n                font-family:`n                    " . Chr(34) . "Open Sans" . Chr(34) . ",`n                    -apple-system,`n                    BlinkMacSystemFont,`n                    " . Chr(34) . "Segoe UI" . Chr(34) . ",`n                    Roboto,`n                    Oxygen-Sans,`n                    Ubuntu,`n                    Cantarell,`n                    " . Chr(34) . "Helvetica Neue" . Chr(34) . ",`n                    Helvetica,`n                    Arial,`n                    sans-serif;`n            }`n        </style>`n" . allLibsToPutAtTop . "`n</head>`n    <body>`n<script>"


if (isNotHTVMfile2 = 0)
{

if (useJavaScriptInAfullHTMLfile = "on") and (langToConvertTo = "js")
{
htCode := jsHTMLupCode . "`n" . htCode . "`n" . jsHTMLdownCode
}

if (langToConvertTo = "cpp") and (includeLibsInCppIf = 0)
{
htCode := "#include <iostream>`n#include <sstream>`n#include <any>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n`n" . htCode
}
if (langToConvertTo = "cs")
{
htCode := "`n" . htCode
}
if (langToConvertTo = "ahk")
{
htCode := "#EscapeChar \`n" . htCode
}




if (langToConvertTo = langFileExtension_2)
{
StringTrimLeft, htCode, htCode, 1
}

}


print(htCode)
return htCode
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func void HTVMv2()
{
global allArgs
str argCODE := ""
str argCODEfile := ""
str argHTVMinstr := ""
str argLangTo := ""
str OUTCODE := "null"
int numOfParams := 0
HTVM_v2_HTVM()

if (noParams = true)
{
return
}

Loop, Parse, str0
{
str00 := Trim(A_LoopField)
StringTrimRight, str00, str00, 1
}


print("HTVM v2")
if (HTVM_getLang_HTVM() = "cpp") or (HTVM_getLang_HTVM() = "py")
{

if (HTVM_getLang_HTVM() = "cpp")
{
print("CPP")
}
if (HTVM_getLang_HTVM() = "py")
{
print("PY")
}


Loop, Parse, allArgs, `n, `r
{
if (A_Index = 0)
{
numOfParams++
argCODE := FileRead(Trim(A_LoopField))
argCODEfile := Trim(A_LoopField)
}
else if (A_Index = 1)
{
numOfParams++
argHTVMinstr := Trim(A_LoopField)
}
else if (A_Index = 2)
{
numOfParams++
argLangTo := Trim(A_LoopField)
}
else
{
numOfParams++
argHTVMinstrMORE.add(Trim(A_LoopField))
}
}


print("===============123431234===========start=====")
Loop, % argHTVMinstrMORE.size()
{
print(argHTVMinstrMORE[A_Index])
}
print("===============123431234==========end======")

print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)

if (SubStrLastChars(argCODEfile, 4) = ".cpp") or (SubStrLastChars(argCODEfile, 3) = ".py") or (SubStrLastChars(argCODEfile, 3) = ".js") or (SubStrLastChars(argCODEfile, 3) = ".go") or (SubStrLastChars(argCODEfile, 4) = ".lua") or (SubStrLastChars(argCODEfile, 3) = ".cs") or (SubStrLastChars(argCODEfile, 5) = ".java") or (SubStrLastChars(argCODEfile, 3) = ".kt") or (SubStrLastChars(argCODEfile, 3) = ".rb") or (SubStrLastChars(argCODEfile, 4) = ".nim") or (SubStrLastChars(argCODEfile, 4) = ".ahk") or (SubStrLastChars(argCODEfile, 6) = ".swift") or (SubStrLastChars(argCODEfile, 5) = ".dart") or (SubStrLastChars(argCODEfile, 3) = ".ts") or (SubStrLastChars(argCODEfile, 6) = ".scala") or (SubStrLastChars(argCODEfile, 7) = ".groovy") or (SubStrLastChars(argCODEfile, StrLen("." . Trim(StrSplit(StrReplace(FileRead(argHTVMinstr), Chr(13), ""), "`n", 2)))) = "." . Trim(StrSplit(StrReplace(FileRead(argHTVMinstr), Chr(13), ""), "`n", 2))) and (numOfParams = 2)
{



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (SubStrLastChars(argCODEfile, 4) = ".cpp") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "cpp")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".py") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "py")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".js") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "js")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".go") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "go")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 4) = ".lua") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "lua")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".cs") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "cs")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 5) = ".java") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "java")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".kt") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "kt")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".rb") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "rb")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 4) = ".nim") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "nim")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 4) = ".ahk") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "ahk")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 6) = ".swift") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "swift")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 5) = ".dart") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "dart")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 3) = ".ts") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "ts")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 6) = ".scala") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "scala")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
} 
else if (SubStrLastChars(argCODEfile, 7) = ".groovy") {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", "groovy")
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
}
else if (SubStrLastChars(argCODEfile, StrLen("." . Trim(StrSplit(StrReplace(FileRead(argHTVMinstr), Chr(13), ""), "`n", 2)))) = "." . Trim(StrSplit(StrReplace(FileRead(argHTVMinstr), Chr(13), ""), "`n", 2))) {
    OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", Trim(StrSplit(StrReplace(FileRead(argHTVMinstr), Chr(13), ""), "`n", 2)))
    FileDelete(Trim(argCODEfile))
    FileAppend(OUTCODE, Trim(argCODEfile))
    return
}
else
{
print("INVALID LANG!!!")
return
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


}
else
{


if (argLangTo != "")
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "full", argLangTo)
}
else
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "full")
}
}   


print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)


if (langToConvertTo = "js") and (useJavaScriptInAfullHTMLfile = "on")
{
FileDelete(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . "html")
FileAppend(OUTCODE, StringTrimRight(argCODEfile, StrLen(langFileExtension)) . "html")
}
else
{
FileDelete(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
FileAppend(OUTCODE, StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
}


}

if (HTVM_getLang_HTVM() = "js")
{
print("JS")
}
}

main
HTVMv2()
