

str str0 := "nothing"
str str00 := "nothing"
str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""
str str10 := ""
str str11 := ""
str str12 := ""
str str13 := ""
str str14 := ""

int int0 := 0
int int1 := 0
int int2 := 0
int int3 := 0
int int4 := 0
int int5 := 0
int int6 := 0
int int7 := 0

arr str argHTVMinstrMOVE

str extraCodeReturned := ""

str langToConvertTo := ""
str langFileExtension := ""
str commands := ""
str keyWordAlliance := ""
str keyWordCrew := ""
str keyWordMethod := ""
str keyWordDefObj := ""
str keyWordPorp := ""
str keyWordThis := ""
str keyWordInclude := ""
str keyWordIncludeInTheTranspiledLang := ""
str keyWordCodeInTheTranspiledLangStart := ""
str keyWordCodeInTheTranspiledLangEnd := ""
str keyWordCodeInTheTranspiledLangStartCPP := ""
str keyWordCodeInTheTranspiledLangEndCPP := ""
str keyWordCodeInTheTranspiledLangStartPY := ""
str keyWordCodeInTheTranspiledLangEndPY := ""
str keyWordCodeInTheTranspiledLangStartJS := ""
str keyWordCodeInTheTranspiledLangEndJS := ""
str keyWordCodeInTheTranspiledLangStartGO := ""
str keyWordCodeInTheTranspiledLangEndGO := ""
str keyWordCodeInTheTranspiledLangStartLUA := ""
str keyWordCodeInTheTranspiledLangEndLUA := ""
str keyWordCodeInTheTranspiledLangStartCS := ""
str keyWordCodeInTheTranspiledLangEndCS := ""
str keyWordCodeInTheTranspiledLangStartJAVA := ""
str keyWordCodeInTheTranspiledLangEndJAVA := ""
str keyWordCodeInTheTranspiledLangStartKT := ""
str keyWordCodeInTheTranspiledLangEndKT := ""
str keyWordCodeInTheTranspiledLangStartRB := ""
str keyWordCodeInTheTranspiledLangEndRB := ""
str keyWordCodeInTheTranspiledLangStartNIM := ""
str keyWordCodeInTheTranspiledLangEndNIM := ""
str keyWordCodeInTheTranspiledLangStartAHK := ""
str keyWordCodeInTheTranspiledLangEndAHK := ""
str keyWordCodeInTheTranspiledLangStartSWIFT := ""
str keyWordCodeInTheTranspiledLangEndSWIFT := ""
str keyWordCodeInTheTranspiledLangStartDART := ""
str keyWordCodeInTheTranspiledLangEndDART := ""
str keyWordCodeInTheTranspiledLangStartTS := ""
str keyWordCodeInTheTranspiledLangEndTS := ""
str keyWordCodeInTheTranspiledLangStartSCALA := ""
str keyWordCodeInTheTranspiledLangEndSCALA := ""
str keyWordCodeInTheTranspiledLangStartGROOVY := ""
str keyWordCodeInTheTranspiledLangEndGROOVY := ""
str keyWordCodeInTheTranspiledLangStartHTVM := ""
str keyWordCodeInTheTranspiledLangEndHTVM := ""
str keyWordCodeInHTVMstart := ""
str keyWordCodeInHTVMend := ""
str keyWordCodeInOtherHTVMsyntaxStart := ""
str keyWordCodeInOtherHTVMsyntaxEnd := ""
str keyWordCurlyBraceOpen := ""
str keyWordCurlyBraceClose := ""
str keyWordNull := ""
str keyWordTrue := ""
str keyWordFalse := ""
str keyWordVoid := ""
str keyWordDouble := ""
str keyWordChar := ""
str keyWordUint8 := ""
str keyWordUint16 := ""
str keyWordUint32 := ""
str keyWordUint64 := ""
str keyWordINT := ""
str keyWordSTR := ""
str keyWordBOOL := ""
str keyWordFLOAT := ""
str keyWordINT8 := ""
str keyWordINT16 := ""
str keyWordINT32 := ""
str keyWordINT64 := ""
str keyWordIF := ""
str keyWordElseIf := ""
str keyWordElse := ""
str keyWordSwitch := ""
str keyWordSwitchCase := ""
str keyWordSwitchDefault := ""
str keyWordWhileLoop := ""
str keyWordForLoop := ""
str keyWordLoopInfinite := ""
str keyWordLoop := ""
str keyWordLoopParse := ""
str keyWordContinue := ""
str keyWordBreak := ""
str keyWordFunc := ""
str keyWordAwait := ""
str keyWordAsync := ""
str keyWordThrow := ""
str keyWordErrorMsg := ""
str keyWordTry := ""
str keyWordCatch := ""
str keyWordFinally := ""
str keyWordReturnStatement := ""
str keyWordArrayAppend := ""
str keyWordArrayPop := ""
str keyWordArraySize := ""
str keyWordArrayInsert := ""
str keyWordArrayRemove := ""
str keyWordArrayIndexOf := ""
str keyWordArrayDefinition := ""
str keyWordArrayOfIntegersDefinition := ""
str keyWordArrayOfStringsDefinition := ""
str keyWordArrayOfFloatingPointNumbersDefinition := ""
str keyWordArrayOfBooleansDefinition := ""
str keyWordVar := ""
str keyWordLet := ""
str keyWordConst := ""
str keyWordEnd := ""
str keyWordGlobal := ""
str keyWordComment := ""
str keyWordCommentOpenMultiLine := ""
str keyWordCommentCloseMultiLine := ""
str keyWordEscpaeChar := ""
str keyWordMainLabel := ""
str keyWordConcat := ""
str keyWordAdd := ""
str keyWordSub := ""
str keyWordMul := ""
str keyWordDiv := ""
str keyWordMod := ""
str keyWordExp := ""
str keyWordEqual := ""
str keyWordStrictEqual := ""
str keyWordNotEqual := ""
str keyWordGreater := ""
str keyWordLess := ""
str keyWordGreaterEqual := ""
str keyWordLessEqual := ""
str keyWordAnd := ""
str keyWordOr := ""
str keyWordNot := ""
str keyWordBitAnd := ""
str keyWordBitOr := ""
str keyWordBitXor := ""
str keyWordBitNot := ""
str keyWordShiftLeft := ""
str keyWordShiftRight := ""
str keyWordShiftUnsignedRight := ""
str keyWordAssign := ""
str keyWordAssignAdd := ""
str keyWordAssignConcat := ""
str keyWordAssignSub := ""
str keyWordAssignMul := ""
str keyWordAssignDiv := ""
str keyWordAssignMod := ""
str keyWordAssignShiftLeft := ""
str keyWordAssignShiftRight := ""
str keyWordLogicalAssignShiftRight := ""
str keyWordAssignBitAnd := ""
str keyWordAssignBitOr := ""
str keyWordAssignBitXor := ""
str keyWordTernary1 := ""
str keyWordTernary2 := ""
str keyWordInc := ""
str keyWordDec := ""
str AHKlikeLoopsIndexedAt := ""
str keyWordAIndex := ""
str keyWordALoopField := ""
str keyWordAllianceEndExtraInfo := ""
str keyWordCrewEndExtraInfo := ""
str keyWordMethodEndExtraInfo := ""
str keyWordDefObjEndExtraInfo := ""
str keyWordIFEndExtraInfo := ""
str keyWordElseIfEndExtraInfo := ""
str keyWordElseEndExtraInfo := ""
str keyWordSwitchEndExtraInfo := ""
str keyWordSwitchCaseEndExtraInfo := ""
str keyWordSwitchDefaultEndExtraInfo := ""
str keyWordWhileLoopEndExtraInfo := ""
str keyWordForLoopEndExtraInfo := ""
str keyWordLoopInfiniteEndExtraInfo := ""
str keyWordLoopEndExtraInfo := ""
str keyWordLoopParseEndExtraInfo := ""
str keyWordFuncEndExtraInfo := ""
str keyWordTryEndExtraInfo := ""
str keyWordCatchEndExtraInfo := ""
str keyWordFinallyEndExtraInfo := ""
str useFuncKeyWord := ""
str useCurlyBraces := ""
str useEnd := ""
str useEndExtraInfo := ""
str useSemicolon := ""
str theSemicolon := ""
str theColon := ""
str useParentheses := ""
str usePrefixTypeForTypeDefinition := ""
str usePostfixTypeForTypeDefinition := ""
str usePythonicColonSyntax := ""
str useCurlyBracesSyntaxForArrayDef := "" 
str useInJavaScriptAlwaysUseVar := ""
str useJavaScriptInAfullHTMLfile := ""
str useJavaScriptAmainFuncDef := ""
str useJavaScriptAllFuncsAreAsync := ""
str useJavaScriptAlwaysTripleEqual := ""


str out_KeyWordsCommands := ""
str outTrimCode := ""
str htCode := ""

str outVarOperator := ""
int lineDone := 0
int areWeInAFuncFromInstructions := 0
int areWeInAFuncFromInstructionsLineNum := 0

str theCppVarForErrors := "jhku-dfsds-ds-d-ffdsf-sdfsfdsedsf"
str theJSvarDeclaredVarsBugFix := "|"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



func str KeyWordsCommands(str theCodeCommands, str mode, str keyWordsCommands, str langToConvertTo)
{
theCodeCommands := StrReplace(theCodeCommands, "%", "")
if (mode = "check")
{
Loop, Parse, keyWordsCommands, "|"
{
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{

if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
return "true"
}
}

if (A_Index = 1)
{
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
return "true"
}
}


}

}
;MsgBox, false
return "false"
}

int AIndex := 0
if (mode = "transpile")
{

int keyWordsCommandsNumLine := 1
Loop, Parse, keyWordsCommands, "|"
{
AIndex := A_Index
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{
if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}

if (A_Index = 1)
{
;MsgBox, %theCodeCommands% = %A_LoopField%
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}


}

}





str outConstuctTheOutFromTheCommands := ""
str outConstuctTheOutFromTheCommandsFucnName := ""
str outConstuctTheOutFromTheCommandsParams := ""
str outConstuctTheOutFromTheCommandsOutVar := ""
str outConstuctTheOutFromTheCommandsInVar := ""
int theCodeCommandNum := 1
int outConstuctTheOutFromTheCommandsLineTranspile := 0
str outConstuctTheOutFromTheCommandsLineTranspileText := ""

str semicolon := ""
if (langToConvertTo != "py")
{
semicolon := ";"
}

arr str theCodeCommand
theCodeCommands := Trim(theCodeCommands)
Loop, Parse, theCodeCommands, `,
{
theCodeCommand.add(Trim(A_LoopField))
;MsgBox, % A_LoopField
}


Loop, Parse, keyWordsCommands, "|"
{



if (keyWordsCommandsNumLine = A_Index)
{

;MsgBox, % A_LoopField

Loop, Parse, A_LoopField, `,
{




if (A_Index = 1)
{
outConstuctTheOutFromTheCommandsFucnName := A_LoopField
}
else if (A_Index = 2)
{

;MsgBox, % A_LoopField
if (A_LoopField = "lineTranspile")
{
outConstuctTheOutFromTheCommandsLineTranspile := 1
}

if (A_LoopField = "OUTVAR")
{
outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INOUTVAR")
{

outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}

}



}
else if (A_Index = 3)
{

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommandsLineTranspileText := A_LoopField
}


if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}

}
else
{

;MsgBox, % theCodeCommand[theCodeCommandNum]
if (InStr(A_LoopField, Chr(39)))
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}

}
else
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}
}
theCodeCommandNum++
}
break
}

}

StringTrimRight, outConstuctTheOutFromTheCommandsParams, outConstuctTheOutFromTheCommandsParams, 2

if (outConstuctTheOutFromTheCommandsOutVar != "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}

}

if (outConstuctTheOutFromTheCommandsOutVar = "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}
}

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsLineTranspileText
}


outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(, ", "( ")
outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(,", "(")
return outConstuctTheOutFromTheCommands





}

return "false"
}


func str HTVMmatchStrRrplace(str line, str matchString, str replaceString) {
    str lineOut := ""
    if (!InStr(line, matchString)) {
        return line
    }
    str allDelimiters := " ()[].,;:'!&|=<>+-*/^%~" . Chr(34)
    arr str lineArr
    Loop, Parse, line {
        lineArr.add(A_LoopField)
    }
    int matchStringLEN := StrLen(matchString)
    int replaceStringLEN := StrLen(replaceString)
    arr int allPosForReplacing
    str sildingLine := ""
    int isStart := 1
    int i1 := 0
    int hasFound := 0
    int hasFound2 := 0
    int isStartTrue := 0
    int isEndTrue := 0
    ; char1 is for text outside the start
    str char1 := ""
    ; char2 is for text inside the start
    str char2 := ""
    ; char3 is for text inside the end
    str char3 := ""
    ; char4 is for text outside the end
    str char4 := ""
    int isMatch := 0
    sildingLine := ""
    isStart := 1
    i1 := 0
    hasFound := 0
    hasFound2 := 0
    isStartTrue := 0
    isEndTrue := 0
    Loop, % lineArr.size() {
        char1 := ""
        char2 := ""
        char3 := ""
        char4 := ""
        isMatch := 0
        if (A_Index != 0) {
            isStart := 0
        }
        sildingLine := ""
        Loop, % matchStringLEN {
            if (A_Index + i1 <= lineArr.size() - 1) {
                sildingLine .= lineArr[A_Index + i1]
            }
        }
        if (StrLen(sildingLine) < matchStringLEN) {
            break
        }
        ;print("!!!!111111111!!!!!!: " . sildingLine)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;==================
        if (sildingLine = matchString) {
            hasFound := 1
            if (isStart != 1) {
                ;print("!!!!2222222222!!!!!!: " . lineArr[i1 - 1])
                char1 := lineArr[i1 - 1]
                ;print("!!!!2222222222.555555555!!!!!!: " . lineArr[i1])
                char2 := lineArr[i1]
            } else {
                isStartTrue := 1
            }
            if (i1 + matchStringLEN < lineArr.size()) {
                ;print("!!!!3333333333.5555555555!!!!!!: " . lineArr[i1 + matchStringLEN - 1])
                char3 := lineArr[i1 + matchStringLEN - 1]
                ;print("!!!!3333333333!!!!!!: " . lineArr[i1 + matchStringLEN])
                char4 := lineArr[i1 + matchStringLEN]
            } else {
                isEndTrue := 1
            }
            if (InStr(allDelimiters, char1)) or (InStr(allDelimiters, char2)) {
                isStartTrue := 1
            }
            if (InStr(allDelimiters, char3)) or (InStr(allDelimiters, char4)) {
                isEndTrue := 1
            }
            if (isStartTrue = 1) and (isEndTrue = 1) {
                isMatch := 1
            }
        }
        ;;;;;;;;;;;;;;;;;;;;===============
        if (isMatch = 1) {
            if (allPosForReplacing.size() > 0) {
                Loop, % allPosForReplacing.size() {
                    if (i1 + 1 != allPosForReplacing[A_Index]) {
                        allPosForReplacing.add(i1 + 1)
                        break
                    }
                }
            } else {
                allPosForReplacing.add(i1 + 1)
            }
        }
        i1++
    }
    str lineTEMP := ""
    lineOut := line
    ;print(allPosForReplacing)
    if (allPosForReplacing.size() > 0) {
        ; matchStringLEN
        ; replaceStringLEN
        int l2 := 0
        int currentPos := 0
        int onceEnd := 0
        Loop, % allPosForReplacing.size() {
            if (A_Index = 0) {
                currentPos := allPosForReplacing[A_Index]
            } else {
                currentPos := allPosForReplacing[A_Index] - (matchStringLEN - replaceStringLEN)
            }
            onceEnd := 0
            Loop, Parse, lineOut {
                if (A_Index + 2 > currentPos) and (A_Index + 1 < currentPos + matchStringLEN) {
                    onceEnd++
                    ;print("DDDDDDDDDDD" . STR(A_Index))
                    if (onceEnd = 1) {
                        lineTEMP .= replaceString
                    }
                } else {
                    lineTEMP .= A_LoopField
                }
            }
            lineOut := lineTEMP
            lineTEMP := ""
            ;print(lineTEMP)
            l2++
        }
    } else {
        return line
    }
    return lineOut
}

func str SubStrLastChars(str text, int numOfChars) {
    str LastOut := ""
    int NumOfChars := 0
    Loop, Parse, text {
        NumOfChars++
    }
    Loop, % numOfChars {
        NumOfChars--
    }
    Loop, Parse, text {
        if (A_Index >= NumOfChars) {
            LastOut .= A_LoopField
        }
    }
    return LastOut
}


func str ExtractDigits(str inputString)
{
str digits := ""

Loop, Parse, inputString
{
    if (RegExMatch(A_LoopField, "\d"))
    {
        digits .= A_LoopField
    }
}
return digits
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Helper function to create spaces
func str spaces(int n)
{
str s := ""
if (n != 0)
{
Loop, % n
{
s .= " "
}
}
return s
}


; Define the function to check odd spaces at the beginning
func str CheckOddLeadingSpaces(str string123)
{
; Initialize a variable to count the spaces
int spaceCount := 0

; Loop through the string one character at a time
Loop, Parse, string123
{
; Check if the current character is a space
if (A_LoopField = Chr(32))
{
spaceCount++
}
else
{
; When we hit a non-space character, break the loop
break
}
}

; Return true if the number of spaces is odd, false otherwise
str sdsfawasd := STR(Mod(spaceCount, 2) = 1)
;MsgBox, % sdsfawasd
return sdsfawasd
}

func str LTrim(str input)
{
    str result := ""
    bool foundNonSpace := false

    Loop, Parse, input
    {
        if (A_LoopField != " " or foundNonSpace)
        {
            result .= A_LoopField
            foundNonSpace := true
        }
    }

    return result
}


func str getLastChar(str strippedString)
{
str lastChar
Loop, Parse, strippedString
{
lastChar := A_LoopField
}
return lastChar
}

func str AddCurlyBraces(str pythonCode)
{
pythonCode := StrReplace(pythonCode, Chr(9), "    ")
str result := ""
int indentLevel := 0
int indent := 0
str line := 0
str stripped := 0
Loop, Parse, pythonCode, `n, `r
{
line := A_LoopField
stripped := Trim(line)
if (stripped = "")
{
result .= line . "`n"
continue
}

; Count leading spaces
indent := StrLen(line) - StrLen(LTrim(line))
;MsgBox, % indent
; Close braces for unindents

Loop
{
if (indentLevel <= indent)
{
	break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


; Add opening brace for new blocks
if (getLastChar(stripped) = ":") and (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordComment))) != StrLower(keyWordComment))
{
result .= SubStr(line, 1, -1) . " {`n"
indentLevel += 4
}
else
{
result .= line . "`n"
}
}

; Close any remaining open braces
Loop
{
if (indentLevel <= 0)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


return result
}


func str RepeatSpaces(int count)
{
str spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}


func str indent_nested_curly_braces(str input_string, int modeCurlyBracesOn)
{
int indent_size := 4
int current_indent := 0
str result := ""
str trimmed_line := ""
str resultOut := ""
;MsgBox, % input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}
else
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}

}


if (modeCurlyBracesOn = 0)
{
str resultOut := ""
Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) != "{") and (Trim(A_LoopField) != "}")
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}
else
{
; format curly braces in a K&R style

arr str lookIntoFurture

Loop, Parse, result, `n, `r
{
lookIntoFurture.add(Trim(A_LoopField))
}
lookIntoFurture.add(" ")

str resultOut := ""
int skipNext := 0
Loop, Parse, result, `n, `r
{


skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(lookIntoFurture[A_Index + 1]) = "{")
{
resultOut .= A_LoopField . " {`n"
skipNext := 2
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}


}
StringTrimRight, result, resultOut, 1

arr str lookIntoFurture2

Loop, Parse, result, `n, `r
{
lookIntoFurture2.add(Trim(A_LoopField))
}
lookIntoFurture2.add(" ")


resultOut := ""
skipNext := 0
str addSpacesAtTheBegginig
Loop, Parse, result, `n, `r
{
skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(A_LoopField) = "}") and (Trim(lookIntoFurture2[A_Index + 1]) = "else {")
{
skipNext := 2
addSpacesAtTheBegginig := ""
Loop, Parse, A_LoopField
{
if (A_LoopField = " ")
{
if (A_LoopField != " ")
{
break
}
addSpacesAtTheBegginig .= A_LoopField
}
}
resultOut .= addSpacesAtTheBegginig . "} else {`n"
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}


resultOut := ""
str ALoopField
Loop, Parse, result, `n, `r
{
if (CheckOddLeadingSpaces(A_LoopField) = "1")
{
StringTrimLeft, ALoopField, A_LoopField, 1
resultOut .= ALoopField . "`n"
}
else
{
resultOut .= A_LoopField . "`n"
}
}

StringTrimRight, result, resultOut, 1


; Return the result
return result
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]
str OSPstrArrayStrALLobjInOSP := ""
str HoldOSPdethodNamePath := ""

func str findTypeOfOSPprop(str fullARRAYstr, str FromPath)
{
str outType := ""
; if the fullARRAYstr is in this format
; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]

str outFormat := ""
str outFormatHELP1 := ""
str outFormatHELP2 := ""


Loop, Parse, fullARRAYstr, "|"
{
if (Trim(A_LoopField) != "")
{
outFormatHELP1 := StrSplit(A_LoopField, ":", 1)
outFormatHELP2 := StrSplit(A_LoopField, ":", 2)
Loop, Parse, outFormatHELP2, `,
{
outFormat .= outFormatHELP1 . "." . A_LoopField . "|"
}
}
}
StringTrimRight, outFormat, outFormat, 1


Loop, Parse, outFormat, "|"
{
if (Trim(A_LoopField) != "")
{
if (StrSplit(Trim(A_LoopField), "[", 1) = Trim(FromPath))
{
outType := StrSplit(Trim(A_LoopField), "[", 2)
StringTrimRight, outType, outType, 1
break
}

}
}




if (outType = "vector<int>")
{
outType := "std::vector<int>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<float>")
{
outType := "std::vector<float>&"
}
else if (outType = "vector<bool>")
{
outType := "std::vector<bool>&"
}
else if (outType = Trim(keyWordINT))
{
outType := "int"
}
else if (outType = Trim(keyWordSTR))
{
outType := "std::string"
}
else if (outType = Trim(keyWordFLOAT))
{
outType := "float"
}
else if (outType = Trim(keyWordBOOL))
{
outType := "bool"
}
else if (outType = Trim(keyWordINT8))
{
outType := "int8_t"
}
else if (outType = Trim(keyWordINT16))
{
outType := "int16_t"
}
else if (outType = Trim(keyWordINT32))
{
outType := "int32_t"
}
else if (outType = Trim(keyWordINT64))
{
outType := "int64_t"
}


return outType
}


func str REMOVELastSTRfromDOT(str THESTR)
{
str THESTRout := ""
if (Trim(THESTR) = "")
{
return ""
}
int count12345 := 0

Loop, Parse, THESTR, "."
{
count12345++
}


Loop, Parse, THESTR, "."
{
if (count12345 = A_Index)
{
break
}
else
{
THESTRout .= Trim(A_LoopField) . "."
}
}

StringTrimRight, THESTRout, THESTRout, 1

return THESTRout
}


;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsPY_JS(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "this__OSP__this[0]")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsLEFT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}

func str replaceTheOSPpathsRIGHT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
type := findTypeOfOSPprop(OSPstrArrayStrALLobjInOSP, ALoopField)
;MsgBox, % type

theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "std::any_cast<" . type . ">(OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_") . ")")

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


func str CheckStringPosition(str text, str target, str reference)
{

    str posReference := SubStr(text, 1, StrLen(reference))
    str posTarget := SubStr(text, 1, StrLen(target))

    ; Check if both strings are found (not using InStr)
    if (posReference != "" and posTarget != "")
    {
        ; Manually find the positions of the target and reference
        posTarget := RegExMatch(text, target)
        posReference := RegExMatch(text, reference)

        ; Compare positions of target and reference
        if (posTarget < posReference)
        {

            return "left"
        }
        else if (posTarget > posReference)
        {

return "not left"
        }
        else
        {

return "uuh"
        }
    }
    else
    {

        return "One or both strings not found."
    }

return "huh"
}


func str getIndexOfTheStrArrayStrOST(str ALoopField, str theSringOSPlineARRAYstrstrSTR)
{



Loop, Parse, theSringOSPlineARRAYstrstrSTR, "|"
{
if (Trim(StrSplit(A_LoopField, ":", 1)) = Trim(ALoopField))
{

return STR(A_Index)
}
}



return "0"
}



func str parserOSPgloabl(str theSringOSPline, str str123)
{
str str_1 := ""
str str_2 := ""
str str_3 := ""
str str_4 := ""
str str_5 := ""
str str_6 := ""

str HELPHoldOSPdethodNamePath := ""

StringTrimRight, HELPHoldOSPdethodNamePath, HoldOSPdethodNamePath, 1




Loop, Parse, theSringOSPline, "|"
{
str_1 .= Trim(StrSplit(A_LoopField, ":", 1)) . "`n"
str_5 := Trim(StrSplit(A_LoopField, ":", 1))
str_6 := Trim(StrSplit(A_LoopField, ":", 2))
Loop, Parse, str_6, `,
{
str_1 .= str_5 . "." . Trim(StrSplit(A_LoopField, "[", 1)) . "[" . STR(A_Index) . "]`n"
}

}

str_1 .= StrReplace(HELPHoldOSPdethodNamePath, "|", "`n")



str shortestLine := ""
str currentLine := ""
int currentLength := 0
int minLength := 0
str tempStr := ""

; Sorting by repeatedly finding and appending the shortest line
Loop
{
    ; Initialize variables to track the shortest line in this pass
    shortestLine := ""
    minLength := 999999

    ; Find the shortest line in str_1
    Loop, Parse, str_1, `n, `r
    {
        currentLine := A_LoopField
        currentLength := StrLen(currentLine)
        if (currentLength < minLength)
        {
            minLength := currentLength
            shortestLine := currentLine
        }
    }

    ; If no shortest line is found, break (str_1 is empty)
    if (shortestLine = "")
	{
        break
	}

    ; Add the shortest line to the sorted result
    str_2 .= shortestLine . "`n"

    ; Rebuild str_1 without the shortest line
    tempStr := ""
    Loop, Parse, str_1, `n, `r
    {
        if (A_LoopField != shortestLine)
		{
            tempStr .= A_LoopField . "`n"
		}

    }
    StringTrimRight, tempStr, tempStr, 1
    str_1 := tempStr
}

; Trim the final trailing newline from str_2
StringTrimRight, str_2, str_2, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Initialize an empty result for the reversed lines
str reversedStr := ""

; Count the number of lines
int lineCount := 0
int index := 0
int lineNum := 0

Loop, Parse, str_2, `n, `r
{
    lineCount++
}

; Reverse the order by re-parsing and appending lines in reverse order
Loop, % lineCount
{
    ; Inner loop to find the (lineCount - A_Index + 1)-th line
    index := lineCount - A_Index + 1
    currentLine := ""
    lineNum := 0

    Loop, Parse, str_2, `n, `r
    {
        lineNum++
        if (lineNum = index)
        {
            currentLine := A_LoopField
            break
        }
    }

    ; Append the line in reverse order
    reversedStr .= currentLine . "`n"
}

; Trim the final trailing newline
StringTrimRight, str_2, reversedStr, 1


; Display the sorted result
;MsgBox, % str_2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;CheckStringPosition(text, target, reference)
str ALoopField := ""
str ALoopField1 := ""

Loop, Parse, str_2, `n, `r
{

if (SubStr(A_LoopField, 1, StrLen(keyWordFunc)) != keyWordFunc)
{

if (langToConvertTo = "cpp")
{

if (Trim(A_LoopField) != "")
{


if (InStr(str123, " += "))
{
str6 := " += "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " = "))
{

str6 := " = "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " -= "))
{
str6 := " -= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " *= "))
{
str6 := " *= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " /= "))
{

str6 := " /= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else
{

str123 := replaceTheOSPpathsRIGHT(str123, A_LoopField)

}


;;;;;
}
}
else
{
if (Trim(A_LoopField) != "")
{
str123 := replaceTheOSPpathsPY_JS(str123, A_LoopField)
}
}



}
}



return str123
}



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str compiler(str htCode, str instructionFile, str mode, str langToConvertToParam := "")
{
extraCodeReturned := ""

str allInstructionFile := Trim(FileRead(instructionFile))

Loop, Parse, allInstructionFile, `n, `r
{
	if (A_Index = 0) {
		langToConvertTo := Trim(A_LoopField)
	}
	if (A_Index = 1) {
		langFileExtension := Trim(A_LoopField)
	}
	if (A_Index = 2) {
		commands := Trim(A_LoopField)
	}
	if (A_Index = 3) {
		keyWordAlliance := Trim(A_LoopField)
	}
	if (A_Index = 4) {
		keyWordCrew := Trim(A_LoopField)
	}
	if (A_Index = 5) {
		keyWordMethod := Trim(A_LoopField)
	}
	if (A_Index = 6) {
		keyWordDefObj := Trim(A_LoopField)
	}
	if (A_Index = 7) {
		keyWordPorp := Trim(A_LoopField)
	}
	if (A_Index = 8) {
		keyWordThis := Trim(A_LoopField)
	}
	if (A_Index = 9) {
		keyWordInclude := Trim(A_LoopField)
	}
	if (A_Index = 10) {
		keyWordIncludeInTheTranspiledLang := Trim(A_LoopField)
	}
	if (A_Index = 11) {
		keyWordCodeInTheTranspiledLangStart := Trim(A_LoopField)
	}
	if (A_Index = 12) {
		keyWordCodeInTheTranspiledLangEnd := Trim(A_LoopField)
	}
	if (A_Index = 13) {
		keyWordCodeInTheTranspiledLangStartCPP := Trim(A_LoopField)
	}
	if (A_Index = 14) {
		keyWordCodeInTheTranspiledLangEndCPP := Trim(A_LoopField)
	}
	if (A_Index = 15) {
		keyWordCodeInTheTranspiledLangStartPY := Trim(A_LoopField)
	}
	if (A_Index = 16) {
		keyWordCodeInTheTranspiledLangEndPY := Trim(A_LoopField)
	}
	if (A_Index = 17) {
		keyWordCodeInTheTranspiledLangStartJS := Trim(A_LoopField)
	}
	if (A_Index = 18) {
		keyWordCodeInTheTranspiledLangEndJS := Trim(A_LoopField)
	}
	if (A_Index = 19) {
		keyWordCodeInTheTranspiledLangStartGO := Trim(A_LoopField)
	}
	if (A_Index = 20) {
		keyWordCodeInTheTranspiledLangEndGO := Trim(A_LoopField)
	}
	if (A_Index = 21) {
		keyWordCodeInTheTranspiledLangStartLUA := Trim(A_LoopField)
	}
	if (A_Index = 22) {
		keyWordCodeInTheTranspiledLangEndLUA := Trim(A_LoopField)
	}
	if (A_Index = 23) {
		keyWordCodeInTheTranspiledLangStartCS := Trim(A_LoopField)
	}
	if (A_Index = 24) {
		keyWordCodeInTheTranspiledLangEndCS := Trim(A_LoopField)
	}
	if (A_Index = 25) {
		keyWordCodeInTheTranspiledLangStartJAVA := Trim(A_LoopField)
	}
	if (A_Index = 26) {
		keyWordCodeInTheTranspiledLangEndJAVA := Trim(A_LoopField)
	}
	if (A_Index = 27) {
		keyWordCodeInTheTranspiledLangStartKT := Trim(A_LoopField)
	}
	if (A_Index = 28) {
		keyWordCodeInTheTranspiledLangEndKT := Trim(A_LoopField)
	}
	if (A_Index = 29) {
		keyWordCodeInTheTranspiledLangStartRB := Trim(A_LoopField)
	}
	if (A_Index = 30) {
		keyWordCodeInTheTranspiledLangEndRB := Trim(A_LoopField)
	}
	if (A_Index = 31) {
		keyWordCodeInTheTranspiledLangStartNIM := Trim(A_LoopField)
	}
	if (A_Index = 32) {
		keyWordCodeInTheTranspiledLangEndNIM := Trim(A_LoopField)
	}
	if (A_Index = 33) {
		keyWordCodeInTheTranspiledLangStartAHK := Trim(A_LoopField)
	}
	if (A_Index = 34) {
		keyWordCodeInTheTranspiledLangEndAHK := Trim(A_LoopField)
	}
	if (A_Index = 35) {
		keyWordCodeInTheTranspiledLangStartSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 36) {
		keyWordCodeInTheTranspiledLangEndSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 37) {
		keyWordCodeInTheTranspiledLangStartDART := Trim(A_LoopField)
	}
	if (A_Index = 38) {
		keyWordCodeInTheTranspiledLangEndDART := Trim(A_LoopField)
	}
	if (A_Index = 39) {
		keyWordCodeInTheTranspiledLangStartTS := Trim(A_LoopField)
	}
	if (A_Index = 40) {
		keyWordCodeInTheTranspiledLangEndTS := Trim(A_LoopField)
	}
	if (A_Index = 41) {
		keyWordCodeInTheTranspiledLangStartSCALA := Trim(A_LoopField)
	}
	if (A_Index = 42) {
		keyWordCodeInTheTranspiledLangEndSCALA := Trim(A_LoopField)
	}
	if (A_Index = 43) {
		keyWordCodeInTheTranspiledLangStartGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 44) {
		keyWordCodeInTheTranspiledLangEndGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 45) {
		keyWordCodeInTheTranspiledLangStartHTVM := Trim(A_LoopField)
	}
	if (A_Index = 46) {
		keyWordCodeInTheTranspiledLangEndHTVM := Trim(A_LoopField)
	}
	if (A_Index = 47) {
		keyWordCodeInHTVMstart := Trim(A_LoopField)
	}
	if (A_Index = 48) {
		keyWordCodeInHTVMend := Trim(A_LoopField)
	}
	if (A_Index = 49) {
		keyWordCodeInOtherHTVMsyntaxStart := Trim(A_LoopField)
	}
	if (A_Index = 50) {
		keyWordCodeInOtherHTVMsyntaxStart := Trim(A_LoopField)
	}
	if (A_Index = 51) {
		keyWordCurlyBraceOpen := Trim(A_LoopField)
	}
	if (A_Index = 52) {
		keyWordCurlyBraceClose := Trim(A_LoopField)
	}
	if (A_Index = 53) {
		keyWordNull := Trim(A_LoopField)
	}
	if (A_Index = 54) {
		keyWordTrue := Trim(A_LoopField)
	}
	if (A_Index = 55) {
		keyWordFalse := Trim(A_LoopField)
	}
	if (A_Index = 56) {
		keyWordVoid := Trim(A_LoopField)
	}
	if (A_Index = 57) {
		keyWordDouble := Trim(A_LoopField)
	}
	if (A_Index = 58) {
		keyWordChar := Trim(A_LoopField)
	}
	if (A_Index = 59) {
		keyWordUint8 := Trim(A_LoopField)
	}
	if (A_Index = 60) {
		keyWordUint16 := Trim(A_LoopField)
	}
	if (A_Index = 61) {
		keyWordUint32 := Trim(A_LoopField)
	}
	if (A_Index = 62) {
		keyWordUint64 := Trim(A_LoopField)
	}
	if (A_Index = 63) {
		keyWordINT := Trim(A_LoopField)
	}
	if (A_Index = 64) {
		keyWordSTR := Trim(A_LoopField)
	}
	if (A_Index = 65) {
		keyWordBOOL := Trim(A_LoopField)
	}
	if (A_Index = 66) {
		keyWordFLOAT := Trim(A_LoopField)
	}
	if (A_Index = 67) {
		keyWordINT8 := Trim(A_LoopField)
	}
	if (A_Index = 68) {
		keyWordINT16 := Trim(A_LoopField)
	}
	if (A_Index = 69) {
		keyWordINT32 := Trim(A_LoopField)
	}
	if (A_Index = 70) {
		keyWordINT64 := Trim(A_LoopField)
	}
	if (A_Index = 71) {
		keyWordIF := Trim(A_LoopField)
	}
	if (A_Index = 72) {
		keyWordElseIf := Trim(A_LoopField)
	}
	if (A_Index = 73) {
		keyWordElse := Trim(A_LoopField)
	}
	if (A_Index = 74) {
		keyWordSwitch := Trim(A_LoopField)
	}
	if (A_Index = 75) {
		keyWordSwitchCase := Trim(A_LoopField)
	}
	if (A_Index = 76) {
		keyWordSwitchDefault := Trim(A_LoopField)
	}
	if (A_Index = 77) {
		keyWordWhileLoop := Trim(A_LoopField)
	}
	if (A_Index = 78) {
		keyWordForLoop := Trim(A_LoopField)
	}
	if (A_Index = 79) {
		keyWordLoopInfinite := Trim(A_LoopField)
	}
	if (A_Index = 80) {
		keyWordLoop := Trim(A_LoopField)
	}
	if (A_Index = 81) {
		keyWordLoopParse := Trim(A_LoopField)
	}
	if (A_Index = 82) {
		keyWordContinue := Trim(A_LoopField)
	}
	if (A_Index = 83) {
		keyWordBreak := Trim(A_LoopField)
	}
	if (A_Index = 84) {
		keyWordFunc := Trim(A_LoopField)
	}
	if (A_Index = 85) {
		keyWordAwait := Trim(A_LoopField)
	}
	if (A_Index = 86) {
		keyWordAsync := Trim(A_LoopField)
	}
	if (A_Index = 87) {
		keyWordThrow := Trim(A_LoopField)
	}
	if (A_Index = 88) {
		keyWordErrorMsg := Trim(A_LoopField)
	}
	if (A_Index = 89) {
		keyWordTry := Trim(A_LoopField)
	}
	if (A_Index = 90) {
		keyWordCatch := Trim(A_LoopField)
	}
	if (A_Index = 91) {
		keyWordFinally := Trim(A_LoopField)
	}
	if (A_Index = 92) {
		keyWordReturnStatement := Trim(A_LoopField)
	}
	if (A_Index = 93) {
		keyWordArrayAppend := Trim(A_LoopField)
	}
	if (A_Index = 94) {
		keyWordArrayPop := Trim(A_LoopField)
	}
	if (A_Index = 95) {
		keyWordArraySize := Trim(A_LoopField)
	}
	if (A_Index = 96) {
		keyWordArrayInsert := Trim(A_LoopField)
	}
	if (A_Index = 97) {
		keyWordArrayRemove := Trim(A_LoopField)
	}
	if (A_Index = 98) {
		keyWordArrayIndexOf := Trim(A_LoopField)
	}
	if (A_Index = 99) {
		keyWordArrayDefinition := Trim(A_LoopField)
	}
	if (A_Index = 100) {
		keyWordArrayOfIntegersDefinition := Trim(A_LoopField)
	}
	if (A_Index = 101) {
		keyWordArrayOfStringsDefinition := Trim(A_LoopField)
	}
	if (A_Index = 102) {
		keyWordArrayOfFloatingPointNumbersDefinition := Trim(A_LoopField)
	}
	if (A_Index = 103) {
		keyWordArrayOfBooleansDefinition := Trim(A_LoopField)
	}
	if (A_Index = 104) {
		keyWordVar := Trim(A_LoopField)
	}
	if (A_Index = 105) {
		keyWordLet := Trim(A_LoopField)
	}
	if (A_Index = 106) {
		keyWordConst := Trim(A_LoopField)
	}
	if (A_Index = 107) {
		keyWordEnd := Trim(A_LoopField)
	}
	if (A_Index = 108) {
		keyWordGlobal := Trim(A_LoopField)
	}
	if (A_Index = 109) {
		keyWordComment := Trim(A_LoopField)
	}
	if (A_Index = 110) {
		keyWordCommentOpenMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 111) {
		keyWordCommentCloseMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 112) {
		keyWordEscpaeChar := Trim(A_LoopField)
	}
	if (A_Index = 113) {
		keyWordMainLabel := Trim(A_LoopField)
	}
	if (A_Index = 114) {
		keyWordConcat := Trim(A_LoopField)
	}
	if (A_Index = 115) {
		keyWordAdd := Trim(A_LoopField)
	}
	if (A_Index = 116) {
		keyWordSub := Trim(A_LoopField)
	}
	if (A_Index = 117) {
		keyWordMul := Trim(A_LoopField)
	}
	if (A_Index = 118) {
		keyWordDiv := Trim(A_LoopField)
	}
	if (A_Index = 119) {
		keyWordMod := Trim(A_LoopField)
	}
	if (A_Index = 120) {
		keyWordExp := Trim(A_LoopField)
	}
	if (A_Index = 121) {
		keyWordEqual := Trim(A_LoopField)
	}
	if (A_Index = 122) {
		keyWordStrictEqual := Trim(A_LoopField)
	}
	if (A_Index = 123) {
		keyWordNotEqual := Trim(A_LoopField)
	}
	if (A_Index = 124) {
		keyWordGreater := Trim(A_LoopField)
	}
	if (A_Index = 125) {
		keyWordLess := Trim(A_LoopField)
	}
	if (A_Index = 126) {
		keyWordGreaterEqual := Trim(A_LoopField)
	}
	if (A_Index = 127) {
		keyWordLessEqual := Trim(A_LoopField)
	}
	if (A_Index = 128) {
		keyWordAnd := Trim(A_LoopField)
	}
	if (A_Index = 129) {
		keyWordOr := Trim(A_LoopField)
	}
	if (A_Index = 130) {
		keyWordNot := Trim(A_LoopField)
	}
	if (A_Index = 131) {
		keyWordBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 132) {
		keyWordBitOr := Trim(A_LoopField)
	}
	if (A_Index = 133) {
		keyWordBitXor := Trim(A_LoopField)
	}
	if (A_Index = 134) {
		keyWordBitNot := Trim(A_LoopField)
	}
	if (A_Index = 135) {
		keyWordShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 136) {
		keyWordShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 137) {
		keyWordShiftUnsignedRight := Trim(A_LoopField)
	}
	if (A_Index = 138) {
		keyWordAssign := Trim(A_LoopField)
	}
	if (A_Index = 139) {
		keyWordAssignAdd := Trim(A_LoopField)
	}
	if (A_Index = 140) {
		keyWordAssignConcat := Trim(A_LoopField)
	}
	if (A_Index = 141) {
		keyWordAssignSub := Trim(A_LoopField)
	}
	if (A_Index = 142) {
		keyWordAssignMul := Trim(A_LoopField)
	}
	if (A_Index = 143) {
		keyWordAssignDiv := Trim(A_LoopField)
	}
	if (A_Index = 144) {
		keyWordAssignMod := Trim(A_LoopField)
	}
	if (A_Index = 145) {
		keyWordAssignShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 146) {
		keyWordAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 147) {
		keyWordLogicalAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 148) {
		keyWordAssignBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 149) {
		keyWordAssignBitOr := Trim(A_LoopField)
	}
	if (A_Index = 150) {
		keyWordAssignBitXor := Trim(A_LoopField)
	}
	if (A_Index = 151) {
		keyWordTernary1 := Trim(A_LoopField)
	}
	if (A_Index = 152) {
		keyWordTernary2 := Trim(A_LoopField)
	}
	if (A_Index = 153) {
		keyWordInc := Trim(A_LoopField)
	}
	if (A_Index = 154) {
		keyWordDec := Trim(A_LoopField)
	}
	if (A_Index = 155) {
		AHKlikeLoopsIndexedAt := Trim(A_LoopField)
	}
	if (A_Index = 156) {
		keyWordAIndex := Trim(A_LoopField)
	}
	if (A_Index = 157) {
		keyWordALoopField := Trim(A_LoopField)
	}
	if (A_Index = 158) {
		keyWordAllianceEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 159) {
		keyWordCrewEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 160) {
		keyWordMethodEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 161) {
		keyWordDefObjEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 162) {
		keyWordIFEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 163) {
		keyWordElseIfEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 164) {
		keyWordElseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 165) {
		keyWordSwitchEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 166) {
		keyWordSwitchCaseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 167) {
		keyWordSwitchDefaultEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 168) {
		keyWordWhileLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 169) {
		keyWordForLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 170) {
		keyWordLoopInfiniteEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 171) {
		keyWordLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 172) {
		keyWordLoopParseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 173) {
		keyWordFuncEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 174) {
		keyWordTryEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 175) {
		keyWordCatchEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 176) {
		keyWordFinallyEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 177) {
		useFuncKeyWord := Trim(A_LoopField)
	}
	if (A_Index = 178) {
		useCurlyBraces := Trim(A_LoopField)
	}
	if (A_Index = 179) {
		useEnd := Trim(A_LoopField)
	}
	if (A_Index = 180) {
		useEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 181) {
		useSemicolon := Trim(A_LoopField)
	}
	if (A_Index = 182) {
		useParentheses := Trim(A_LoopField)
	}
	if (A_Index = 183) {
		usePrefixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 184) {
		usePostfixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 185) {
		usePythonicColonSyntax := Trim(A_LoopField)
	}
	if (A_Index = 186) {
		useCurlyBracesSyntaxForArrayDef := Trim(A_LoopField)
	}
	if (A_Index = 187) {
		useInJavaScriptAlwaysUseVar := Trim(A_LoopField)
	}
	if (A_Index = 188) {
		useJavaScriptInAfullHTMLfile := Trim(A_LoopField)
	}
	if (A_Index = 189) {
		useJavaScriptAmainFuncDef := Trim(A_LoopField)
	}
	if (A_Index = 190) {
		useJavaScriptAllFuncsAreAsync := Trim(A_LoopField)
	}
	if (A_Index = 191) {
		useJavaScriptAlwaysTripleEqual := Trim(A_LoopField)
	}

}

if (Trim(langToConvertToParam) != "") {
    langToConvertTo := Trim(langToConvertToParam)
}


int isFullHTVMCode := 0
int isNotHTVMfile := 0

if (Trim(mode) = "full") {
    isFullHTVMCode := 1
} else {
    isFullHTVMCode := 0
}
if (Trim(mode) = "notHTVM") {
    isNotHTVMfile := 1
} else {
    isNotHTVMfile := 0
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
'''1

if (langToConvertTo = "htvm") {

}
if (langToConvertTo = "cpp") {

}
if (langToConvertTo = "py") {

}
if (langToConvertTo = "js") {

}
if (langToConvertTo = "go") {

}
if (langToConvertTo = "lua") {

}
if (langToConvertTo = "cs") {

}
if (langToConvertTo = "java") {

}
if (langToConvertTo = "kt") {

}
if (langToConvertTo = "rb") {

}
if (langToConvertTo = "nim") {

}
if (langToConvertTo = "ahk") {

}
if (langToConvertTo = "swift") {

}
if (langToConvertTo = "dart") {

}
if (langToConvertTo = "ts") {

}
if (langToConvertTo = "scala") {

}
if (langToConvertTo = "groovy") {

}
'''2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str HTVMout := ""

htCode := Trim(StrReplace(htCode, Chr(13), ""))

if (langToConvertTo = "htvm") {
HTVMout := "0"
}
if (langToConvertTo = "cpp") {
HTVMout := "0"
}
if (langToConvertTo = "py") {
HTVMout := "0"
}
if (langToConvertTo = "js") {
HTVMout := "0"
}
if (langToConvertTo = "go") {
HTVMout := "0"
}
if (langToConvertTo = "lua") {
HTVMout := "0"
}
if (langToConvertTo = "cs") {
HTVMout := "0"
}
if (langToConvertTo = "java") {
HTVMout := "0"
}
if (langToConvertTo = "kt") {
HTVMout := "0"
}
if (langToConvertTo = "rb") {
HTVMout := "0"
}
if (langToConvertTo = "nim") {
HTVMout := "0"
}
if (langToConvertTo = "ahk") {
HTVMout := "0"
}
if (langToConvertTo = "swift") {
HTVMout := "0"
}
if (langToConvertTo = "dart") {
HTVMout := "0"
}
if (langToConvertTo = "ts") {
HTVMout := "0"
}
if (langToConvertTo = "scala") {
HTVMout := "0"
}
if (langToConvertTo = "groovy") {
HTVMout := "0"
}

str code := ""

print(htCode)
code := htCode
print(instructionFile)
print(mode)
print(langToConvertTo)
print("==================================")
print("==================================")
print("==================================")
print("==================================")
print("==================================")
;print(allInstructionFile)


str codeOutFix1 := ""
Loop, Parse, code, `n, `r
{
codeOutFix1 .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, codeOutFix1, 1




int haveWeEverUsedAloop := 0
int lineDone := 0
str var1 := ""
str nothing := ""
int AindexcharLength := 1
str AindexcharLengthStr := ""
str theFixTextLoopNL := ""
int htCodeAcurlyBraceAddSomeVrasFixNL := 0
str htCodeLoopfixa := ""
str htCodeLoopfixa1 := ""
str str123 := ""
str out2 := ""
str myVar := ""
str lineYGI := ""
str line := ""
str line1 := ""
str line2 := ""
str line3 := ""
str itemsOut := ""
str var1out := ""
str theFixTextLoopLP := ""
int htCodeAcurlyBraceAddSomeVrasFixLP := 0
int AIndexLoopCurlyFix := 0
str sstr123 := ""
str fixLoopLokingFor := ""
int fixLoopLokingForfound := 0
str out1 := ""
int wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
int inTarget := 0
int insideBracket := 0
int netsedCurly := 0
int eldLoopNestedBADlol := 0
int readyToEnd := 0
int endBracketDOntPutThere := 0
int dontSaveStr := 0
int weAreDoneHereCurly := 0
int DeleayOneCuzOfLoopParse := 0
int fixLoopLokingForNum := 0
int insdeAnestedLoopBAD := 0
int foundTheTopLoop := 0
str out4758686d86d86d86578991a
str ALoopField := ""
str out1z := ""
int insideBracket1 := 0
int netsedCurly1 := 0
int readyToEnd1 := 0
str strstysrstsytTRIMHELP := ""
str out4758686d86dgt8r754444444 := ""
int hold := 0
str holdText := ""
int ignore := 0
str htCodeOut1234565432 := ""
str out := ""
str s := ""
int skipLeftCuleyForFuncPLS := 0







str htCodeOUT754754 := ""
int areWEinSome34sNum := 0
int theIdNumOfThe34 := 0




arr str theIdNumOfThe34theVar

str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
arr str getAllCharForTheFurtureSoIcanAddEscapeChar

int removeNexFixkeyWordEscpaeChar := 0

Loop, Parse, code
{
theIdNumOfThe34theVar.add("")
theIdNumOfThe34theVar.add("")
}

Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
}

getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")

ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuusgfgesrheidFor-aasdsas-theuhtuwaesphoutr" . Chr(34)
str OutFixDoubleQuotesInsideDoubleQuotes := ""

int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0

Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}


code := OutFixDoubleQuotesInsideDoubleQuotes

if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}


if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1) 
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)

}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}

theIdNumOfThe34theVar.add(Chr(34))



code := StrReplace(code, Chr(13), "")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (langToConvertTo != "py") and (langToConvertTo != "nim") and (langToConvertTo != "lua") and (langToConvertTo != "rb") and (langToConvertTo != "go") and (langToConvertTo != "swift") and (useSemicolon = "off") {
    theSemicolon := ";"
} else {
    theSemicolon := ""
}



if (langToConvertTo != "py") and (langToConvertTo != "nim") and (usePythonicColonSyntax = "off") {
    theColon := ""
} else {
    theColon := ":"
}





str beforeKeywordForRemoveCommentsOnTheEndOfTheLine := ""
str newStringOutCode := ""
int posForRemoveCommentsOnTheEndOfTheLine := 0
str originalStringForRemoveCommentsOnTheEndOfTheLine := ""
Loop, Parse, code, `n, `r
{

; Define the original string
originalStringForRemoveCommentsOnTheEndOfTheLine := A_LoopField

; Find the position of the keyword in the original string
posForRemoveCommentsOnTheEndOfTheLine := InStr(originalStringForRemoveCommentsOnTheEndOfTheLine, " " . keyWordComment)

if (SubStr(Trim(A_LoopField), 1, StrLen(keyWordComment)) != keyWordComment)
{
if (posForRemoveCommentsOnTheEndOfTheLine > 0)
{

; Extract the part of the string before the keyword
if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordForLoop))) != StrLower(keyWordForLoop))
{
beforeKeywordForRemoveCommentsOnTheEndOfTheLine := SubStr(originalStringForRemoveCommentsOnTheEndOfTheLine, 1, posForRemoveCommentsOnTheEndOfTheLine - 1)
}
else
{
beforeKeywordForRemoveCommentsOnTheEndOfTheLine := A_LoopField
}

; Construct the new string with everything before the keyword
newStringOutCode .= beforeKeywordForRemoveCommentsOnTheEndOfTheLine . "`n"
}
else
{
newStringOutCode .= A_LoopField . "`n"
}
}
else
{
newStringOutCode .= A_LoopField . "`n"
}

}

StringTrimRight, code, newStringOutCode, 1
;MsgBox, % code



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

str htCodeOutFixEnd := ""
if (useEnd = "on") or (useEndExtraInfo = "on")
{
Loop, Parse, code, `n, `r
{
if (StrLower(Trim(A_LoopField)) = StrLower(keyWordEnd))
{
htCodeOutFixEnd .= str10 . "}" . "`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopInfinite))) = StrLower(keyWordLoopInfinite))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchDefault))) = StrLower(keyWordSwitchDefault))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordTry))) = StrLower(keyWordTry))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordAlliance))) = StrLower(keyWordAlliance))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCrew))) = StrLower(keyWordCrew))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordDefObj))) = StrLower(keyWordDefObj))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordMethod))) = StrLower(keyWordMethod))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally))
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1
}


if (useEnd = "off") and (useEndExtraInfo = "off") and (useCurlyBraces = "off")
{
htCodeOutFixEnd := ""
Loop, Parse, code, `n, `r
{
if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordForLoop))) = StrLower(keyWordForLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopInfinite))) = StrLower(keyWordLoopInfinite))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordSwitchDefault))) = StrLower(keyWordSwitchDefault))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordTry))) = StrLower(keyWordTry))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordAlliance))) = StrLower(keyWordAlliance))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCrew))) = StrLower(keyWordCrew))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordDefObj))) = StrLower(keyWordDefObj))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordMethod))) = StrLower(keyWordMethod))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1

}


if (useCurlyBraces = "off") and (useEnd = "off") and (useEndExtraInfo = "off")
{
code := AddCurlyBraces(code)
}


Loop, Parse, code, `n, `r
{
outTrimCode .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, outTrimCode, 1


; for converting c++ to js and py
;code := StrReplace(code, "{}", "[]")

str outCodeFixBraces := ""
Loop, 2
{
outCodeFixBraces := ""
Loop, Parse, code, `n, `r
{
if (InStr(Trim(A_LoopField), "{")) and (Trim(A_LoopField) != "{")
{
outCodeFixBraces .= Trim(StrReplace(Trim(A_LoopField), "{", "")) . "`n{`n"
}
else if (InStr(Trim(A_LoopField), "}")) and (Trim(A_LoopField) != "}")
{
outCodeFixBraces .= "}`n" . Trim(StrReplace(Trim(A_LoopField), "}", "")) . "`n"
}
else
{
outCodeFixBraces .= Trim(A_LoopField) . "`n"
}

}

StringTrimRight, code, outCodeFixBraces, 1
}


;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;

int didWeUseMainLabel := 0
str codeOutFixAndAddMainFunc := ""

print(code)
print("WAEFDGSERDGFHESDFDGFSDFX=============")
htCode := ""
Loop, Parse, code, `n ,`r
{

htCode .= A_LoopField . "`n"
}
StringTrimRight, htCode, htCode, 1
print("WAEFDGSERDGFHESDFDGFSDFX=============")
print(htCode)
print("WAEFDGSERDGFHESDFDGFSDFX=============")
Loop, % theIdNumOfThe34
{

if (theIdNumOfThe34 = A_Index + 1)
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1] . Chr(34))
}
else
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1])
}

}
print(htCode)
return htCode
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func void HTVMv2()
{
str argCODE := ""
str argCODEfile := ""
str argHTVMinstr := ""
str argLangTo := ""
str OUTCODE := "null"

HTVM_v2_HTVM()

if (noParams = true)
{
return
}

Loop, Parse, str0
{
str00 := Trim(A_LoopField)
StringTrimRight, str00, str00, 1
}


print("HTVM v2")
if (HTVM_getLang_HTVM() = "cpp") or (HTVM_getLang_HTVM() = "py")
{

if (HTVM_getLang_HTVM() = "cpp")
{
print("CPP")
}
if (HTVM_getLang_HTVM() = "py")
{
print("PY")
}


Loop, Parse, allArgs, `n, `r
{
if (A_Index = 0)
{
argCODE := FileRead(Trim(A_LoopField))
argCODEfile := Trim(A_LoopField)
}
else if (A_Index = 1)
{
argHTVMinstr := Trim(A_LoopField)
}
else if (A_Index = 2)
{
argLangTo := Trim(A_LoopField)
}
else
{
argHTVMinstrMOVE.add(Trim(A_LoopField))
}
}

print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
if (SubStrLastChars(argCODEfile, 4) = ".cpp") or (SubStrLastChars(argCODEfile, 3) = ".py") or (SubStrLastChars(argCODEfile, 3) = ".js") or (SubStrLastChars(argCODEfile, 3) = ".go") or (SubStrLastChars(argCODEfile, 4) = ".lua") or (SubStrLastChars(argCODEfile, 3) = ".cs") or (SubStrLastChars(argCODEfile, 5) = ".java") or (SubStrLastChars(argCODEfile, 3) = ".kt") or (SubStrLastChars(argCODEfile, 3) = ".rb") or (SubStrLastChars(argCODEfile, 4) = ".nim") or (SubStrLastChars(argCODEfile, 4) = ".ahk") or (SubStrLastChars(argCODEfile, 6) = ".swift") or (SubStrLastChars(argCODEfile, 5) = ".dart") or (SubStrLastChars(argCODEfile, 3) = ".ts") or (SubStrLastChars(argCODEfile, 6) = ".scala") or (SubStrLastChars(argCODEfile, 7) = ".groovy")
{

if (argLangTo != "")
{
OUTCODE := compiler(argCODE, argHTVMinstr, "notHTVM", argLangTo)
}
else
{
OUTCODE := compiler(argCODE, argHTVMinstr, "notHTVM")
}
}
else
{


if (argLangTo != "")
{
OUTCODE := compiler(argCODE, argHTVMinstr, "full", argLangTo)
}
else
{
OUTCODE := compiler(argCODE, argHTVMinstr, "full")
}
}   


print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
FileDelete(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
FileAppend(OUTCODE, StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)



}

if (HTVM_getLang_HTVM() = "js")
{
print("JS")
}
}

main
HTVMv2()
