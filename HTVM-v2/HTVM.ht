

str str0 := "nothing"
str str00 := "nothing"
str str1 := ""
str str2 := ""
str str3 := ""
str str4 := ""
str str5 := ""
str str6 := ""
str str7 := ""
str str8 := ""
str str9 := ""
str str10 := ""
str str11 := ""
str str12 := ""
str str13 := ""
str str14 := ""

int int0 := 0
int int1 := 0
int int2 := 0
int int3 := 0
int int4 := 0
int int5 := 0
int int6 := 0
int int7 := 0

arr str argHTVMinstrMOVE

str extraCodeReturned := ""

str langToConvertTo := ""
str langFileExtension := ""
str commands := ""
str keyWordAlliance := ""
str keyWordCrew := ""
str keyWordMethod := ""
str keyWordDefObj := ""
str keyWordPorp := ""
str keyWordThis := ""
str keyWordInclude := ""
str keyWordIncludeInTheTranspiledLang := ""
str keyWordCodeInTheTranspiledLangStart := ""
str keyWordCodeInTheTranspiledLangEnd := ""
str keyWordCodeInTheTranspiledLangStartCPP := ""
str keyWordCodeInTheTranspiledLangEndCPP := ""
str keyWordCodeInTheTranspiledLangStartPY := ""
str keyWordCodeInTheTranspiledLangEndPY := ""
str keyWordCodeInTheTranspiledLangStartJS := ""
str keyWordCodeInTheTranspiledLangEndJS := ""
str keyWordCodeInTheTranspiledLangStartGO := ""
str keyWordCodeInTheTranspiledLangEndGO := ""
str keyWordCodeInTheTranspiledLangStartLUA := ""
str keyWordCodeInTheTranspiledLangEndLUA := ""
str keyWordCodeInTheTranspiledLangStartCS := ""
str keyWordCodeInTheTranspiledLangEndCS := ""
str keyWordCodeInTheTranspiledLangStartJAVA := ""
str keyWordCodeInTheTranspiledLangEndJAVA := ""
str keyWordCodeInTheTranspiledLangStartKT := ""
str keyWordCodeInTheTranspiledLangEndKT := ""
str keyWordCodeInTheTranspiledLangStartRB := ""
str keyWordCodeInTheTranspiledLangEndRB := ""
str keyWordCodeInTheTranspiledLangStartNIM := ""
str keyWordCodeInTheTranspiledLangEndNIM := ""
str keyWordCodeInTheTranspiledLangStartAHK := ""
str keyWordCodeInTheTranspiledLangEndAHK := ""
str keyWordCodeInTheTranspiledLangStartSWIFT := ""
str keyWordCodeInTheTranspiledLangEndSWIFT := ""
str keyWordCodeInTheTranspiledLangStartDART := ""
str keyWordCodeInTheTranspiledLangEndDART := ""
str keyWordCodeInTheTranspiledLangStartTS := ""
str keyWordCodeInTheTranspiledLangEndTS := ""
str keyWordCodeInTheTranspiledLangStartSCALA := ""
str keyWordCodeInTheTranspiledLangEndSCALA := ""
str keyWordCodeInTheTranspiledLangStartGROOVY := ""
str keyWordCodeInTheTranspiledLangEndGROOVY := ""
str keyWordCodeInTheTranspiledLangStartHTVM := ""
str keyWordCodeInTheTranspiledLangEndHTVM := ""
str keyWordCodeInHTVMstart := ""
str keyWordCodeInHTVMend := ""
str keyWordCodeInOtherHTVMsyntaxStart := ""
str keyWordCodeInOtherHTVMsyntaxEnd := ""
str keyWordCurlyBraceOpen := ""
str keyWordCurlyBraceClose := ""
str keyWordNull := ""
str keyWordTrue := ""
str keyWordFalse := ""
str keyWordVoid := ""
str keyWordDouble := ""
str keyWordChar := ""
str keyWordUint8 := ""
str keyWordUint16 := ""
str keyWordUint32 := ""
str keyWordUint64 := ""
str keyWordINT := ""
str keyWordSTR := ""
str keyWordBOOL := ""
str keyWordFLOAT := ""
str keyWordINT8 := ""
str keyWordINT16 := ""
str keyWordINT32 := ""
str keyWordINT64 := ""
str keyWordIF := ""
str keyWordElseIf := ""
str keyWordElse := ""
str keyWordSwitch := ""
str keyWordSwitchCase := ""
str keyWordSwitchDefault := ""
str keyWordWhileLoop := ""
str keyWordLoopInfinite := ""
str keyWordLoop := ""
str keyWordLoopParse := ""
str keyWordContinue := ""
str keyWordBreak := ""
str keyWordFunc := ""
str keyWordAwait := ""
str keyWordAsync := ""
str keyWordThrow := ""
str keyWordErrorMsg := ""
str keyWordTry := ""
str keyWordCatch := ""
str keyWordFinally := ""
str keyWordReturnStatement := ""
str keyWordArrayAppend := ""
str keyWordArrayPop := ""
str keyWordArraySize := ""
str keyWordArrayInsert := ""
str keyWordArrayRemove := ""
str keyWordArrayIndexOf := ""
str keyWordArrayDefinition := ""
str keyWordArrayOfIntegersDefinition := ""
str keyWordArrayOfStringsDefinition := ""
str keyWordArrayOfFloatingPointNumbersDefinition := ""
str keyWordArrayOfBooleansDefinition := ""
str keyWordVar := ""
str keyWordLet := ""
str keyWordConst := ""
str keyWordEnd := ""
str keyWordGlobal := ""
str keyWordComment := ""
str keyWordCommentOpenMultiLine := ""
str keyWordCommentCloseMultiLine := ""
str keyWordEscpaeChar := ""
str keyWordMainLabel := ""
str keyWordConcat := ""
str keyWordAdd := ""
str keyWordSub := ""
str keyWordMul := ""
str keyWordDiv := ""
str keyWordMod := ""
str keyWordExp := ""
str keyWordEqual := ""
str keyWordStrictEqual := ""
str keyWordNotEqual := ""
str keyWordGreater := ""
str keyWordLess := ""
str keyWordGreaterEqual := ""
str keyWordLessEqual := ""
str keyWordAnd := ""
str keyWordOr := ""
str keyWordNot := ""
str keyWordBitAnd := ""
str keyWordBitOr := ""
str keyWordBitXor := ""
str keyWordBitNot := ""
str keyWordShiftLeft := ""
str keyWordShiftRight := ""
str keyWordShiftUnsignedRight := ""
str keyWordAssign := ""
str keyWordAssignAdd := ""
str keyWordAssignConcat := ""
str keyWordAssignSub := ""
str keyWordAssignMul := ""
str keyWordAssignDiv := ""
str keyWordAssignMod := ""
str keyWordAssignShiftLeft := ""
str keyWordAssignShiftRight := ""
str keyWordLogicalAssignShiftRight := ""
str keyWordAssignBitAnd := ""
str keyWordAssignBitOr := ""
str keyWordAssignBitXor := ""
str keyWordTernary1 := ""
str keyWordTernary2 := ""
str keyWordInc := ""
str keyWordDec := ""
str AHKlikeLoopsIndexedAt := ""
str keyWordAIndex := ""
str keyWordALoopField := ""
str keyWordAllianceEndExtraInfo := ""
str keyWordCrewEndExtraInfo := ""
str keyWordMethodEndExtraInfo := ""
str keyWordDefObjEndExtraInfo := ""
str keyWordIFEndExtraInfo := ""
str keyWordElseIfEndExtraInfo := ""
str keyWordElseEndExtraInfo := ""
str keyWordSwitchEndExtraInfo := ""
str keyWordSwitchCaseEndExtraInfo := ""
str keyWordSwitchDefaultEndExtraInfo := ""
str keyWordWhileLoopEndExtraInfo := ""
str keyWordForLoopEndExtraInfo := ""
str keyWordLoopInfiniteEndExtraInfo := ""
str keyWordLoopEndExtraInfo := ""
str keyWordLoopParseEndExtraInfo := ""
str keyWordFuncEndExtraInfo := ""
str keyWordTryEndExtraInfo := ""
str keyWordCatchEndExtraInfo := ""
str keyWordFinallyEndExtraInfo := ""
str useFuncKeyWord := ""
str useCurlyBraces := ""
str useEnd := ""
str useEndExtraInfo := ""
str useSemicolon := ""
str theSemicolon := ""
str theColon := ""
str useParentheses := ""
str usePrefixTypeForTypeDefinition := ""
str usePostfixTypeForTypeDefinition := ""
str usePythonicColonSyntax := ""
str useCurlyBracesSyntaxForArrayDef := "" 
str useInJavaScriptAlwaysUseVar := ""
str useJavaScriptInAfullHTMLfile := ""
str useJavaScriptAmainFuncDef := ""
str useJavaScriptAllFuncsAreAsync := ""
str useJavaScriptAlwaysTripleEqual := ""


str out_KeyWordsCommands := ""
str outTrimCode := ""
str htCode := ""

str outVarOperator := ""
int lineDone := 0
int areWeInAFuncFromInstructions := 0
int areWeInAFuncFromInstructionsLineNum := 0

str theCppVarForErrors := "jhku-dfsds-ds-d-ffdsf-sdfsfdsedsf"
str theJSvarDeclaredVarsBugFix := "|"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



func str KeyWordsCommands(str theCodeCommands, str mode, str keyWordsCommands, str langToConvertTo)
{
theCodeCommands := StrReplace(theCodeCommands, "%", "")
if (mode = "check")
{
Loop, Parse, keyWordsCommands, "|"
{
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{

if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
return "true"
}
}

if (A_Index = 1)
{
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
return "true"
}
}


}

}
;MsgBox, false
return "false"
}

int AIndex := 0
if (mode = "transpile")
{

int keyWordsCommandsNumLine := 1
Loop, Parse, keyWordsCommands, "|"
{
AIndex := A_Index
Loop, Parse, A_LoopField, `,
{
if (A_Index = 1)
{
if (SubStr(StrLower(theCodeCommands), 1, StrLen(A_LoopField . ", ")) = StrLower(A_LoopField . ", "))
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}

if (A_Index = 1)
{
;MsgBox, %theCodeCommands% = %A_LoopField%
if (theCodeCommands = A_LoopField)
{
;MsgBox, true
keyWordsCommandsNumLine := AIndex
break
}
}


}

}





str outConstuctTheOutFromTheCommands := ""
str outConstuctTheOutFromTheCommandsFucnName := ""
str outConstuctTheOutFromTheCommandsParams := ""
str outConstuctTheOutFromTheCommandsOutVar := ""
str outConstuctTheOutFromTheCommandsInVar := ""
int theCodeCommandNum := 1
int outConstuctTheOutFromTheCommandsLineTranspile := 0
str outConstuctTheOutFromTheCommandsLineTranspileText := ""

str semicolon := ""
if (langToConvertTo != "py")
{
semicolon := ";"
}

arr str theCodeCommand
theCodeCommands := Trim(theCodeCommands)
Loop, Parse, theCodeCommands, `,
{
theCodeCommand.add(Trim(A_LoopField))
;MsgBox, % A_LoopField
}


Loop, Parse, keyWordsCommands, "|"
{



if (keyWordsCommandsNumLine = A_Index)
{

;MsgBox, % A_LoopField

Loop, Parse, A_LoopField, `,
{




if (A_Index = 1)
{
outConstuctTheOutFromTheCommandsFucnName := A_LoopField
}
else if (A_Index = 2)
{

;MsgBox, % A_LoopField
if (A_LoopField = "lineTranspile")
{
outConstuctTheOutFromTheCommandsLineTranspile := 1
}

if (A_LoopField = "OUTVAR")
{
outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INOUTVAR")
{

outConstuctTheOutFromTheCommandsOutVar := theCodeCommand[theCodeCommandNum]
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}

}



}
else if (A_Index = 3)
{

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommandsLineTranspileText := A_LoopField
}


if (A_LoopField = "INVAR")
{
outConstuctTheOutFromTheCommandsInVar := theCodeCommand[theCodeCommandNum]
}
else
{
if (InStr(A_LoopField, Chr(39)))
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}
else
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}

}
else
{

;MsgBox, % theCodeCommand[theCodeCommandNum]
if (InStr(A_LoopField, Chr(39)))
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= Chr(34) . theCodeCommand[theCodeCommandNum] . Chr(34) . ", "
}

}
else
{
if (Trim(theCodeCommand[theCodeCommandNum]) != "")
{
outConstuctTheOutFromTheCommandsParams .= theCodeCommand[theCodeCommandNum] . ", "
}
}
}
theCodeCommandNum++
}
break
}

}

StringTrimRight, outConstuctTheOutFromTheCommandsParams, outConstuctTheOutFromTheCommandsParams, 2

if (outConstuctTheOutFromTheCommandsOutVar != "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsOutVar . " = " . outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}

}

if (outConstuctTheOutFromTheCommandsOutVar = "")
{
if (outConstuctTheOutFromTheCommandsParams = "")
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ")" . semicolon
}
else
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsFucnName . "(" . outConstuctTheOutFromTheCommandsInVar . ", " . outConstuctTheOutFromTheCommandsParams . ")" . semicolon
}
}

if (outConstuctTheOutFromTheCommandsLineTranspile = 1)
{
outConstuctTheOutFromTheCommands := outConstuctTheOutFromTheCommandsLineTranspileText
}


outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(, ", "( ")
outConstuctTheOutFromTheCommands := StrReplace(outConstuctTheOutFromTheCommands, "(,", "(")
return outConstuctTheOutFromTheCommands





}

return "false"
}


func str HTVMmatchStrRrplace(str line, str matchString, str replaceString) {
    str lineOut := ""
    if (!InStr(line, matchString)) {
        return line
    }
    str allDelimiters := " ()[].,;:'!&|=<>+-*/^%~" . Chr(34) . Chr(9) . Chr(11)
    arr str lineArr
    Loop, Parse, line {
        lineArr.add(A_LoopField)
    }
    int matchStringLEN := StrLen(matchString)
    int replaceStringLEN := StrLen(replaceString)
    arr int allPosForReplacing
    str sildingLine := ""
    int isStart := 1
    int i1 := 0
    int hasFound := 0
    int hasFound2 := 0
    int isStartTrue := 0
    int isEndTrue := 0
    ; char1 is for text outside the start
    str char1 := ""
    ; char2 is for text inside the start
    str char2 := ""
    ; char3 is for text inside the end
    str char3 := ""
    ; char4 is for text outside the end
    str char4 := ""
    int isMatch := 0
    sildingLine := ""
    isStart := 1
    i1 := 0
    hasFound := 0
    hasFound2 := 0
    isStartTrue := 0
    isEndTrue := 0
    Loop, % lineArr.size() {
        char1 := ""
        char2 := ""
        char3 := ""
        char4 := ""
        isMatch := 0
        if (A_Index != 0) {
            isStart := 0
        }
        sildingLine := ""
        Loop, % matchStringLEN {
            if (A_Index + i1 <= lineArr.size() - 1) {
                sildingLine .= lineArr[A_Index + i1]
            }
        }
        if (StrLen(sildingLine) < matchStringLEN) {
            break
        }
        ;print("!!!!111111111!!!!!!: " . sildingLine)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;==================
        if (sildingLine = matchString) {
            hasFound := 1
            if (isStart != 1) {
                ;print("!!!!2222222222!!!!!!: " . lineArr[i1 - 1])
                char1 := lineArr[i1 - 1]
                ;print("!!!!2222222222.555555555!!!!!!: " . lineArr[i1])
                char2 := lineArr[i1]
            } else {
                isStartTrue := 1
            }
            if (i1 + matchStringLEN < lineArr.size()) {
                ;print("!!!!3333333333.5555555555!!!!!!: " . lineArr[i1 + matchStringLEN - 1])
                char3 := lineArr[i1 + matchStringLEN - 1]
                ;print("!!!!3333333333!!!!!!: " . lineArr[i1 + matchStringLEN])
                char4 := lineArr[i1 + matchStringLEN]
            } else {
                isEndTrue := 1
            }
            if (InStr(allDelimiters, char1)) or (InStr(allDelimiters, char2)) {
                isStartTrue := 1
            }
            if (InStr(allDelimiters, char3)) or (InStr(allDelimiters, char4)) {
                isEndTrue := 1
            }
            if (isStartTrue = 1) and (isEndTrue = 1) {
                isMatch := 1
            }
        }
        ;;;;;;;;;;;;;;;;;;;;===============
        if (isMatch = 1) {
            if (allPosForReplacing.size() > 0) {
                Loop, % allPosForReplacing.size() {
                    if (i1 + 1 != allPosForReplacing[A_Index]) {
                        allPosForReplacing.add(i1 + 1)
                        break
                    }
                }
            } else {
                allPosForReplacing.add(i1 + 1)
            }
        }
        i1++
    }
    str lineTEMP := ""
    lineOut := line
    ;print(allPosForReplacing)
    if (allPosForReplacing.size() > 0) {
        ; matchStringLEN
        ; replaceStringLEN
        int l2 := 0
        int currentPos := 0
        int onceEnd := 0
        Loop, % allPosForReplacing.size() {
            if (A_Index = 0) {
                currentPos := allPosForReplacing[A_Index]
            } else {
                currentPos := allPosForReplacing[A_Index] - (matchStringLEN - replaceStringLEN)
            }
            onceEnd := 0
            Loop, Parse, lineOut {
                if (A_Index + 2 > currentPos) and (A_Index + 1 < currentPos + matchStringLEN) {
                    onceEnd++
                    ;print("DDDDDDDDDDD" . STR(A_Index))
                    if (onceEnd = 1) {
                        lineTEMP .= replaceString
                    }
                } else {
                    lineTEMP .= A_LoopField
                }
            }
            lineOut := lineTEMP
            lineTEMP := ""
            ;print(lineTEMP)
            l2++
        }
    } else {
        return line
    }
    return lineOut
}

func str SubStrLastChars(str text, int numOfChars) {
    str LastOut := ""
    int NumOfChars := 0
    Loop, Parse, text {
        NumOfChars++
    }
    Loop, % numOfChars {
        NumOfChars--
    }
    Loop, Parse, text {
        if (A_Index >= NumOfChars) {
            LastOut .= A_LoopField
        }
    }
    return LastOut
}


func str ExtractDigits(str inputString)
{
str digits := ""

Loop, Parse, inputString
{
    if (RegExMatch(A_LoopField, "\d"))
    {
        digits .= A_LoopField
    }
}
return digits
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Helper function to create spaces
func str spaces(int n)
{
str s := ""
if (n != 0)
{
Loop, % n
{
s .= " "
}
}
return s
}


; Define the function to check odd spaces at the beginning
func str CheckOddLeadingSpaces(str string123)
{
; Initialize a variable to count the spaces
int spaceCount := 0

; Loop through the string one character at a time
Loop, Parse, string123
{
; Check if the current character is a space
if (A_LoopField = Chr(32))
{
spaceCount++
}
else
{
; When we hit a non-space character, break the loop
break
}
}

; Return true if the number of spaces is odd, false otherwise
str sdsfawasd := STR(Mod(spaceCount, 2) = 1)
;MsgBox, % sdsfawasd
return sdsfawasd
}

func str LTrim(str input)
{
    str result := ""
    bool foundNonSpace := false

    Loop, Parse, input
    {
        if (A_LoopField != " " or foundNonSpace)
        {
            result .= A_LoopField
            foundNonSpace := true
        }
    }

    return result
}


func str getLastChar(str strippedString)
{
str lastChar
Loop, Parse, strippedString
{
lastChar := A_LoopField
}
return lastChar
}

func str AddCurlyBraces(str pythonCode)
{
pythonCode := StrReplace(pythonCode, Chr(9), "    ")
str result := ""
int indentLevel := 0
int indent := 0
str line := ""
str stripped := ""
Loop, Parse, pythonCode, `n, `r
{
line := A_LoopField
stripped := Trim(line)
if (stripped = "")
{
result .= line . "`n"
continue
}

; Count leading spaces
indent := StrLen(line) - StrLen(LTrim(line))

; Close braces for unindents

Loop
{
if (indentLevel <= indent)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


; Add opening brace for new blocks
if (getLastChar(stripped) = ":") and (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordComment))) != StrLower(keyWordComment))
{
result .= SubStr(line, 1, -1) . " {`n"
indentLevel += 4
}
else
{
result .= line . "`n"
}
}

; Close any remaining open braces
Loop
{
if (indentLevel <= 0)
{
break
}
indentLevel -= 4
result .= spaces(indentLevel) . "}`n"
}


return result
}


func str RepeatSpaces(int count)
{
str spaces := ""
Loop, % count
{
spaces .= Chr(32)
}
return spaces
}


func str indent_nested_curly_braces(str input_string, int modeCurlyBracesOn)
{
int indent_size := 4
int current_indent := 0
str result := ""
str trimmed_line := ""
str resultOut := ""
;MsgBox, % input_string
Loop, Parse, input_string, `n, `r
{

trimmed_line := Trim(A_LoopField)

if (trimmed_line = Chr(123))
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
current_indent := current_indent + indent_size
}
else if (trimmed_line = Chr(125))
{

current_indent := current_indent - indent_size
result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}
else
{

result .= Chr(32) . RepeatSpaces(current_indent) . trimmed_line . "`n"
}

}


if (modeCurlyBracesOn = 0)
{
str resultOut := ""
Loop, Parse, result, `n, `r
{
if (Trim(A_LoopField) != "{") and (Trim(A_LoopField) != "}")
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}
else
{
; format curly braces in a K&R style

arr str lookIntoFurture

Loop, Parse, result, `n, `r
{
lookIntoFurture.add(Trim(A_LoopField))
}
lookIntoFurture.add(" ")

str resultOut := ""
int skipNext := 0
Loop, Parse, result, `n, `r
{


skipNext--
if (skipNext <= 0)
{
skipNext := 0
}
if (Trim(lookIntoFurture[A_Index + 1]) = "{")
{
resultOut .= A_LoopField . " {`n"
skipNext := 2
}

if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}


}
StringTrimRight, result, resultOut, 1

arr str lookIntoFurture2

Loop, Parse, result, `n, `r
{
lookIntoFurture2.add(Trim(A_LoopField))
}
lookIntoFurture2.add(" ")


resultOut := ""
skipNext := 0
str addSpacesAtTheBegginig
Loop, Parse, result, `n, `r
{
skipNext--
if (skipNext <= 0)
{
skipNext := 0
}

if (langToConvertTo != "lua") and (langToConvertTo != "rb")
{
if (Trim(A_LoopField) = "}") and (Trim(lookIntoFurture2[A_Index + 1]) = "else {")
{
skipNext := 2
addSpacesAtTheBegginig := ""
Loop, Parse, A_LoopField
{
if (A_LoopField = " ")
{
if (A_LoopField != " ")
{
break
}
addSpacesAtTheBegginig .= A_LoopField
}
}
resultOut .= addSpacesAtTheBegginig . "} else {`n"
}
}


if (skipNext = 0)
{
resultOut .= A_LoopField . "`n"
}
}
StringTrimRight, result, resultOut, 1
}


resultOut := ""
str ALoopField
Loop, Parse, result, `n, `r
{
if (CheckOddLeadingSpaces(A_LoopField) = "1")
{
StringTrimLeft, ALoopField, A_LoopField, 1
resultOut .= ALoopField . "`n"
}
else
{
resultOut .= A_LoopField . "`n"
}
}

StringTrimRight, result, resultOut, 1


; Return the result
return result
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]
str OSPstrArrayStrALLobjInOSP := ""
str HoldOSPdethodNamePath := ""

func str findTypeOfOSPprop(str fullARRAYstr, str FromPath)
{
str outType := ""
; if the fullARRAYstr is in this format
; path.path.path:propName1[str],propName2[bool],propName3[str array]|path.path.path:propName1[str],propName2[bool],propName3[str array]

str outFormat := ""
str outFormatHELP1 := ""
str outFormatHELP2 := ""


Loop, Parse, fullARRAYstr, "|"
{
if (Trim(A_LoopField) != "")
{
outFormatHELP1 := StrSplit(A_LoopField, ":", 1)
outFormatHELP2 := StrSplit(A_LoopField, ":", 2)
Loop, Parse, outFormatHELP2, `,
{
outFormat .= outFormatHELP1 . "." . A_LoopField . "|"
}
}
}
StringTrimRight, outFormat, outFormat, 1


Loop, Parse, outFormat, "|"
{
if (Trim(A_LoopField) != "")
{
if (StrSplit(Trim(A_LoopField), "[", 1) = Trim(FromPath))
{
outType := StrSplit(Trim(A_LoopField), "[", 2)
StringTrimRight, outType, outType, 1
break
}

}
}




if (outType = "vector<int>")
{
outType := "std::vector<int>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<string>")
{
outType := "std::vector<std::string>&"
}
else if (outType = "vector<float>")
{
outType := "std::vector<float>&"
}
else if (outType = "vector<bool>")
{
outType := "std::vector<bool>&"
}
else if (outType = Trim(keyWordINT))
{
outType := "int"
}
else if (outType = Trim(keyWordSTR))
{
outType := "std::string"
}
else if (outType = Trim(keyWordFLOAT))
{
outType := "float"
}
else if (outType = Trim(keyWordBOOL))
{
outType := "bool"
}
else if (outType = Trim(keyWordINT8))
{
outType := "int8_t"
}
else if (outType = Trim(keyWordINT16))
{
outType := "int16_t"
}
else if (outType = Trim(keyWordINT32))
{
outType := "int32_t"
}
else if (outType = Trim(keyWordINT64))
{
outType := "int64_t"
}


return outType
}


func str REMOVELastSTRfromDOT(str THESTR)
{
str THESTRout := ""
if (Trim(THESTR) = "")
{
return ""
}
int count12345 := 0

Loop, Parse, THESTR, "."
{
count12345++
}


Loop, Parse, THESTR, "."
{
if (count12345 = A_Index)
{
break
}
else
{
THESTRout .= Trim(A_LoopField) . "."
}
}

StringTrimRight, THESTRout, THESTRout, 1

return THESTRout
}


;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsPY_JS(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "this__OSP__this[0]")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str replaceTheOSPpathsLEFT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_"))

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}

func str replaceTheOSPpathsRIGHT(str theSTR123, str ALoopFieldIN)
{

if (Trim(theSTR123) = "")
{
return ""
}
if (Trim(ALoopFieldIN) = "")
{
return ""
}

str type := ""
str theSTR123out := ""
str ALoopField := ""
str ALoopField1 := ""
str ALoopField11 := ""

if (InStr(ALoopFieldIN, "["))
{
; ALoopFieldIN
; animalsKingdom.animals.Dog.typeOf2[2]

ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)


ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 1)
ALoopField11 := StrSplit(Trim(ALoopFieldIN), "[", 2)
ALoopField1 := REMOVELastSTRfromDOT(ALoopField1) . "[" . ALoopField11


; REMOVELastSTRfromDOT(param1)
type := findTypeOfOSPprop(OSPstrArrayStrALLobjInOSP, ALoopField)
;MsgBox, % type

theSTR123 := StrReplace(theSTR123, Trim(ALoopField), "std::any_cast<" . type . ">(OSPHTVMOSP_" . StrReplace(ALoopField1, ".", "_") . ")")

}
else
{
ALoopField := StrSplit(Trim(ALoopFieldIN), "[", 1)

ALoopField1 := StrSplit(Trim(ALoopFieldIN), "[", 2)

ALoopField1 := REMOVELastSTRfromDOT(StrSplit(Trim(ALoopFieldIN), "]", 1))

ALoopField1 := "[" . Trim(StrSplit(ALoopField1, "[", 2)) . "]"
theSTR123 := StrReplace(theSTR123, Trim(ALoopFieldIN), "OSPHTVMOSP_" . StrReplace(ALoopFieldIN, ".", "_"))

}

;this__OSP__this
theSTR123 := RegExReplace(theSTR123, "\bthis\b", "std::any_cast<std::string>((*this__OSP__this)[0])")
theSTR123 := StrReplace(theSTR123, "OSPHTVMOSP_OSPHTVMOSP_", "OSPHTVMOSP_")



return theSTR123
}


func str CheckStringPosition(str text, str target, str reference)
{

    str posReference := SubStr(text, 1, StrLen(reference))
    str posTarget := SubStr(text, 1, StrLen(target))

    ; Check if both strings are found (not using InStr)
    if (posReference != "" and posTarget != "")
    {
        ; Manually find the positions of the target and reference
        posTarget := RegExMatch(text, target)
        posReference := RegExMatch(text, reference)

        ; Compare positions of target and reference
        if (posTarget < posReference)
        {

            return "left"
        }
        else if (posTarget > posReference)
        {

return "not left"
        }
        else
        {

return "uuh"
        }
    }
    else
    {

        return "One or both strings not found."
    }

return "huh"
}


func str getIndexOfTheStrArrayStrOST(str ALoopField, str theSringOSPlineARRAYstrstrSTR)
{



Loop, Parse, theSringOSPlineARRAYstrstrSTR, "|"
{
if (Trim(StrSplit(A_LoopField, ":", 1)) = Trim(ALoopField))
{

return STR(A_Index)
}
}



return "0"
}



func str parserOSPgloabl(str theSringOSPline, str str123)
{
str str_1 := ""
str str_2 := ""
str str_3 := ""
str str_4 := ""
str str_5 := ""
str str_6 := ""

str HELPHoldOSPdethodNamePath := ""

StringTrimRight, HELPHoldOSPdethodNamePath, HoldOSPdethodNamePath, 1




Loop, Parse, theSringOSPline, "|"
{
str_1 .= Trim(StrSplit(A_LoopField, ":", 1)) . "`n"
str_5 := Trim(StrSplit(A_LoopField, ":", 1))
str_6 := Trim(StrSplit(A_LoopField, ":", 2))
Loop, Parse, str_6, `,
{
str_1 .= str_5 . "." . Trim(StrSplit(A_LoopField, "[", 1)) . "[" . STR(A_Index) . "]`n"
}

}

str_1 .= StrReplace(HELPHoldOSPdethodNamePath, "|", "`n")



str shortestLine := ""
str currentLine := ""
int currentLength := 0
int minLength := 0
str tempStr := ""

; Sorting by repeatedly finding and appending the shortest line
Loop
{
    ; Initialize variables to track the shortest line in this pass
    shortestLine := ""
    minLength := 999999

    ; Find the shortest line in str_1
    Loop, Parse, str_1, `n, `r
    {
        currentLine := A_LoopField
        currentLength := StrLen(currentLine)
        if (currentLength < minLength)
        {
            minLength := currentLength
            shortestLine := currentLine
        }
    }

    ; If no shortest line is found, break (str_1 is empty)
    if (shortestLine = "")
	{
        break
	}

    ; Add the shortest line to the sorted result
    str_2 .= shortestLine . "`n"

    ; Rebuild str_1 without the shortest line
    tempStr := ""
    Loop, Parse, str_1, `n, `r
    {
        if (A_LoopField != shortestLine)
		{
            tempStr .= A_LoopField . "`n"
		}

    }
    StringTrimRight, tempStr, tempStr, 1
    str_1 := tempStr
}

; Trim the final trailing newline from str_2
StringTrimRight, str_2, str_2, 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Initialize an empty result for the reversed lines
str reversedStr := ""

; Count the number of lines
int lineCount := 0
int index := 0
int lineNum := 0

Loop, Parse, str_2, `n, `r
{
    lineCount++
}

; Reverse the order by re-parsing and appending lines in reverse order
Loop, % lineCount
{
    ; Inner loop to find the (lineCount - A_Index + 1)-th line
    index := lineCount - A_Index + 1
    currentLine := ""
    lineNum := 0

    Loop, Parse, str_2, `n, `r
    {
        lineNum++
        if (lineNum = index)
        {
            currentLine := A_LoopField
            break
        }
    }

    ; Append the line in reverse order
    reversedStr .= currentLine . "`n"
}

; Trim the final trailing newline
StringTrimRight, str_2, reversedStr, 1


; Display the sorted result
;MsgBox, % str_2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;CheckStringPosition(text, target, reference)
str ALoopField := ""
str ALoopField1 := ""

Loop, Parse, str_2, `n, `r
{

if (SubStr(A_LoopField, 1, StrLen(keyWordFunc)) != keyWordFunc)
{

if (langToConvertTo = "cpp")
{

if (Trim(A_LoopField) != "")
{


if (InStr(str123, " += "))
{
str6 := " += "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " = "))
{

str6 := " = "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " -= "))
{
str6 := " -= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " *= "))
{
str6 := " *= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else if (InStr(str123, " /= "))
{

str6 := " /= "
str1 := ""
str2 := ""
str3 := ""
str4 := ""
str5 := ""
str1 := Trim(StrSplit(str123, str6, 1))
str2 := Trim(StrSplit(str123, str6, 2))
str3 := Trim(replaceTheOSPpathsLEFT(str1, A_LoopField))
str4 := Trim(replaceTheOSPpathsRIGHT(str2, A_LoopField))
str5 := str3 . str6 . str4
str123 := Trim(str5)

}
else
{

str123 := replaceTheOSPpathsRIGHT(str123, A_LoopField)

}


;;;;;
}
}
else
{
if (Trim(A_LoopField) != "")
{
str123 := replaceTheOSPpathsPY_JS(str123, A_LoopField)
}
}



}
}



return str123
}



func bool isLineAconstruct(str line)
{
if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordElse)) or (StrLower(Trim(line)) = StrLower(keyWordElse . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordElse))) = keyWordCurlyBraceClose . " " . StrLower(keyWordElse))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordElse) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordElse) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordWhileLoop))) = StrLower(keyWordWhileLoop))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordLoopInfinite)) or (StrLower(Trim(line)) = StrLower(keyWordLoopInfinite . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordLoopInfinite))) = keyWordCurlyBraceClose . " " . StrLower(keyWordLoopInfinite))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordLoopInfinite) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordLoopInfinite) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordSwitch))) = StrLower(keyWordSwitch))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordSwitchCase))) = StrLower(keyWordSwitchCase))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordSwitchDefault)) or (StrLower(Trim(line)) = StrLower(keyWordSwitchDefault . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordSwitchDefault))) = keyWordCurlyBraceClose . " " . StrLower(keyWordSwitchDefault))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordSwitchDefault) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordSwitchDefault) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordTry)) or (StrLower(Trim(line)) = StrLower(keyWordTry . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordTry))) = keyWordCurlyBraceClose . " " . StrLower(keyWordTry))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordTry) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordTry) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordAlliance))) = StrLower(keyWordAlliance))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordCrew))) = StrLower(keyWordCrew))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordDefObj))) = StrLower(keyWordDefObj))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordMethod))) = StrLower(keyWordMethod))
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch))
{
return true
}
else if (StrLower(Trim(line)) = StrLower(keyWordFinally)) or (StrLower(Trim(line)) = StrLower(keyWordFinally . ":"))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(keyWordCurlyBraceClose . " " . StrLower(keyWordFinally))) = keyWordCurlyBraceClose . " " . StrLower(keyWordFinally))
{
return true
}
else if (SubStr(Trim(line), 1, StrLen(StrLower(keyWordFinally) . " " . keyWordCurlyBraceOpen)) = StrLower(keyWordFinally) . " " . keyWordCurlyBraceOpen)
{
return true
}
else if (SubStr(StrLower(Trim(line)), 1, StrLen(StrLower(keyWordFunc))) = StrLower(keyWordFunc))
{
return true
}
return false
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str expressionParserTranspiler(str expression)
{

if (langToConvertTo = "htvm") {
expression := expression
}
if (langToConvertTo = "cpp") {
expression := expression
}
if (langToConvertTo = "py") {
expression := expression
}
if (langToConvertTo = "js") {
expression := expression
}
if (langToConvertTo = "go") {
expression := expression
}
if (langToConvertTo = "lua") {
expression := expression
}
if (langToConvertTo = "cs") {
expression := expression
}
if (langToConvertTo = "java") {
expression := expression
}
if (langToConvertTo = "kt") {
expression := expression
}
if (langToConvertTo = "rb") {
expression := expression
}
if (langToConvertTo = "nim") {
expression := expression
}
if (langToConvertTo = "ahk") {
expression := expression
}
if (langToConvertTo = "swift") {
expression := expression
}
if (langToConvertTo = "dart") {
expression := expression
}
if (langToConvertTo = "ts") {
expression := expression
}
if (langToConvertTo = "scala") {
expression := expression
}
if (langToConvertTo = "groovy") {
expression := expression
}

return expression
}




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func str compiler(str htCode, str allInstructionFile, str mode, str langToConvertToParam := "")
{
extraCodeReturned := ""


str instructions := allInstructionFile

Loop, Parse, allInstructionFile, `n, `r
{
	if (A_Index = 0) {
		langToConvertTo := Trim(A_LoopField)
	}
	if (A_Index = 1) {
		langFileExtension := Trim(A_LoopField)
	}
	if (A_Index = 2) {
		commands := Trim(A_LoopField)
	}
	if (A_Index = 3) {
		keyWordAlliance := Trim(A_LoopField) . " "
	}
	if (A_Index = 4) {
		keyWordCrew := Trim(A_LoopField) . " "
	}
	if (A_Index = 5) {
		keyWordMethod := Trim(A_LoopField) . " "
	}
	if (A_Index = 6) {
		keyWordDefObj := Trim(A_LoopField) . " "
	}
	if (A_Index = 7) {
		keyWordPorp := Trim(A_LoopField) . " "
	}
	if (A_Index = 8) {
		keyWordThis := Trim(A_LoopField)
	}
	if (A_Index = 9) {
		keyWordInclude := Trim(A_LoopField) . " "
	}
	if (A_Index = 10) {
		keyWordIncludeInTheTranspiledLang := Trim(A_LoopField)
	}
	if (A_Index = 11) {
		keyWordCodeInTheTranspiledLangStart := Trim(A_LoopField)
	}
	if (A_Index = 12) {
		keyWordCodeInTheTranspiledLangEnd := Trim(A_LoopField)
	}
	if (A_Index = 13) {
		keyWordCodeInTheTranspiledLangStartCPP := Trim(A_LoopField)
	}
	if (A_Index = 14) {
		keyWordCodeInTheTranspiledLangEndCPP := Trim(A_LoopField)
	}
	if (A_Index = 15) {
		keyWordCodeInTheTranspiledLangStartPY := Trim(A_LoopField)
	}
	if (A_Index = 16) {
		keyWordCodeInTheTranspiledLangEndPY := Trim(A_LoopField)
	}
	if (A_Index = 17) {
		keyWordCodeInTheTranspiledLangStartJS := Trim(A_LoopField)
	}
	if (A_Index = 18) {
		keyWordCodeInTheTranspiledLangEndJS := Trim(A_LoopField)
	}
	if (A_Index = 19) {
		keyWordCodeInTheTranspiledLangStartGO := Trim(A_LoopField)
	}
	if (A_Index = 20) {
		keyWordCodeInTheTranspiledLangEndGO := Trim(A_LoopField)
	}
	if (A_Index = 21) {
		keyWordCodeInTheTranspiledLangStartLUA := Trim(A_LoopField)
	}
	if (A_Index = 22) {
		keyWordCodeInTheTranspiledLangEndLUA := Trim(A_LoopField)
	}
	if (A_Index = 23) {
		keyWordCodeInTheTranspiledLangStartCS := Trim(A_LoopField)
	}
	if (A_Index = 24) {
		keyWordCodeInTheTranspiledLangEndCS := Trim(A_LoopField)
	}
	if (A_Index = 25) {
		keyWordCodeInTheTranspiledLangStartJAVA := Trim(A_LoopField)
	}
	if (A_Index = 26) {
		keyWordCodeInTheTranspiledLangEndJAVA := Trim(A_LoopField)
	}
	if (A_Index = 27) {
		keyWordCodeInTheTranspiledLangStartKT := Trim(A_LoopField)
	}
	if (A_Index = 28) {
		keyWordCodeInTheTranspiledLangEndKT := Trim(A_LoopField)
	}
	if (A_Index = 29) {
		keyWordCodeInTheTranspiledLangStartRB := Trim(A_LoopField)
	}
	if (A_Index = 30) {
		keyWordCodeInTheTranspiledLangEndRB := Trim(A_LoopField)
	}
	if (A_Index = 31) {
		keyWordCodeInTheTranspiledLangStartNIM := Trim(A_LoopField)
	}
	if (A_Index = 32) {
		keyWordCodeInTheTranspiledLangEndNIM := Trim(A_LoopField)
	}
	if (A_Index = 33) {
		keyWordCodeInTheTranspiledLangStartAHK := Trim(A_LoopField)
	}
	if (A_Index = 34) {
		keyWordCodeInTheTranspiledLangEndAHK := Trim(A_LoopField)
	}
	if (A_Index = 35) {
		keyWordCodeInTheTranspiledLangStartSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 36) {
		keyWordCodeInTheTranspiledLangEndSWIFT := Trim(A_LoopField)
	}
	if (A_Index = 37) {
		keyWordCodeInTheTranspiledLangStartDART := Trim(A_LoopField)
	}
	if (A_Index = 38) {
		keyWordCodeInTheTranspiledLangEndDART := Trim(A_LoopField)
	}
	if (A_Index = 39) {
		keyWordCodeInTheTranspiledLangStartTS := Trim(A_LoopField)
	}
	if (A_Index = 40) {
		keyWordCodeInTheTranspiledLangEndTS := Trim(A_LoopField)
	}
	if (A_Index = 41) {
		keyWordCodeInTheTranspiledLangStartSCALA := Trim(A_LoopField)
	}
	if (A_Index = 42) {
		keyWordCodeInTheTranspiledLangEndSCALA := Trim(A_LoopField)
	}
	if (A_Index = 43) {
		keyWordCodeInTheTranspiledLangStartGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 44) {
		keyWordCodeInTheTranspiledLangEndGROOVY := Trim(A_LoopField)
	}
	if (A_Index = 45) {
		keyWordCodeInTheTranspiledLangStartHTVM := Trim(A_LoopField)
	}
	if (A_Index = 46) {
		keyWordCodeInTheTranspiledLangEndHTVM := Trim(A_LoopField)
	}
	if (A_Index = 47) {
		keyWordCodeInHTVMstart := Trim(A_LoopField)
	}
	if (A_Index = 48) {
		keyWordCodeInHTVMend := Trim(A_LoopField)
	}
	if (A_Index = 49) {
		keyWordCodeInOtherHTVMsyntaxStart := Trim(A_LoopField)
	}
	if (A_Index = 50) {
		keyWordCodeInOtherHTVMsyntaxStart := Trim(A_LoopField)
	}
	if (A_Index = 51) {
		keyWordCurlyBraceOpen := Trim(A_LoopField)
	}
	if (A_Index = 52) {
		keyWordCurlyBraceClose := Trim(A_LoopField)
	}
	if (A_Index = 53) {
		keyWordNull := Trim(A_LoopField)
	}
	if (A_Index = 54) {
		keyWordTrue := Trim(A_LoopField)
	}
	if (A_Index = 55) {
		keyWordFalse := Trim(A_LoopField)
	}
	if (A_Index = 56) {
		keyWordVoid := Trim(A_LoopField) . " "
	}
	if (A_Index = 57) {
		keyWordDouble := Trim(A_LoopField) . " "
	}
	if (A_Index = 58) {
		keyWordChar := Trim(A_LoopField) . " "
	}
	if (A_Index = 59) {
		keyWordUint8 := Trim(A_LoopField) . " "
	}
	if (A_Index = 60) {
		keyWordUint16 := Trim(A_LoopField) . " "
	}
	if (A_Index = 61) {
		keyWordUint32 := Trim(A_LoopField) . " "
	}
	if (A_Index = 62) {
		keyWordUint64 := Trim(A_LoopField) . " "
	}
	if (A_Index = 63) {
		keyWordINT := Trim(A_LoopField) . " "
	}
	if (A_Index = 64) {
		keyWordSTR := Trim(A_LoopField) . " "
	}
	if (A_Index = 65) {
		keyWordBOOL := Trim(A_LoopField) . " "
	}
	if (A_Index = 66) {
		keyWordFLOAT := Trim(A_LoopField) . " "
	}
	if (A_Index = 67) {
		keyWordINT8 := Trim(A_LoopField) . " "
	}
	if (A_Index = 68) {
		keyWordINT16 := Trim(A_LoopField) . " "
	}
	if (A_Index = 69) {
		keyWordINT32 := Trim(A_LoopField) . " "
	}
	if (A_Index = 70) {
		keyWordINT64 := Trim(A_LoopField) . " "
	}
	if (A_Index = 71) {
		keyWordIF := Trim(A_LoopField) . " "
	}
	if (A_Index = 72) {
		keyWordElseIf := Trim(A_LoopField) . " "
	}
	if (A_Index = 73) {
		keyWordElse := Trim(A_LoopField)
	}
	if (A_Index = 74) {
		keyWordSwitch := Trim(A_LoopField) . " "
	}
	if (A_Index = 75) {
		keyWordSwitchCase := Trim(A_LoopField) . " "
	}
	if (A_Index = 76) {
		keyWordSwitchDefault := Trim(A_LoopField)
	}
	if (A_Index = 77) {
		keyWordWhileLoop := Trim(A_LoopField) . " "
	}
	if (A_Index = 78) {
		keyWordLoopInfinite := Trim(A_LoopField)
	}
	if (A_Index = 79) {
		keyWordLoop := Trim(A_LoopField) . " "
	}
	if (A_Index = 80) {
		keyWordLoopParse := Trim(A_LoopField) . " "
	}
	if (A_Index = 81) {
		keyWordContinue := Trim(A_LoopField)
	}
	if (A_Index = 82) {
		keyWordBreak := Trim(A_LoopField)
	}
	if (A_Index = 83) {
		keyWordFunc := Trim(A_LoopField) . " "
	}
	if (A_Index = 84) {
		keyWordAwait := Trim(A_LoopField) . " "
	}
	if (A_Index = 85) {
		keyWordAsync := Trim(A_LoopField) . " "
	}
	if (A_Index = 86) {
		keyWordThrow := Trim(A_LoopField) . " "
	}
	if (A_Index = 87) {
		keyWordErrorMsg := Trim(A_LoopField)
	}
	if (A_Index = 88) {
		keyWordTry := Trim(A_LoopField)
	}
	if (A_Index = 89) {
		keyWordCatch := Trim(A_LoopField) . " "
	}
	if (A_Index = 90) {
		keyWordFinally := Trim(A_LoopField)
	}
	if (A_Index = 91) {
		keyWordReturnStatement := Trim(A_LoopField) . " "
	}
	if (A_Index = 92) {
		keyWordArrayAppend := Trim(A_LoopField)
	}
	if (A_Index = 93) {
		keyWordArrayPop := Trim(A_LoopField)
	}
	if (A_Index = 94) {
		keyWordArraySize := Trim(A_LoopField)
	}
	if (A_Index = 95) {
		keyWordArrayInsert := Trim(A_LoopField)
	}
	if (A_Index = 96) {
		keyWordArrayRemove := Trim(A_LoopField)
	}
	if (A_Index = 97) {
		keyWordArrayIndexOf := Trim(A_LoopField)
	}
	if (A_Index = 98) {
		keyWordArrayDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 99) {
		keyWordArrayOfIntegersDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 100) {
		keyWordArrayOfStringsDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 101) {
		keyWordArrayOfFloatingPointNumbersDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 102) {
		keyWordArrayOfBooleansDefinition := Trim(A_LoopField) . " "
	}
	if (A_Index = 103) {
		keyWordVar := Trim(A_LoopField) . " "
	}
	if (A_Index = 104) {
		keyWordLet := Trim(A_LoopField) . " "
	}
	if (A_Index = 105) {
		keyWordConst := Trim(A_LoopField) . " "
	}
	if (A_Index = 106) {
		keyWordEnd := Trim(A_LoopField)
	}
	if (A_Index = 107) {
		keyWordGlobal := Trim(A_LoopField) . " "
	}
	if (A_Index = 108) {
		keyWordComment := Trim(A_LoopField)
	}
	if (A_Index = 109) {
		keyWordCommentOpenMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 110) {
		keyWordCommentCloseMultiLine := Trim(A_LoopField)
	}
	if (A_Index = 111) {
		keyWordEscpaeChar := Trim(A_LoopField)
	}
	if (A_Index = 112) {
		keyWordMainLabel := Trim(A_LoopField)
	}
	if (A_Index = 113) {
		keyWordConcat := Trim(A_LoopField)
	}
	if (A_Index = 114) {
		keyWordAdd := Trim(A_LoopField)
	}
	if (A_Index = 115) {
		keyWordSub := Trim(A_LoopField)
	}
	if (A_Index = 116) {
		keyWordMul := Trim(A_LoopField)
	}
	if (A_Index = 117) {
		keyWordDiv := Trim(A_LoopField)
	}
	if (A_Index = 118) {
		keyWordMod := Trim(A_LoopField)
	}
	if (A_Index = 119) {
		keyWordExp := Trim(A_LoopField)
	}
	if (A_Index = 120) {
		keyWordEqual := Trim(A_LoopField)
	}
	if (A_Index = 121) {
		keyWordStrictEqual := Trim(A_LoopField)
	}
	if (A_Index = 122) {
		keyWordNotEqual := Trim(A_LoopField)
	}
	if (A_Index = 123) {
		keyWordGreater := Trim(A_LoopField)
	}
	if (A_Index = 124) {
		keyWordLess := Trim(A_LoopField)
	}
	if (A_Index = 125) {
		keyWordGreaterEqual := Trim(A_LoopField)
	}
	if (A_Index = 126) {
		keyWordLessEqual := Trim(A_LoopField)
	}
	if (A_Index = 127) {
		keyWordAnd := Trim(A_LoopField)
	}
	if (A_Index = 128) {
		keyWordOr := Trim(A_LoopField)
	}
	if (A_Index = 129) {
		keyWordNot := Trim(A_LoopField)
	}
	if (A_Index = 130) {
		keyWordBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 131) {
		keyWordBitOr := Trim(A_LoopField)
	}
	if (A_Index = 132) {
		keyWordBitXor := Trim(A_LoopField)
	}
	if (A_Index = 133) {
		keyWordBitNot := Trim(A_LoopField)
	}
	if (A_Index = 134) {
		keyWordShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 135) {
		keyWordShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 136) {
		keyWordShiftUnsignedRight := Trim(A_LoopField)
	}
	if (A_Index = 137) {
		keyWordAssign := Trim(A_LoopField)
	}
	if (A_Index = 138) {
		keyWordAssignAdd := Trim(A_LoopField)
	}
	if (A_Index = 139) {
		keyWordAssignConcat := Trim(A_LoopField)
	}
	if (A_Index = 140) {
		keyWordAssignSub := Trim(A_LoopField)
	}
	if (A_Index = 141) {
		keyWordAssignMul := Trim(A_LoopField)
	}
	if (A_Index = 142) {
		keyWordAssignDiv := Trim(A_LoopField)
	}
	if (A_Index = 143) {
		keyWordAssignMod := Trim(A_LoopField)
	}
	if (A_Index = 144) {
		keyWordAssignShiftLeft := Trim(A_LoopField)
	}
	if (A_Index = 145) {
		keyWordAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 146) {
		keyWordLogicalAssignShiftRight := Trim(A_LoopField)
	}
	if (A_Index = 147) {
		keyWordAssignBitAnd := Trim(A_LoopField)
	}
	if (A_Index = 148) {
		keyWordAssignBitOr := Trim(A_LoopField)
	}
	if (A_Index = 149) {
		keyWordAssignBitXor := Trim(A_LoopField)
	}
	if (A_Index = 150) {
		keyWordTernary1 := Trim(A_LoopField)
	}
	if (A_Index = 151) {
		keyWordTernary2 := Trim(A_LoopField)
	}
	if (A_Index = 152) {
		keyWordInc := Trim(A_LoopField)
	}
	if (A_Index = 153) {
		keyWordDec := Trim(A_LoopField)
	}
	if (A_Index = 154) {
		AHKlikeLoopsIndexedAt := Trim(A_LoopField)
	}
	if (A_Index = 155) {
		keyWordAIndex := Trim(A_LoopField)
	}
	if (A_Index = 156) {
		keyWordALoopField := Trim(A_LoopField)
	}
	if (A_Index = 157) {
		keyWordAllianceEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 158) {
		keyWordCrewEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 159) {
		keyWordMethodEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 160) {
		keyWordDefObjEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 161) {
		keyWordIFEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 162) {
		keyWordElseIfEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 163) {
		keyWordElseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 164) {
		keyWordSwitchEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 165) {
		keyWordSwitchCaseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 166) {
		keyWordSwitchDefaultEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 167) {
		keyWordWhileLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 168) {
		keyWordForLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 169) {
		keyWordLoopInfiniteEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 170) {
		keyWordLoopEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 171) {
		keyWordLoopParseEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 172) {
		keyWordFuncEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 173) {
		keyWordTryEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 174) {
		keyWordCatchEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 175) {
		keyWordFinallyEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 176) {
		useCurlyBraces := Trim(A_LoopField)
	}
	if (A_Index = 177) {
		useEnd := Trim(A_LoopField)
	}
	if (A_Index = 178) {
		useEndExtraInfo := Trim(A_LoopField)
	}
	if (A_Index = 179) {
		useSemicolon := Trim(A_LoopField)
	}
	if (A_Index = 180) {
		useParentheses := Trim(A_LoopField)
	}
	if (A_Index = 181) {
		usePrefixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 182) {
		usePostfixTypeForTypeDefinition := Trim(A_LoopField)
	}
	if (A_Index = 183) {
		usePythonicColonSyntax := Trim(A_LoopField)
	}
	if (A_Index = 184) {
		useCurlyBracesSyntaxForArrayDef := Trim(A_LoopField)
	}
	if (A_Index = 185) {
		useInJavaScriptAlwaysUseVar := Trim(A_LoopField)
	}
	if (A_Index = 186) {
		useJavaScriptInAfullHTMLfile := Trim(A_LoopField)
	}
	if (A_Index = 187) {
		useJavaScriptAmainFuncDef := Trim(A_LoopField)
	}
	if (A_Index = 188) {
		useJavaScriptAllFuncsAreAsync := Trim(A_LoopField)
	}
	if (A_Index = 189) {
		useJavaScriptAlwaysTripleEqual := Trim(A_LoopField)
	}

}

if (Trim(langToConvertToParam) != "") {
    langToConvertTo := Trim(langToConvertToParam)
}


int isFullHTVMCode := 0
int isNotHTVMfile := 0

if (Trim(mode) = "full") {
    isFullHTVMCode := 1
} else {
    isFullHTVMCode := 0
}
if (Trim(mode) = "notHTVM") {
    isNotHTVMfile := 1
} else {
    isNotHTVMfile := 0
}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
'''1

if (langToConvertTo = "htvm") {

}
if (langToConvertTo = "cpp") {

}
if (langToConvertTo = "py") {

}
if (langToConvertTo = "js") {

}
if (langToConvertTo = "go") {

}
if (langToConvertTo = "lua") {

}
if (langToConvertTo = "cs") {

}
if (langToConvertTo = "java") {

}
if (langToConvertTo = "kt") {

}
if (langToConvertTo = "rb") {

}
if (langToConvertTo = "nim") {

}
if (langToConvertTo = "ahk") {

}
if (langToConvertTo = "swift") {

}
if (langToConvertTo = "dart") {

}
if (langToConvertTo = "ts") {

}
if (langToConvertTo = "scala") {

}
if (langToConvertTo = "groovy") {

}
'''2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
str HTVMout := ""

htCode := Trim(StrReplace(htCode, Chr(13), ""))

str code := ""

print(htCode)
code := htCode
print(mode)
print(langToConvertTo)
print("==================================")
print("==================================")
print("==================================")
print("==================================")
print("==================================")
;print(allInstructionFile)






int haveWeEverUsedAloop := 0
int lineDone := 0
str var1 := ""
str nothing := ""
int AindexcharLength := 1
str AindexcharLengthStr := ""
str theFixTextLoopNL := ""
int htCodeAcurlyBraceAddSomeVrasFixNL := 0
str htCodeLoopfixa := ""
str htCodeLoopfixa1 := ""
str str123 := ""
str out2 := ""
str myVar := ""
str lineYGI := ""
str line := ""
str line1 := ""
str line2 := ""
str line3 := ""
str itemsOut := ""
str var1out := ""
str theFixTextLoopLP := ""
int htCodeAcurlyBraceAddSomeVrasFixLP := 0
int AIndexLoopCurlyFix := 0
str sstr123 := ""
str fixLoopLokingFor := ""
int fixLoopLokingForfound := 0
str out1 := ""
int wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
int inTarget := 0
int insideBracket := 0
int netsedCurly := 0
int eldLoopNestedBADlol := 0
int readyToEnd := 0
int endBracketDOntPutThere := 0
int dontSaveStr := 0
int weAreDoneHereCurly := 0
int DeleayOneCuzOfLoopParse := 0
int fixLoopLokingForNum := 0
int insdeAnestedLoopBAD := 0
int foundTheTopLoop := 0
str out4758686d86d86d86578991a
str ALoopField := ""
str out1z := ""
int insideBracket1 := 0
int netsedCurly1 := 0
int readyToEnd1 := 0
str strstysrstsytTRIMHELP := ""
str out4758686d86dgt8r754444444 := ""
int hold := 0
str holdText := ""
int ignore := 0
str htCodeOut1234565432 := ""
str out := ""
str s := ""
int skipLeftCuleyForFuncPLS := 0







str htCodeOUT754754 := ""
int areWEinSome34sNum := 0
int theIdNumOfThe34 := 0




arr str theIdNumOfThe34theVar

str ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := ""
arr str getAllCharForTheFurtureSoIcanAddEscapeChar

int removeNexFixkeyWordEscpaeChar := 0

Loop, Parse, code
{
theIdNumOfThe34theVar.add("")
theIdNumOfThe34theVar.add("")
}

Loop, Parse, code
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
getAllCharForTheFurtureSoIcanAddEscapeChar.add(A_LoopField)
}

getAllCharForTheFurtureSoIcanAddEscapeChar.add(" ")

ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes := Chr(34) . "ihuiuusgfgesrheidFor-aasdsas-theuhtuwaesphoutr" . Chr(34)
str OutFixDoubleQuotesInsideDoubleQuotes := ""

int fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0

Loop, Parse, code
{

if (A_LoopField = keyWordEscpaeChar) and (getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1] = Chr(34))
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 1
OutFixDoubleQuotesInsideDoubleQuotes .= ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes
}
else
{
if (fixOutFixDoubleQuotesInsideDoubleQuotesFIXok != 1)
{
OutFixDoubleQuotesInsideDoubleQuotes .= A_LoopField
}
else
{
fixOutFixDoubleQuotesInsideDoubleQuotesFIXok := 0
}
}

}


code := OutFixDoubleQuotesInsideDoubleQuotes

if (keyWordEscpaeChar != Chr(92))
{
code := StrReplace(code, Chr(92), Chr(92) . Chr(92))
}


if (keyWordEscpaeChar = Chr(92))
{
Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1) 
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}
}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)
}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}

}
else
{

Loop, Parse, code
{
if (A_LoopField = Chr(34))
{
areWEinSome34sNum++
}


if (areWEinSome34sNum = 1)
{



if (A_LoopField != Chr(34))
{
if (A_LoopField = keyWordEscpaeChar) and (keyWordEscpaeChar = getAllCharForTheFurtureSoIcanAddEscapeChar[A_Index + 1])
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . keyWordEscpaeChar
removeNexFixkeyWordEscpaeChar := 1
}
else if (A_LoopField = keyWordEscpaeChar)
{
if (removeNexFixkeyWordEscpaeChar != 1)
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . Chr(92)
}
else
{
removeNexFixkeyWordEscpaeChar := 0
}
}
else
{
theIdNumOfThe34theVar[theIdNumOfThe34] := theIdNumOfThe34theVar[theIdNumOfThe34] . A_LoopField
}

}
else
{
theIdNumOfThe34++
htCodeOUT754754 .= "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(theIdNumOfThe34) . Chr(65) . Chr(65)

}

}


if (areWEinSome34sNum = 2) or (areWEinSome34sNum = 0)
{
if (A_LoopField != Chr(34))
{
htCodeOUT754754 .= A_LoopField
}

areWEinSome34sNum := 0
}



}
}






code := htCodeOUT754754

Loop, % theIdNumOfThe34
{
theIdNumOfThe34theVar[A_Index] := theIdNumOfThe34theVar[A_Index] . Chr(34)
}

theIdNumOfThe34theVar.add(Chr(34))



code := StrReplace(code, Chr(13), "")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

if (langToConvertTo != "py") and (langToConvertTo != "nim") and (langToConvertTo != "lua") and (langToConvertTo != "rb") and (langToConvertTo != "go") and (langToConvertTo != "swift") and (useSemicolon = "off") {
    theSemicolon := ";"
} else {
    theSemicolon := ""
}



if (langToConvertTo != "py") and (langToConvertTo != "nim") and (usePythonicColonSyntax = "off") {
    theColon := ""
} else {
    theColon := ":"
}





str beforeKeywordForRemoveCommentsOnTheEndOfTheLine := ""
str newStringOutCode := ""
int posForRemoveCommentsOnTheEndOfTheLine := 0
str originalStringForRemoveCommentsOnTheEndOfTheLine := ""
Loop, Parse, code, `n, `r
{

; Define the original string
originalStringForRemoveCommentsOnTheEndOfTheLine := A_LoopField

; Find the position of the keyword in the original string
posForRemoveCommentsOnTheEndOfTheLine := InStr(originalStringForRemoveCommentsOnTheEndOfTheLine, " " . keyWordComment)

if (SubStr(Trim(A_LoopField), 1, StrLen(keyWordComment)) != keyWordComment)
{
if (posForRemoveCommentsOnTheEndOfTheLine > 0)
{


beforeKeywordForRemoveCommentsOnTheEndOfTheLine := A_LoopField


; Construct the new string with everything before the keyword
newStringOutCode .= beforeKeywordForRemoveCommentsOnTheEndOfTheLine . "`n"
}
else
{
newStringOutCode .= A_LoopField . "`n"
}
}
else
{
newStringOutCode .= A_LoopField . "`n"
}

}

StringTrimRight, code, newStringOutCode, 1
;MsgBox, % code


str htCodeOutFixEnd := ""
int htCodeOutFixINT := 0
int htCodeOutFixINT2 := 0

if (useCurlyBraces = "on")
{
if (keyWordCurlyBraceOpen != "{")
{

Loop, Parse, code, `n, `r
{
htCodeOutFixINT2 := 0
if (isLineAconstruct(Trim(A_LoopField)) = true) or (Trim(A_LoopField) = keyWordCurlyBraceOpen)
{
htCodeOutFixINT2 := 1
}

htCodeOutFixINT := 0
Loop, Parse, A_LoopField, " "
{
htCodeOutFixINT++
}

htCodeOutFixINT--
Loop, Parse, A_LoopField, " "
{
if (htCodeOutFixINT = A_Index) && (htCodeOutFixINT2 = 1)
{
htCodeOutFixINT2 := 0
htCodeOutFixEnd .= HTVMmatchStrRrplace(A_LoopField, keyWordCurlyBraceOpen, "{") . " "
}
else
{
htCodeOutFixEnd .= A_LoopField . " "
}

}
StringTrimRight, htCodeOutFixEnd, htCodeOutFixEnd, 1
htCodeOutFixEnd .= "`n"

}
StringTrimRight, code, htCodeOutFixEnd, 1

}
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
htCodeOutFixEnd := ""

if (keyWordCurlyBraceClose != "}")
{

Loop, Parse, code, `n, `r
{
htCodeOutFixINT2 := 0
if (isLineAconstruct(Trim(A_LoopField)) = true) or (Trim(A_LoopField) = keyWordCurlyBraceClose)
{
htCodeOutFixINT2 := 1
}
htCodeOutFixINT := 0
Loop, Parse, A_LoopField, " "
{
htCodeOutFixINT++
}

htCodeOutFixINT--
Loop, Parse, A_LoopField, " "
{
if (htCodeOutFixINT = A_Index) && (htCodeOutFixINT2 = 1)
{
htCodeOutFixINT2 := 0
htCodeOutFixEnd .= HTVMmatchStrRrplace(A_LoopField, keyWordCurlyBraceClose, "}") . " "
}
else
{
htCodeOutFixEnd .= A_LoopField . " "
}

}
StringTrimRight, htCodeOutFixEnd, htCodeOutFixEnd, 1
htCodeOutFixEnd .= "`n"

}
StringTrimRight, code, htCodeOutFixEnd, 1

}
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

htCodeOutFixEnd := ""
if (useEnd = "on") or (useEndExtraInfo = "on")
{
Loop, Parse, code, `n, `r
{
if (StrLower(Trim(A_LoopField)) = StrLower(keyWordEnd)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordAllianceEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordCrewEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordMethodEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordDefObjEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordIFEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordElseIfEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordElseEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordSwitchEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordSwitchCaseEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordSwitchDefaultEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordWhileLoopEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordForLoopEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordLoopInfiniteEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordLoopEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordLoopParseEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordFuncEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordTryEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordCatchEndExtraInfo)) or (StrLower(Trim(A_LoopField)) = StrLower(keyWordFinallyEndExtraInfo))
{
htCodeOutFixEnd .= "}`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordIF))) = StrLower(keyWordIF)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElseIf))) = StrLower(keyWordElseIf)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordElse))) = StrLower(keyWordElse)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordCatch))) = StrLower(keyWordCatch)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (SubStr(StrLower(Trim(A_LoopField)), 1, StrLen(StrLower(keyWordFinally))) = StrLower(keyWordFinally)) and (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= "`n}`n" . A_LoopField . "`n{`n"
}
else if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . "`n{`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1
}

if (usePythonicColonSyntax = "off")
{
if (useEnd = "off") and (useEndExtraInfo = "off") and (useCurlyBraces = "off")
{
htCodeOutFixEnd := ""
Loop, Parse, code, `n, `r
{
if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= A_LoopField . ":`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}
}
StringTrimRight, code, htCodeOutFixEnd, 1

}

}



if (useCurlyBraces = "off") and (useEnd = "off") and (useEndExtraInfo = "off")
{
code := AddCurlyBraces(code)
}



outTrimCode := ""
Loop, Parse, code, `n, `r
{
outTrimCode .= Trim(A_LoopField) . "`n"
}
StringTrimRight, code, outTrimCode, 1


; for converting c++ to js and py
;code := StrReplace(code, "{}", "[]")

str outCodeFixBraces := ""
Loop, 2
{
outCodeFixBraces := ""
Loop, Parse, code, `n, `r
{
if (InStr(Trim(A_LoopField), "{")) and (Trim(A_LoopField) != "{")
{
outCodeFixBraces .= Trim(StrReplace(Trim(A_LoopField), "{", "")) . "`n{`n"
}
else if (InStr(Trim(A_LoopField), "}")) and (Trim(A_LoopField) != "}")
{
outCodeFixBraces .= "}`n" . Trim(StrReplace(Trim(A_LoopField), "}", "")) . "`n"
}
else
{
outCodeFixBraces .= Trim(A_LoopField) . "`n"
}

}

StringTrimRight, code, outCodeFixBraces, 1
}



htCodeOutFixEnd := ""
if (usePythonicColonSyntax = "on")
{


Loop, Parse, code, `n, `r
{
if (isLineAconstruct(Trim(A_LoopField)) = true)
{
htCodeOutFixEnd .= StringTrimRight(A_LoopField, 1) . "`n"
}
else
{
htCodeOutFixEnd .= A_LoopField . "`n"
}

}

StringTrimRight, code, htCodeOutFixEnd, 1
}




;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;
;;; main loop ;;;

int didWeUseMainLabel := 0
str codeOutFixAndAddMainFunc := ""







Loop, Parse, code, `n, `r
{

if (StrLower(A_LoopField) = StrLower(keyWordMainLabel))
{
didWeUseMainLabel := 1
if (langToConvertTo = "cpp")
{
codeOutFixAndAddMainFunc .= "int main(int argc, char* argv[])`n{`n"
}
if (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc .= "async function main()`n{`n"
}
if (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc .= "async function main(): Promise<void>`n{`n"
}
if (langToConvertTo = "go")
{
codeOutFixAndAddMainFunc .= "func main()`n{`n"
}
if (langToConvertTo = "cs")
{
codeOutFixAndAddMainFunc .= "static void Main(string[] args)`n{`n"
}
if (langToConvertTo = "java")
{
codeOutFixAndAddMainFunc .= "public static void main(String[] args)`n{`n"
}
if (langToConvertTo = "kt")
{
codeOutFixAndAddMainFunc .= "fun main(args: Array<String>)`n{`n"
}
if (langToConvertTo = "swift")
{
codeOutFixAndAddMainFunc .= "func main()`n{`n"
}
if (langToConvertTo = "dart")
{
codeOutFixAndAddMainFunc .= "void main(List<String> arguments)`n{`n"
}
if (langToConvertTo = "scala")
{
    codeOutFixAndAddMainFunc .= "ndef main(args: Array[String]): Unit = `n{`n"
}

}
else
{
codeOutFixAndAddMainFunc .= A_LoopField . "`n"
}
}

if (didWeUseMainLabel != 1) and (langToConvertTo = "cpp")
{
codeOutFixAndAddMainFunc := "int main(int argc, char* argv[])`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
codeOutFixAndAddMainFunc := "async function main()`n{`n" . codeOutFixAndAddMainFunc
}

if (didWeUseMainLabel != 1) and (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
    codeOutFixAndAddMainFunc := "async function main(): Promise<void>`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "go")
{
    codeOutFixAndAddMainFunc := "func main()`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "cs")
{
    codeOutFixAndAddMainFunc := "static void Main(string[] args)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "java")
{
    codeOutFixAndAddMainFunc := "public static void main(String[] args)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "kt")
{
    codeOutFixAndAddMainFunc := "fun main(args: Array<String>)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "swift")
{
    codeOutFixAndAddMainFunc := "func main()`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "dart")
{
    codeOutFixAndAddMainFunc := "void main(List<String> arguments)`n{`n" . codeOutFixAndAddMainFunc
}
if (didWeUseMainLabel != 1) and (langToConvertTo = "scala")
{
    codeOutFixAndAddMainFunc := "def main(args: Array[String]): Unit = `n{`n" . codeOutFixAndAddMainFunc
}

StringTrimRight, code, codeOutFixAndAddMainFunc, 1
; main loop
; main loop

arr str lookIntoTheNextLineForFuncWhitNoKeyWord
Loop, Parse, code, `n, `r
{
lookIntoTheNextLineForFuncWhitNoKeyWord.add(A_LoopField)
}
lookIntoTheNextLineForFuncWhitNoKeyWord.add(" ")






htCode := ""
print("=======UP==========")
print(code)
print("=======DOWN==========")
Loop, Parse, code, `n, `r
{
lineDone := 0
if (A_LoopField = "qWERDEW3ERE QOWES FSjw sfdfouwae pawi")
{
htCode .= "ASFSEDF`n"
}
else if (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite)) or (StrLower(A_LoopField) = StrLower(keyWordLoopInfinite . ":"))
{
; infinity loops
haveWeEverUsedAloop := 1
lineDone := 1

if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , value in enumerate(iter(int, 1), start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; ; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", someLimit do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit)"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit:"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop"
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< someLimit"
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < someLimit; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to someLimit)"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . "..someLimit)"
}



nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
lineDone := 1
if (langToConvertTo != "ahk")
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop))) = StrLower(keyWordLoop)) and (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) != StrLower(keyWordLoop) . "% ") and (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoopParse))) != StrLower(keyWordLoopParse))
{
out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop))
out2 := StrReplace(out2, ":", "")
;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ":"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop, " . line 
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< " . line . " + " . AHKlikeLoopsIndexedAt
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to " . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
if (langToConvertTo != "ahk")
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(Trim(StrLower(A_LoopField)), 1, StrLen(StrLower(keyWordLoop)) + 2) = StrLower(keyWordLoop) . "% ")
{

out2 := StringTrimLeft(A_LoopField, StrLen(keyWordLoop) + 2)
out2 := StrReplace(out2, ":", "")

;MsgBox % out2

;MsgBox, % out2
out2 := Trim(out2)


myVar := out2
lineYGI := expressionParserTranspiler(myVar)
line := lineYGI
haveWeEverUsedAloop := 1
;MsgBox, % line



if (langToConvertTo = "py")
{
var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in range(" . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " := " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++"
}
if (langToConvertTo = "lua")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . ", " . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "cs")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "java")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "kt")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "rb")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . " do"
}
if (langToConvertTo = "nim")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ":"
}
if (langToConvertTo = "ahk")
{
    var1 := "Loop, % " . line 
}
if (langToConvertTo = "swift")
{
    var1 := "for " . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . " ..< " . line . " + " . AHKlikeLoopsIndexedAt
}
if (langToConvertTo = "dart")
{
    var1 := "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1 := "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < " . line . " + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- " . AHKlikeLoopsIndexedAt . " to " . line . " + " . AHKlikeLoopsIndexedAt . ")"
}
if (langToConvertTo = "groovy")
{
    var1 := "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " in " . AHKlikeLoopsIndexedAt . ".." . line . " + " . AHKlikeLoopsIndexedAt . ")"
}

nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

htCodeAcurlyBraceAddSomeVrasFixNL := 1
if (langToConvertTo != "ahk")
{
htCodeLoopfixa .= "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "nl|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
lineDone := 1
htCode .= htCodeLoopfixa1 . "`n" . var1 . "`n"
}
else if (SubStr(StrLower(A_LoopField), 1, StrLen(StrLower(keyWordLoopParse))) = StrLower(keyWordLoopParse))
{
var1 := StringTrimLeft(A_LoopField, StrLen(keyWordLoopParse))
out2 := StrReplace(out2, ":", "")
lineDone := 1

line1 := Trim(StrSplit(var1, ",", 1))

line1 := expressionParserTranspiler(line1)
line2 := ""
line3 := ""
itemsOut := ""
line2 := Trim(StrSplit(var1, ",", 2))
line3 := Trim(StrSplit(var1, ",", 3))



if (InStr(var1, keyWordEscpaeChar . ","))
{
line2 := Chr(34) . "," . Chr(34)


if (langToConvertTo = "py")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}

}
else
{


if (line2 = "") and (line3 = "")
{
; nothing so only each char
if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ")"
}



}

if (line2 != "") and (line3 = "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}

if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ")"
}



}

if (line2 != "") and (line3 != "")
{
if (InStr(line2, keyWordEscpaeChar))
{
line2 := Chr(34) . line2 . Chr(34)
}
if (InStr(line3, keyWordEscpaeChar))
{
line3 := Chr(34) . line3 . Chr(34)
}

if (langToConvertTo = "py") or (langToConvertTo = "js")
{
itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "cpp")
{
itemsOut := "std::vector<std::string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}


if (langToConvertTo = "go")
{
    itemsOut := "items" . STR(AindexcharLength) . " := LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "lua")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "cs")
{
    itemsOut := "List<string> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}
if (langToConvertTo = "java")
{
    itemsOut := "List<String> items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ");"
}
if (langToConvertTo = "kt")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "rb")
{
    itemsOut := "items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "nim")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "ahk")
{
    itemsOut := "`n"
    
}
if (langToConvertTo = "swift")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "dart")
{
    itemsOut := "var items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "ts")
{
    itemsOut := "let items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "scala")
{
    itemsOut := "val items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}
if (langToConvertTo = "groovy")
{
    itemsOut := "def items" . STR(AindexcharLength) . " = LoopParseFunc(" . line1 . ", " . line2 . ", " . line3 . ")"
}

}



itemsOut := StrReplace(itemsOut, keyWordEscpaeChar, Chr(92))



}



if (langToConvertTo = "py")
{
var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in enumerate(items" . STR(AindexcharLength) . ", start=" . AHKlikeLoopsIndexedAt . "):"
}
if (langToConvertTo = "js")
{
var1out := itemsOut . "`n" . "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "cpp")
{
var1out := itemsOut . "`n" . "for (size_t " . keyWordAIndex . "" . STR(AindexcharLength) . " = " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".size() + " . AHKlikeLoopsIndexedAt . "; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}

if (langToConvertTo = "go")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " := range(items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "lua")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in ipairs(items" . STR(AindexcharLength) . ") do"
}
if (langToConvertTo = "cs")
{
    var1out := itemsOut . "`n" . "foreach (var " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "java")
{
    var1out := itemsOut . "`n" . "for (" . keyWordALoopField . "" . STR(AindexcharLength) . " : items" . STR(AindexcharLength) . ")"
}
if (langToConvertTo = "kt")
{
    var1out := itemsOut . "`n" . "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . ".withIndex())"
}
if (langToConvertTo = "rb")
{
    var1out := itemsOut . "`n" . "items" . STR(AindexcharLength) . ".each_with_index do |" . keyWordALoopField . "" . STR(AindexcharLength) . " , " . keyWordAIndex . "" . STR(AindexcharLength) . "|"
}
if (langToConvertTo = "nim")
{
    var1out := itemsOut . "`n" . "for " . keyWordAIndex . "" . STR(AindexcharLength) . " , " . keyWordALoopField . "" . STR(AindexcharLength) . " in items" . STR(AindexcharLength) . " | " . keyWordAIndex . "" . STR(AindexcharLength) . " += 1:"
}
if (langToConvertTo = "ahk")
{
    var1out := "Loop, Parse, " . line1 . " " . line2 . " " . line3
}
if (langToConvertTo = "swift")
{
    var1out := itemsOut . "`n" . "for (index, " . keyWordALoopField . "" . STR(AindexcharLength) . ") in items" . STR(AindexcharLength) . ".enumerated()"
}
if (langToConvertTo = "dart")
{
    var1out := itemsOut . "`n" . "for (int " . keyWordAIndex . "" . STR(AindexcharLength) . " = 0; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "ts")
{
    var1out := itemsOut . "`n" . "for (let " . keyWordAIndex . "" . STR(AindexcharLength) . " = 0; " . keyWordAIndex . "" . STR(AindexcharLength) . " < items" . STR(AindexcharLength) . ".length; " . keyWordAIndex . "" . STR(AindexcharLength) . "++)"
}
if (langToConvertTo = "scala")
{
    var1out := itemsOut . "`n" . "for (" . keyWordAIndex . "" . STR(AindexcharLength) . " <- items" . STR(AindexcharLength) . ".indices)"
}
if (langToConvertTo = "groovy")
{
    var1out := itemsOut . "`n" . "items" . STR(AindexcharLength) . ".eachWithIndex { " . keyWordALoopField . "" . STR(AindexcharLength) . " , " . keyWordAIndex . "" . STR(AindexcharLength) . " ->"
}



nothing := ""
AindexcharLengthStr := nothing . STR(AindexcharLength) . nothing

;
;
theFixTextLoopLP := ""
if (langToConvertTo = "cpp")
{
theFixTextLoopLP := "std::string " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}
if (langToConvertTo = "js")
{
theFixTextLoopLP := "const " . keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "];"
}
if (langToConvertTo = "go")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " := items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "lua")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "cs")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "java")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "kt")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "rb")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "nim")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "ahk")
{
    theFixTextLoopLP := "`n"
}
if (langToConvertTo = "swift")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "dart")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "ts")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "scala")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}
if (langToConvertTo = "groovy")
{
    theFixTextLoopLP := keyWordALoopField . "" . AindexcharLengthStr . " = items" . AindexcharLengthStr . "[" . keyWordAIndex . "" . AindexcharLengthStr . " - " . AHKlikeLoopsIndexedAt . "]"
}


htCodeAcurlyBraceAddSomeVrasFixLP := 1
haveWeEverUsedAloop := 1
if (langToConvertTo != "ahk")
{
htCodeLoopfixa .= "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength) . "`n"
htCodeLoopfixa1 := "lp|itsaersdtgtgfergsdgfsegdfsedAA|" . STR(AindexcharLength)
}
AindexcharLength++
htCode .= htCodeLoopfixa1 . "`n" . var1out . "`n"





}
else if ((SubStr(Trim(A_LoopField), -2) = ");") or (SubStr(Trim(A_LoopField), -1) = ")")) and (!(InStr(A_LoopField, "int main(int argc, char* argv[])"))) and (!(InStr(A_LoopField, "async function main()"))) and (lineDone = 0)
{
lineDone := 1
str1 := A_LoopField
if (langToConvertTo = "py") or (langToConvertTo = "nim") or (langToConvertTo = "ahk") or (langToConvertTo = "go") or (langToConvertTo = "lua") or (langToConvertTo = "kt") or (langToConvertTo = "rb") or (langToConvertTo = "swift") or (langToConvertTo = "scala") or (langToConvertTo = "groovy") 
{
str1 := StrReplace(str1, ";", "")
}



str2 := expressionParserTranspiler(Trim(str1)) . ";"
if (langToConvertTo = "py") or (langToConvertTo = "nim") or (langToConvertTo = "ahk") or (langToConvertTo = "go") or (langToConvertTo = "lua") or (langToConvertTo = "kt") or (langToConvertTo = "rb") or (langToConvertTo = "swift") or (langToConvertTo = "scala") or (langToConvertTo = "groovy") 
{
str2 := StrReplace(str2, ";", "")
}
else
{
str2 := StrReplace(str2, ";;", ";")
}
htCode .= str2 . "`n"
}
else
{
;print("else else else " . A_LoopField)
; this is THE else
if (lineDone != 1)
{
if (skipLeftCuleyForFuncPLS != 1)
{
if (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(125))
{
htCode .= Chr(125) . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixLP = 1) and (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixLP := 0


htCode .= A_LoopField . "`n" . theFixTextLoopLP . "`n"
}
else
{
if (htCodeAcurlyBraceAddSomeVrasFixNL = 1) and (SubStr(Trim(StrLower(A_LoopField)), 1, 1) = Chr(123))
{
htCodeAcurlyBraceAddSomeVrasFixNL := 0
htCode .= A_LoopField . "`n" . theFixTextLoopNL . "`n"
}
else
{
htCode .= A_LoopField . "`n"
}
}
}
}
else
{
skipLeftCuleyForFuncPLS := 0
}
}
}

}
StringTrimRight, htCode, htCode, 1



















;s
;s
;s
if (langToConvertTo != "ahk")
{

;s

if (haveWeEverUsedAloop = 1)
{

StringTrimRight, htCodeLoopfixa, htCodeLoopfixa, 1

;OutputDebug, |%htCodeLoopfixa%|
AIndexLoopCurlyFix := 1
Loop, Parse, htCodeLoopfixa, `n, `r
{



sstr123 := A_LoopField
fixLoopLokingFor := A_LoopField
fixLoopLokingForfound := 1
out1 := StrSplit(sstr123 ,"|" , 1)
out2 := StrSplit(sstr123 ,"|" , 3)
;OutputDebug, |%out1%|
;OutputDebug, |%out2%|



wasAtanyIfsElseAddAIndexLoopCurlyFix := 0


if (out1 = "nl")
{

inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{
;MsgBox, dsfgsdefgesrdg1
;MsgBox, |%A_LoopField%|`n|%fixLoopLokingFor%|


if (InStr(A_LoopField, fixLoopLokingFor)) and (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1

;MsgBox, do we came here 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (weAreDoneHereCurly != 1) and (insdeAnestedLoopBAD != 1) and (fixLoopLokingForNum = 1)
{

s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s


s := StrSplit(out1z, " ", 1)
out1z := Trim(s)


;MsgBox, % out1z

;MsgBox, do we came here 2
fixLoopLokingForNum := 0
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField


DeleayOneCuzOfLoopParse := 1


out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(125))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (insdeAnestedLoopBAD != 1) and (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) and (readyToEnd1 = 1) and (netsedCurly1 = 0) and (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}

out4758686d86d86d86578991a .= A_LoopField . "`n"
}


if (inTarget = 1) and (dontSaveStr != 1) and (fixLoopLokingForNum != 1) and (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField




; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\d*", "" . keyWordAIndex . "" . out1z)




out4758686d86d86d86578991a .= ALoopField . "`n"

}


if (inTarget = 1) and (InStr(A_LoopField, Chr(125))) and (readyToEnd = 1) and (netsedCurly = 0) and (weAreDoneHereCurly = 0) and (dontSaveStr != 1) and (insdeAnestedLoopBAD != 1)
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) and (endBracketDOntPutThere != 1) and (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}
else
{


inTarget := 0
insideBracket := 0
netsedCurly := 0
eldLoopNestedBADlol := 0
readyToEnd := 0
endBracketDOntPutThere := 0
dontSaveStr := 0
weAreDoneHereCurly := 0
DeleayOneCuzOfLoopParse := 0
fixLoopLokingForNum := 0
insdeAnestedLoopBAD := 0
foundTheTopLoop := 0
out4758686d86d86d86578991a := ""

Loop, Parse, htCode, `n, `r
{

if (InStr(A_LoopField , fixLoopLokingFor)) and (insdeAnestedLoopBAD != 1)
{
fixLoopLokingForNum := 1
;MsgBox, do we came here 3
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (weAreDoneHereCurly != 1) and (insdeAnestedLoopBAD != 1) and (fixLoopLokingForNum = 1)
{


s := StrSplit(A_LoopField ,"" . keyWordAIndex . "", 2)
out1z := s

s := StrSplit(out1z, " ", 1)
out1z := Trim(s)

;MsgBox, % out1z

fixLoopLokingForNum := 0
;MsgBox, do we came here 4
foundTheTopLoop++
inTarget := 1
;MsgBox, % A_LoopField
dontSaveStr := 1

ALoopField := A_LoopField

DeleayOneCuzOfLoopParse := 1

out4758686d86d86d86578991a .= ALoopField . "`n"
}

if (inTarget = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
insideBracket := 1
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(123))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly++
}

if (insideBracket = 1) and (InStr(A_LoopField, Chr(125))) and (insdeAnestedLoopBAD != 1)
{
netsedCurly--
readyToEnd := 1
}

if (SubStr(Trim(A_LoopField), 1, 4) = "for ") and (insdeAnestedLoopBAD != 1) and (foundTheTopLoop >= 2)
{
insdeAnestedLoopBAD := 1
insideBracket1 := 0
netsedCurly1 := 0
}
if (inTarget = 1)
{
foundTheTopLoop++
}
if (insdeAnestedLoopBAD = 1)
{



if (InStr(A_LoopField, Chr(123)))
{
insideBracket1 := 1
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(123)))
{
netsedCurly1++
}

if (insideBracket1 = 1) and (InStr(A_LoopField, Chr(125)))
{
netsedCurly1--
readyToEnd1 := 1
}


if (InStr(A_LoopField, Chr(125))) and (readyToEnd1 = 1) and (netsedCurly1 = 0) and (insideBracket = 1)
{
;MsgBox, % A_LoopField
eldLoopNestedBADlol := 1

}


out4758686d86d86d86578991a .= A_LoopField . "`n"

}


if (inTarget = 1) and (dontSaveStr != 1) and (fixLoopLokingForNum != 1) and (insdeAnestedLoopBAD != 1)
{

ALoopField := A_LoopField

; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordAIndex . "\d*", "" . keyWordAIndex . "" . out1z)
; Replace "A_Index" with or without a following digit with "A_Index" + out1z
ALoopField := RegExReplace(ALoopField, "" . keyWordALoopField . "\d*", "" . keyWordALoopField . "" . out1z)





out4758686d86d86d86578991a .= ALoopField . "`n"

}


if ((inTarget = 1) and (InStr(A_LoopField, Chr(125))) and (readyToEnd = 1) and (netsedCurly = 0) and (weAreDoneHereCurly = 0) and (dontSaveStr != 1) and (insdeAnestedLoopBAD != 1))
{
;MsgBox, % A_LoopField
weAreDoneHereCurly := 1
inTarget := 0
endBracketDOntPutThere := 1

}
dontSaveStr := 0

if (inTarget != 1) and (endBracketDOntPutThere != 1) and (insdeAnestedLoopBAD != 1)
{

out4758686d86d86d86578991a .= A_LoopField . "`n"

}
endBracketDOntPutThere := 0

if (eldLoopNestedBADlol = 1)
{
insdeAnestedLoopBAD := 0
}


}

strstysrstsytTRIMHELP := out4758686d86d86d86578991a
StringTrimRight, strstysrstsytTRIMHELP, strstysrstsytTRIMHELP, 1



htCode := strstysrstsytTRIMHELP

;MsgBox, % htCode
wasAtanyIfsElseAddAIndexLoopCurlyFix := 1
}

if (wasAtanyIfsElseAddAIndexLoopCurlyFix = 1)
{
AIndexLoopCurlyFix++
wasAtanyIfsElseAddAIndexLoopCurlyFix := 0
}
}


out4758686d86dgt8r754444444 := ""
hold := 0
Loop, Parse, htCode, `n, `r
{
ignore := 0
if (SubStr(Trim(A_LoopField), 1, 4) = "for ")
{
if (hold = 1) and (holdText = A_LoopField)
{
ignore := 1
}
else
{
holdText := A_LoopField
hold := 1
}
}

if (!ignore)
{
out4758686d86dgt8r754444444 .= A_LoopField . "`n"
}
}

StringTrimRight, out4758686d86dgt8r754444444, out4758686d86dgt8r754444444, 1
htCode := out4758686d86dgt8r754444444


}


htCodeOut1234565432 := ""
Loop, Parse, htCode, `n, `r
{
out := A_LoopField
if (!InStr(out, "|itsaersdtgtgfergsdgfsegdfsedAA|"))
{
htCodeOut1234565432 .= out . "`n"
}
}


StringTrimRight, htCode, htCodeOut1234565432, 1








}










if (langToConvertTo = "py") or (langToConvertTo = "nim")
{
htCode := indent_nested_curly_braces(htCode, 0)
}
else
{
htCode := indent_nested_curly_braces(htCode, 1)
}


str fixLuaAndRuby := ""
if (langToConvertTo = "lua") or (langToConvertTo = "rb")
{

    Loop, Parse, htCode, `n, `r
    {
        if (Trim(A_LoopField) = "}")
        {
            fixLuaAndRuby .= StrReplace(A_LoopField, "}", "end") . "`n"
        }
        else if (SubStrLastChars(A_LoopField, 2) = " {")
        {
            fixLuaAndRuby .= StringTrimRight(A_LoopField, 2) . "`n"
        }
        else
        {
            fixLuaAndRuby .= A_LoopField . "`n"
        }
    }
    StringTrimRight, htCode, fixLuaAndRuby, 1
}










areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0

str funcLangHolder := ""
str funcNameHolder := ""
str funcLibsHolder := ""
str funcFuncHolder := ""
str funcDescriptionHolder := ""

arr str allFuncLang
arr str allFuncNames
arr str allFuncLibs
arr str allFuncs
arr str allfuncDescription


int correctLang := 0
Loop, Parse, instructions, `n, `r
{
if (Trim(A_LoopField) = "funcEND======================funcEND==============")
{
areWeInAFuncFromInstructions := 0
areWeInAFuncFromInstructionsLineNum := 0
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
;MsgBox, % funcFuncHolder
allFuncs.add(funcFuncHolder)
}
correctLang := 0
funcFuncHolder := ""
}

if (areWeInAFuncFromInstructions = 1)
{

if (areWeInAFuncFromInstructionsLineNum = 1)
{
; name of the func
StringTrimLeft, funcLangHolder, A_LoopField, 5
if (Trim(funcLangHolder) = langToConvertTo)
{
allFuncLang.add(Trim(funcLangHolder))
correctLang := 1
}
}
if (areWeInAFuncFromInstructionsLineNum = 2)
{
; name of the func
StringTrimLeft, funcNameHolder, A_LoopField, 5
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allFuncNames.add(Trim(funcNameHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum = 3)
{
; all libs
StringTrimLeft, funcLibsHolder, A_LoopField, 5
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allFuncLibs.add(Trim(funcLibsHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum = 4)
{
; func description
StringTrimLeft, funcDescriptionHolder, A_LoopField, 12
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
allfuncDescription.add(Trim(funcDescriptionHolder))
}
}
if (areWeInAFuncFromInstructionsLineNum >= 5)
{
; the full func
if (correctLang = 1) and (InStr(htCode, Trim(funcNameHolder)))
{
funcFuncHolder .= A_LoopField . "`n"
}
}

;MsgBox, % A_LoopField

areWeInAFuncFromInstructionsLineNum++
}


if (Trim(A_LoopField) = "func======================func==============")
{
areWeInAFuncFromInstructions := 1
areWeInAFuncFromInstructionsLineNum := 1
correctLang := 0
}



}

;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncNames
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLibs
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncLang
;~ MsgBox, ===========================================================================
;~ msgbox, % allFuncs
;~ MsgBox, ===========================================================================





if (langToConvertTo = "cpp")
{
htCode := htCode . "`n    return 0;`n}"
htCode := StrReplace(htCode, "int main(int argc, char* argv[]);", "int main(int argc, char* argv[])")
}
if (langToConvertTo = "js") and (useJavaScriptAmainFuncDef = "on")
{
htCode := htCode . "`n}`nmain();"
htCode := StrReplace(htCode, "async function main();", "async function main()")
htCode := StrReplace(htCode, "function async function main()", "async function main()")
}


if (langToConvertTo = "ts") and (useJavaScriptAmainFuncDef = "on")
{
    htCode := htCode . "`n}`nmain();"
    htCode := StrReplace(htCode, "async function main(): Promise<void>;", "async function main(): Promise<void>")
    htCode := StrReplace(htCode, "function async function main(): Promise<void>", "async function main(): Promise<void>")
}

if (langToConvertTo = "go")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "func main();", "func main()")
}

if (langToConvertTo = "cs")
{
    htCode := htCode . "`n    }`n}"
    htCode := StrReplace(htCode, "static void Main(string[] args);", "static void Main(string[] args)")
}

if (langToConvertTo = "java")
{
    htCode := htCode . "`n    }`n}"
    htCode := StrReplace(htCode, "public static void main(String[] args);", "public static void main(String[] args)")
}

if (langToConvertTo = "kt")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "fun main(args: Array<String>);", "fun main(args: Array<String>)")
}

if (langToConvertTo = "swift")
{
    htCode := htCode . "`n}`nmain()"
    htCode := StrReplace(htCode, "func main();", "func main()")
}

if (langToConvertTo = "dart")
{
    htCode := htCode . "`n}"
    htCode := StrReplace(htCode, "void main(List<String> arguments);", "void main(List<String> arguments)")
}

if (langToConvertTo = "scala")
{
    htCode := htCode . "`n    }`n}"

}


str jsHTMLdownCode := "</script>`n</body>`n</html>"

int includeLibsInCppIf := 0

str allFuncsToPutAtTop := "`n"
str allLibsToPutAtTop

if (!(allFuncNames.size() <= 0))
{
Loop, % allFuncNames.size()
{
if (InStr(htCode, allFuncNames[A_Index]) . "(")
{
;MsgBox, % allFuncNames[A_Index]

allFuncsToPutAtTop .= allFuncs[A_Index] . "`n"

if (Trim(allFuncLibs[A_Index]) != "null")
{
allLibsToPutAtTop .= allFuncLibs[A_Index] . "|"
}

}
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTop, 1

str allLibsToPutAtTopTEMP
Loop, Parse, allLibsToPutAtTop, "|"
{
allLibsToPutAtTopTEMP .= A_LoopField . "`n"
}
StringTrimRight, allLibsToPutAtTop, allLibsToPutAtTopTEMP, 1

includeLibsInCppIf := 1

if (langToConvertTo = "cpp")
{
allLibsToPutAtTop := "#include <iostream>`n#include <sstream>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n#include <any>`n#include <optional>`n" . allLibsToPutAtTop
}

Sort, allLibsToPutAtTop, U

allLibsToPutAtTop := StrReplace(allLibsToPutAtTop, "~", "`n")

if (langToConvertTo != "js")
{
htCode := allLibsToPutAtTop . "`n" . allFuncsToPutAtTop . "`n" . htCode
}
else
{
htCode := "`n" . allFuncsToPutAtTop . "`n" . htCode
}

}







if (langToConvertTo = "cs")
{
    htCode := "class Program`n{`n" . htCode
}
if (langToConvertTo = "java")
{
    htCode := "public class Main`n{`n" . htCode
}

if (langToConvertTo = "scala")
{
    htCode := "object MainApp`n{`n" . htCode
}

if (langToConvertTo = "go")
{
    htCode := "package main`nimport (`n" . htCode
}





Loop, % theIdNumOfThe34
{
if (theIdNumOfThe34 = A_Index + 1)
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1] . Chr(34))
}
else
{
htCode := StrReplace(htCode, "ihuiuuhuuhtheidFor-asdsas-theuhturtyphoutr-" . Chr(65) . Chr(65) . STR(A_Index + 1) . Chr(65) . Chr(65), theIdNumOfThe34theVar[A_Index + 1])
}
}

htCode := StrReplace(htCode, ReplaceFixWhitOutFixDoubleQuotesInsideDoubleQuotes, Chr(92) . Chr(34))


htCode := StrReplace(htCode, "std::string(" . Chr(34) . Chr(34) . ";),", "std::string(" . Chr(34) . Chr(34) . "),")








str jsHTMLupCode := "<!doctype html>`n<html lang=" . Chr(34) . "en" . Chr(34) . ">`n    <head>`n        <meta charset=" . Chr(34) . "UTF-8" . Chr(34) . " />`n        <meta name=" . Chr(34) . "viewport" . Chr(34) . " content=" . Chr(34) . "width=device-width, initial-scale=1.0" . Chr(34) . " />`n        <title>HTVM</title>`n        <style>`n            body {`n                background-color: #202020;`n                font-family:`n                    " . Chr(34) . "Open Sans" . Chr(34) . ",`n                    -apple-system,`n                    BlinkMacSystemFont,`n                    " . Chr(34) . "Segoe UI" . Chr(34) . ",`n                    Roboto,`n                    Oxygen-Sans,`n                    Ubuntu,`n                    Cantarell,`n                    " . Chr(34) . "Helvetica Neue" . Chr(34) . ",`n                    Helvetica,`n                    Arial,`n                    sans-serif;`n            }`n        </style>`n" . allLibsToPutAtTop . "`n</head>`n    <body>`n<script>"



if (useJavaScriptInAfullHTMLfile = "on") and (langToConvertTo = "js")
{
htCode := jsHTMLupCode . "`n" . htCode . "`n" . jsHTMLdownCode
}

if (langToConvertTo = "cpp") and (includeLibsInCppIf = 0)
{
htCode := "#include <iostream>`n#include <sstream>`n#include <any>`n#include <string>`n#include <cstdint>`n#include <algorithm>`n#include <vector>`n`n" . htCode
}
if (langToConvertTo = "cs")
{
htCode := "using System;`n" . htCode
}
if (langToConvertTo = "ahk")
{
htCode := "#EscapeChar \`n" . htCode
}







print(htCode)
return htCode
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

func void HTVMv2()
{
global allArgs
str argCODE := ""
str argCODEfile := ""
str argHTVMinstr := ""
str argLangTo := ""
str OUTCODE := "null"

HTVM_v2_HTVM()

if (noParams = true)
{
return
}

Loop, Parse, str0
{
str00 := Trim(A_LoopField)
StringTrimRight, str00, str00, 1
}


print("HTVM v2")
if (HTVM_getLang_HTVM() = "cpp") or (HTVM_getLang_HTVM() = "py")
{

if (HTVM_getLang_HTVM() = "cpp")
{
print("CPP")
}
if (HTVM_getLang_HTVM() = "py")
{
print("PY")
}


Loop, Parse, allArgs, `n, `r
{
if (A_Index = 0)
{
argCODE := FileRead(Trim(A_LoopField))
argCODEfile := Trim(A_LoopField)
}
else if (A_Index = 1)
{
argHTVMinstr := Trim(A_LoopField)
}
else if (A_Index = 2)
{
argLangTo := Trim(A_LoopField)
}
else
{
argHTVMinstrMOVE.add(Trim(A_LoopField))
}
}

print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
if (SubStrLastChars(argCODEfile, 4) = ".cpp") or (SubStrLastChars(argCODEfile, 3) = ".py") or (SubStrLastChars(argCODEfile, 3) = ".js") or (SubStrLastChars(argCODEfile, 3) = ".go") or (SubStrLastChars(argCODEfile, 4) = ".lua") or (SubStrLastChars(argCODEfile, 3) = ".cs") or (SubStrLastChars(argCODEfile, 5) = ".java") or (SubStrLastChars(argCODEfile, 3) = ".kt") or (SubStrLastChars(argCODEfile, 3) = ".rb") or (SubStrLastChars(argCODEfile, 4) = ".nim") or (SubStrLastChars(argCODEfile, 4) = ".ahk") or (SubStrLastChars(argCODEfile, 6) = ".swift") or (SubStrLastChars(argCODEfile, 5) = ".dart") or (SubStrLastChars(argCODEfile, 3) = ".ts") or (SubStrLastChars(argCODEfile, 6) = ".scala") or (SubStrLastChars(argCODEfile, 7) = ".groovy")
{

if (argLangTo != "")
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM", argLangTo)
}
else
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "notHTVM")
}
}
else
{


if (argLangTo != "")
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "full", argLangTo)
}
else
{
OUTCODE := compiler(argCODE, Trim(FileRead(argHTVMinstr)), "full")
}
}   


print(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)


if (langToConvertTo = "js") and (useJavaScriptInAfullHTMLfile = "on")
{
FileDelete(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . "html")
FileAppend(OUTCODE, StringTrimRight(argCODEfile, StrLen(langFileExtension)) . "html")
}
else
{
FileDelete(StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
FileAppend(OUTCODE, StringTrimRight(argCODEfile, StrLen(langFileExtension)) . langToConvertTo)
}


}

if (HTVM_getLang_HTVM() = "js")
{
print("JS")
}
}

main
HTVMv2()
