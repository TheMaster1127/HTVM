htvm
htvm2
StringTrimLeft,OUTVAR,INVAR,param1|StringTrimRight,OUTVAR,INVAR,param1|Random,OUTVAR,param1,param2|Sleep,INVAR|FileRead,OUTVAR,'param1|FileAppend,INVAR,'param1|FileDelete,'INVAR|Sort,INOUTVAR,'param1|MsgBox,'param1
alliance
crew
proc
struct
prop
this
import
___start
___end
___cpp start
___cpp end
___py start
___py end
___js start
___js end
___go start
___go end
___lua start
___lua end
___cs start
___cs end
___java start
___java end
___kt start
___kt end
___rb start
___rb end
___nim start
___nim end
___ahk start
___ahk end
___swift start
___swift end
___dart start
___dart end
___ts start
___ts end
___groovy start
___groovy end
___htvm start
___htvm end
___inhtvm start
___inhtvm end
{
}
null
true
false
void
double
char
uint8
uint16
uint32
uint64
int
str
bool
float
int8
int16
int32
int64
if
else if
else
while
Loop
Loop,
Loop, Parse,
continue
break
func
await
async
throw
ErrorMsg
try
catch
finally
return
.add
.pop
.size
.insert
.rm
.indexOf
arr
arr int
arr str
arr float
arr bool
var
let
const
end
global
;
'''1
'''2
`
main
.
+
-
*
/
%
**
=
===
!=
>
<
>=
<=
and
or
!
&
|
^
~
<<
>>
>>>
:=
+=
.=
-=
*=
/=
%=
<<=
>>=
>>>=
&=
|=
^=
?
:
++
--
0
A_Index
A_LoopField
on
off
off
on
on
off
off
off
on
off
off
on
off


func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null

// add the function here

funcEND======================funcEND==============



func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null
// add the function here
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: HTVM_func1
libs: null
description: null
// add the function here
funcEND======================funcEND==============
func======================func==============
lang: lua
name: infinite_HTVM_Lua_Loop_HTVM
libs: null
description: null
function infinite_HTVM_Lua_Loop_HTVM()
    local i = 0
    return function()
        i = i + 1
        return i
    end
end
funcEND======================funcEND==============

func======================func==============
lang: cs
name: ResetList
libs: null
description: null
    // Dynamic function to reset lists, detects type and returns an empty list of the same type
    static dynamic ResetList(dynamic arr)
    {
        // Get the type of the elements in the list
        Type elementType = arr.GetType().GetGenericArguments()[0];

        // Create a new empty list of the same type and return it
        Type listType = typeof(List<>).MakeGenericType(elementType);
        return Activator.CreateInstance(listType);
    }
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: LoopParseFunc
libs: #include <vector>|#include <string>|#include <regex>
description: null
// Function to escape special characters for regex
std::string escapeRegex(const std::string& str) {
    static const std::regex specialChars{R"([-[\]{}()*+?.,\^$|#\s])"};
    return std::regex_replace(str, specialChars, R"(\$&)");
}
// Function to split a string based on delimiters
std::vector<std::string> LoopParseFunc(const std::string& var, const std::string& delimiter1 = "", const std::string& delimiter2 = "") {
    std::vector<std::string> items;
    if (delimiter1.empty() && delimiter2.empty()) {
        // If no delimiters are provided, return a list of characters
        for (char c : var) {
            items.push_back(std::string(1, c));
        }
    } else {
        // Escape delimiters for regex
        std::string escapedDelimiters = escapeRegex(delimiter1 + delimiter2);
        // Construct the regular expression pattern for splitting the string
        std::string pattern = "[" + escapedDelimiters + "]+";
        std::regex regexPattern(pattern);
        std::sregex_token_iterator iter(var.begin(), var.end(), regexPattern, -1);
        std::sregex_token_iterator end;
        while (iter != end) {
            items.push_back(*iter++);
        }
    }
    return items;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: LoopParseFunc
libs: import re
description: null
def LoopParseFunc(var, delimiter1="", delimiter2=""):
    if not delimiter1 and not delimiter2:
        # If no delimiters are provided, return a list of characters
        items = list(var)
    else:
        # Construct the regular expression pattern for splitting the string
        pattern = r'[' + re.escape(delimiter1) + re.escape(delimiter2) + r']+'
        # Split the string using the constructed pattern
        items = re.split(pattern, var)
    return items
funcEND======================funcEND==============

func======================func==============
lang: go
name: LoopParseFunc
libs: "regexp"
description: null
func LoopParseFunc(varString string, delimiter1 string, delimiter2 string) []string {
    var items []string
    if delimiter1 == "" && delimiter2 == "" {
        // If no delimiters are provided, convert string to slice of strings
        items = make([]string, len(varString))
        for i, c := range varString {
            items[i] = string(c)
        }
    } else {
        // Construct the regular expression pattern for splitting the string
        pattern := fmt.Sprintf("[%s%s]+", delimiter1, delimiter2)
        // Split the string using the constructed pattern
        items = regexp.MustCompile(pattern).Split(varString, -1)
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString, delimiter1, delimiter2)
    local items = {}
    delimiter1 = delimiter1 or ""
    delimiter2 = delimiter2 or ""

    -- Changed: Don't escape the delimiters since we want them literal
    -- Just use them directly in the pattern
    if delimiter1 == "" and delimiter2 == "" then
        for i = 1, #varString do
            table.insert(items, varString:sub(i, i))
        end
    else
        -- Changed: Simplified pattern to directly match \n and \r
        local pattern = delimiter1 .. delimiter2
        for item in varString:gmatch("([^" .. pattern .. "]+)") do
            table.insert(items, item)
        end
    end
    return items
end
funcEND======================funcEND==============


func======================func==============
lang: cs
name: LoopParseFunc
libs: using System.Linq;|using System.Text.RegularExpressions;
description: null
    public static string[] LoopParseFunc(string varString, string delimiter1 = "", string delimiter2 = "")
    {
        string[] items;
        if (string.IsNullOrEmpty(delimiter1) && string.IsNullOrEmpty(delimiter2))
        {
            // If no delimiters are provided, return an array of characters
            items = varString.ToCharArray().Select(c => c.ToString()).ToArray();
        }
        else
        {
            // Construct the regular expression pattern for splitting the string
            string pattern = "[" + Regex.Escape(delimiter1) + Regex.Escape(delimiter2) + "]+";
            // Split the string using the constructed pattern
            items = Regex.Split(varString, pattern);
        }
        return items;
    }
funcEND======================funcEND==============


func======================func==============
lang: java
name: LoopParseFunc
libs: null
description: null
    public static String[] LoopParseFunc(String varString, String delimiter1, String delimiter2) {
        String[] items;
        if (delimiter1.isEmpty() && delimiter2.isEmpty()) {
            // If no delimiters are provided, return an array of characters
            items = varString.split("");
        } else {
            // Construct the regular expression pattern for splitting the string
            String pattern = "[" + Pattern.quote(delimiter1) + Pattern.quote(delimiter2) + "]+";
            // Split the string using the constructed pattern
            items = varString.split(pattern);
        }
        return items;
    }

funcEND======================funcEND==============


func======================func==============
lang: kt
name: LoopParseFunc
libs: null
description: null
fun LoopParseFunc(varString: String, delimiter1: String = "", delimiter2: String = ""): List<String> {
    val items: MutableList<String> = mutableListOf()
    if (delimiter1.isEmpty() && delimiter2.isEmpty()) {
        // If no delimiters are provided, return a list of characters
        for (char in varString) {
            items.add(char.toString())
        }
    } else {
        // Construct the regular expression pattern for splitting the string
        val pattern = "[$delimiter1$delimiter2]+"
        // Split the string using the constructed pattern
        items.addAll(varString.split(Regex(pattern)))
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: rb
name: LoopParseFunc
libs: null
description: null
def LoopParseFunc(varString, delimiter1 = "", delimiter2 = "")
    items = []
    if delimiter1.empty? && delimiter2.empty?
        # If no delimiters are provided, return an array of characters
        items = varString.chars
    else
        # Construct the regular expression pattern for splitting the string
        pattern = "[#{delimiter1}#{delimiter2}]+"
        # Split the string using the constructed pattern
        items = varString.split(Regexp.new(pattern))
    end
    return items
end
funcEND======================funcEND==============


func======================func==============
lang: nim
name: LoopParseFunc
libs: import strutils
description: null

proc LoopParseFunc(varString: string, delimiter1: string = "", delimiter2: string = ""): seq[string] =
  var items: seq[string] = @[]

  if delimiter1.len == 0 and delimiter2.len == 0:
    # If no delimiters are provided, return a sequence of characters
    for i in 0..<varString.len:
      items.add($varString[i])
  else:
    if delimiter2.len == 0:
      # If only one delimiter is provided, use simple split
      items = varString.split(delimiter1)
    else:
      # If both delimiters are provided, first split by delimiter1
      let tempItems = varString.split(delimiter1)
      # Then split each item by delimiter2 if needed
      for item in tempItems:
        let subItems = item.split(delimiter2)
        for subItem in subItems:
          if subItem.len > 0:  # Only add non-empty items
            items.add(subItem)

  return items


funcEND======================funcEND==============


func======================func==============
lang: ahk
name: LoopParseFunc
libs: null
description: null
;LoopParseFunc

funcEND======================funcEND==============


func======================func==============
lang: swift
name: LoopParseFunc
libs: null
description: null
func LoopParseFunc(_ varString: String, _ delimiter1: String = "", _ delimiter2: String = "") -> [String] {
    var items: [String] = []

    // If no delimiters are provided, return an array of characters
    if delimiter1.isEmpty && delimiter2.isEmpty {
        items = Array(varString).map { String($0) }
    } else {
        // Use the first delimiter for splitting the string
        let delimiter = delimiter1.isEmpty ? delimiter2 : delimiter1
        items = varString.split(separator: Character(delimiter)).map { String($0) }
    }

    return items
}

funcEND======================funcEND==============


func======================func==============
lang: dart
name: LoopParseFunc
libs: null
description: null
List<String> LoopParseFunc(String varString, [String delimiter1 = "", String delimiter2 = ""]) {
    List<String> items = [];
    if (delimiter1.isEmpty && delimiter2.isEmpty) {
        // If no delimiters are provided, return a list of characters
        items.addAll(varString.split(''));
    } else {
        // Construct the regular expression pattern for splitting the string
        String pattern = "[$delimiter1$delimiter2]+";
        // Split the string using the constructed pattern
        items.addAll(varString.split(RegExp(pattern)));
    }
    return items;
}
funcEND======================funcEND==============


func======================func==============
lang: ts
name: LoopParseFunc
libs: null
description: null
function LoopParseFunc(varString: string, delimiter1: string = "", delimiter2: string = ""): string[] {
    let items: string[];
    if (delimiter1 === "" && delimiter2 === "") {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        const pattern = `[${delimiter1}${delimiter2}]+`;
        // Split the string using the constructed pattern
        items = varString.split(new RegExp(pattern));
    }
    return items;
}
funcEND======================funcEND==============




func======================func==============
lang: groovy
name: LoopParseFunc
libs: null
description: null
def LoopParseFunc(String varString, String delimiter1 = "", String delimiter2 = "") {
    def items = []
    if (delimiter1 == "" && delimiter2 == "") {
        // If no delimiters are provided, return an array of characters
        items = varString.toList()
    } else {
        // Construct the regular expression pattern for splitting the string
        def pattern = "[${delimiter1}${delimiter2}]"
        // Split the string using the constructed pattern
        items = varString.split(pattern)
    }
    return items
}
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: print
libs: #include <iostream>|#include <string>|#include <type_traits>
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for const char* specifically
void print(const char* value) {
    std::cout << std::string(value) << std::endl;  // Convert const char* to std::string
}
// Print function that converts all types to string if needed
template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
function print(value) {
    console.log(value)
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the
# used the print func
funcEND======================funcEND==============


func======================func==============
lang: go
name: print
libs: )|"fmt"
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
func print(value interface{}) {
    fmt.Println(value)
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
-- Print function for different types

funcEND======================funcEND==============

func======================func==============
lang: cs
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types

    public static void print(object value)
    {
        Console.WriteLine(value);
    }
funcEND======================funcEND==============

func======================func==============
lang: java
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types

    public static void print(Object value) {
        System.out.println(value);
    }

funcEND======================funcEND==============

func======================func==============
lang: kt
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types
fun print(value: Any) {
  println(value)
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
# Print function for various types

def print(value)
  if value.is_a?(String)
    puts value
  elsif value.is_a?(Numeric)
    puts value.to_s
  elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
    puts value ? "true" : "false"
  else
    puts "Unsupported type"
  end
end


funcEND======================funcEND==============

func======================func==============
lang: nim
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
# Print function for various types
proc print(value: auto) =  # Use 'auto' instead of 'untyped'
  echo value

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
; Print function for various types
print(value) {
    if IsObject(value) {
        str := ""
        for index, element in value
            str .= element ", "
        MsgBox % Trim(str, ", ")  ; Remove trailing comma and space
    } else {
        MsgBox % value
    }
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types



funcEND======================funcEND==============

func======================func==============
lang: dart
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types

funcEND======================funcEND==============

func======================func==============
lang: ts
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function for various types
function print(value: any): void {
    console.log(value);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: print
libs: null
description: io~~~print is a function that outputs the specified data to the console or standard output.~~~here is how the func looks like:~~~```htvm~~~print(str)~~~```~~~
// Print function
def print = { message ->
    System.out.print("$message\n\r")
}

funcEND======================funcEND==============


func======================func==============
lang: js
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
// Convert value to string
function STR(value) {
    if (value === null || value === undefined) {
        return ""; // Return a string for null or undefined
    } else if (typeof value === 'number') {
        return value.toString();
    } else if (typeof value === 'boolean') {
        return value ? "1" : "0";
    } else if (typeof value === 'string') {
        return value; // Return the string as is
    } else {
        // Handle any unexpected types gracefully
        return String(value); // Convert any other type to a string
    }
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: INT
libs: null
description: string~~~INT is a function that converts a value to an integer, throwing an error if the conversion fails.~~~here is how the func looks like:~~~```htvm~~~INT(str value)~~~```~~~
// Convert value to integer
function INT(value) {
    const intValue = parseInt(value, 10);
    if (Number.isNaN(intValue)) {
        console.warn(`Invalid input: ${value} cannot be converted to an integer.`);
        return 0;  // Or any other default value
    }
    return intValue;
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: FLOAT
libs: null
description: string~~~FLOAT is a function that converts a given value to a float and throws an error if the value cannot be converted.~~~here is how the func looks like:~~~```htvm~~~FLOAT(str value)~~~```~~~
// Convert value to float
function FLOAT(value) {
    const floatValue = parseFloat(value);
    if (isNaN(floatValue)) {
        throw new TypeError("Cannot convert to float");
    }
    return floatValue;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
# Convert value to string
def STR(value):
    if isinstance(value, (int, float)):
        return str(value)
    elif isinstance(value, bool):
        return "1" if value else "0"
    elif isinstance(value, str):
        return value  # If the value is already a string, return it as-is
    else:
        raise TypeError("Unsupported type")
funcEND======================funcEND==============
func======================func==============
lang: py
name: INT
libs: null
description: string~~~INT is a function that converts a value to an integer, throwing an error if the conversion fails.~~~here is how the func looks like:~~~```htvm~~~INT(str value)~~~```~~~
# Convert value to integer
def INT(value):
    try:
        # Try converting the value to an integer
        return int(float(value))
    except ValueError:
        # If conversion fails, raise a TypeError
        raise TypeError("Cannot convert to integer")
funcEND======================funcEND==============
func======================func==============
lang: py
name: FLOAT
libs: null
description: string~~~FLOAT is a function that converts a given value to a float and throws an error if the value cannot be converted.~~~here is how the func looks like:~~~```htvm~~~FLOAT(str value)~~~```~~~
# Convert value to float
def FLOAT(value):
    try:
        return float(value)
    except ValueError:
        raise TypeError("Cannot convert to float")
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: INT
libs: #include <string>|#include <sstream>
description: string~~~INT is a function that converts a value to an integer, throwing an error if the conversion fails.~~~here is how the func looks like:~~~```htvm~~~INT(str value)~~~```~~~
// Convert std::string to int
int INT(const std::string& str) {
    std::istringstream iss(str);
    int value;
    iss >> value;
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: STR
libs: #include <string>
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
// Convert various types to std::string
std::string STR(int value) {
    return std::to_string(value);
}
// Convert various types to std::string
std::string STR(long long value) {
    return std::to_string(value);
}
std::string STR(float value) {
    return std::to_string(value);
}
std::string STR(double value) {
    return std::to_string(value);
}
std::string STR(size_t value) {
    return std::to_string(value);
}
std::string STR(bool value) {
    return value ? "1" : "0";
}
std::string STR(const char* value) {
    return std::string(value);
}
funcEND======================funcEND==============





func======================func==============
lang: go
name: STR
libs: )|"strconv"
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
func STR(value interface{}) string {
    switch v := value.(type) {
    case int:
        return strconv.Itoa(v)
    case int64:
        return strconv.FormatInt(v, 10)
    case float64:
        return fmt.Sprintf("%f", v)
    case bool:
        if v {
            return "1"
        } else {
            return "0"
        }
    case string:
        return v
    default:
        return fmt.Sprintf("%v", v)
    }
}
funcEND======================funcEND==============

func======================func==============
lang: lua
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
function STR(value)
    if type(value) == "number" then
        return tostring(value)
    elseif type(value) == "boolean" then
        return value and "1" or "0"
    elseif type(value) == "string" then
        return value
    else
        return tostring(value)
    end
end
funcEND======================funcEND==============


func======================func==============
lang: cs
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
public static string STR(object value) {
    if (value is int)
        return value.ToString();
    else if (value is long)
        return value.ToString();
    else if (value is float)
        return value.ToString();
    else if (value is double)
        return value.ToString();
    else if (value is bool)
        return (bool)value ? "1" : "0";
    else if (value is string)
        return (string)value;
    else
        return value.ToString();
}
funcEND======================funcEND==============

func======================func==============
lang: java
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
public static String STR(Object value) {
    if (value instanceof Integer) {
        return value.toString();
    } else if (value instanceof Long) {
        return value.toString();
    } else if (value instanceof Float) {
        return value.toString();
    } else if (value instanceof Double) {
        return value.toString();
    } else if (value instanceof Boolean) {
        return (Boolean) value ? "1" : "0";
    } else if (value instanceof String) {
        return (String) value;
    } else {
        return value.toString();
    }
}
funcEND======================funcEND==============


func======================func==============
lang: kt
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
fun STR(value: Any): String {
    return when (value) {
        is Int -> value.toString()
        is Long -> value.toString()
        is Float -> value.toString()
        is Double -> value.toString()
        is Boolean -> if (value) "1" else "0"
        is String -> value
        else -> value.toString()
    }
}
funcEND======================funcEND==============


func======================func==============
lang: rb
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
def STR(value)
  if value.is_a?(Integer) || value.is_a?(Float)
    return value.to_s
  elsif value.is_a?(TrueClass) || value.is_a?(FalseClass)
    return value ? "1" : "0"
  elsif value.is_a?(String)
    return value
  else
    return value.to_s
  end
end

funcEND======================funcEND==============

func======================func==============
lang: nim
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
proc STR(value: auto): string =
  when value is int | int64 | float | float64:
    return $value
  elif value is bool:
    return if value: "1" else: "0"
  elif value is cstring:
    return $value
  else:
    return $value
funcEND======================funcEND==============

func======================func==============
lang: ahk
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
STR(value) {
    return value
}
funcEND======================funcEND==============


func======================func==============
lang: swift
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
func STR(_ value: Any) -> String {
    if let value = value as? Int {
        return String(value)
    } else if let value = value as? Float {
        return String(value)
    } else if let value = value as? Double {
        return String(value)
    } else if let value = value as? Bool {
        return value ? "1" : "0"
    } else if let value = value as? String {
        return value
    } else {
        return "\(value)"
    }
}
funcEND======================funcEND==============


func======================func==============
lang: dart
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
String STR(dynamic value) {
  if (value is int || value is double || value is num) {
    return value.toString();
  } else if (value is bool) {
    return value ? "1" : "0";
  } else if (value is String) {
    return value;
  } else {
    return value.toString();
  }
}
funcEND======================funcEND==============

func======================func==============
lang: ts
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
function STR(value: any): string {
    if (typeof value === "number") {
        return value.toString();
    } else if (typeof value === "boolean") {
        return value ? "1" : "0";
    } else if (typeof value === "string") {
        return value;
    } else {
        return String(value);
    }
}
funcEND======================funcEND==============



func======================func==============
lang: groovy
name: STR
libs: null
description: string~~~STR is a function that converts a value to its string representation, handling numbers, booleans, and strings, while throwing an error for unsupported types.~~~here is how the func looks like:~~~```htvm~~~STR(value)~~~```~~~
// Convert various types to String
String STR(int value) {
    return value.toString()
}

// Convert various types to String
String STR(long value) {
    return value.toString()
}

String STR(float value) {
    return value.toString()
}

String STR(double value) {
    return value.toString()
}

String STR(boolean value) {
    return value ? "1" : "0"
}

String STR(String value) {
    return value
}
funcEND======================funcEND==============


func======================func==============
lang: cpp
name: FLOAT
libs: #include <string>|#include <sstream>
description: string~~~FLOAT is a function that converts a given value to a float and throws an error if the value cannot be converted.~~~here is how the func looks like:~~~```htvm~~~FLOAT(str value)~~~```~~~
// Convert std::string to float
float FLOAT(const std::string& str) {
    std::istringstream iss(str);
    float value;
    iss >> value;
    return value;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: InStr
libs: #include <string>
description: string~~~InStr is a function that finds the position of the substring needle within the string haystack and returns its position (1-based index), or 0 if the substring is not found.~~~here is how the func looks like:~~~```htvm~~~InStr(str haystack, str needle)~~~```~~~
// Function to find the position of needle in haystack (std::string overload)
int InStr(const std::string& haystack, const std::string& needle) {
    size_t pos = haystack.find(needle);
    return (pos != std::string::npos) ? static_cast<int>(pos) + 1 : 0;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Random
libs: #include <cstdlib>|#include <ctime>|#include <random>
description: math~~~Random is a function that generates and returns a random integer between a specified minimum and maximum value, inclusive.~~~here is how the func looks like:~~~```htvm~~~Random(min, max)~~~```~~~
int Random(int min, int max) {
    // Create a random device to seed the generator
    std::random_device rd;

    // Create a generator seeded with the random device
    std::mt19937 gen(rd());

    // Define a distribution within the specified range
    std::uniform_int_distribution<> dis(min, max);

    // Generate and return a random number within the specified range
    return dis(gen);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sleep
libs: #include <thread>|#include <chrono>
description: system~~~Sleep is a function that pauses execution for a specified number of milliseconds.~~~here is how the func looks like:~~~```htvm~~~Sleep(int milliseconds)~~~```~~~
// Function to sleep for a specified number of milliseconds
void Sleep(int milliseconds) {
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: input
libs: #include <iostream>|#include <string>
description: io~~~input is a function that displays a prompt with the given text and returns the user's input.~~~here is how the func looks like:~~~```htvm~~~input(str promptText)~~~```~~~
// Function to get input from the user, similar to Python's input() function
std::string input(const std::string& prompt) {
    std::string userInput;
    std::cout << prompt; // Display the prompt to the user
    std::getline(std::cin, userInput); // Get the entire line of input
    return userInput;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileRead
libs: #include <fstream>|#include <string>|#include <filesystem>|#include <stdexcept>
description: file~~~FileRead is a function that reads the content of a file given a path, prepends the current working directory if the path is not absolute, and returns the file content as a string.~~~here is how the func looks like:~~~```htvm~~~FileRead(path: str)~~~```~~~
std::string FileRead(const std::string& path) {
    std::ifstream file;
    std::filesystem::path full_path;
    // Check if the file path is an absolute path
    if (std::filesystem::path(path).is_absolute()) {
        full_path = path;
    } else {
        // If it's not a full path, prepend the current working directory
        full_path = std::filesystem::current_path() / path;
    }
    // Open the file
    file.open(full_path);
    if (!file.is_open()) {
        throw std::runtime_error("Error: Could not open the file.");
    }
    // Read the file content into a string
    std::string content;
    std::string line;
    while (std::getline(file, line)) {
        content += line + '\n';
    }
    file.close();
    return content;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileAppend
libs: #include <fstream>|#include <iostream>|#include <string>|#include <filesystem>
description: file~~~FileAppend is a function that appends the given content to a file at the specified path and returns a boolean indicating success or failure.~~~here is how the func looks like:~~~```htvm~~~FileAppend(str content, str path)~~~```~~~
bool FileAppend(const std::string& content, const std::string& path) {
    std::ofstream file;
    // Open the file in append mode
    file.open(path, std::ios::app);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open the file for appending." << std::endl;
        return false;
    }
    // Append the content to the file
    file << content;
    // Close the file
    file.close();
    return true;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileDelete
libs: #include <fstream>|#include <iostream>|#include <string>|#include <filesystem>
description: file~~~FileDelete is a function that checks if a file exists at the given path and deletes it if found, returning True if the file is deleted, otherwise False.~~~here is how the func looks like:~~~```htvm~~~FileDelete(str path)~~~```~~~
bool FileDelete(const std::string& path) {
    std::filesystem::path file_path(path);
    // Check if the file exists
    if (!std::filesystem::exists(file_path)) {
        return false;
    }
    // Attempt to remove the file
    if (!std::filesystem::remove(file_path)) {
        return false;
    }
    return true;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrLen
libs: #include <string>
description: string~~~StrLen is a function that takes a string as input and returns its length as a size_t value.~~~here is how the func looks like:~~~```htvm~~~StrLen(str)~~~```~~~
size_t StrLen(const std::string& str) {
    return str.length();
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Asc
libs: #include <string>
description: string~~~Asc is a function that takes a string and returns the ASCII value of its first character, or -1 if the string is empty.~~~here is how the func looks like:~~~```htvm~~~Asc(str s)~~~```~~~
int Asc(const std::string& str) {
    if (!str.empty()) {
        return static_cast<int>(str[0]);
    }
    return -1; // Return -1 if the string is empty
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Abs
libs: #include <string>
description: math~~~Abs is a function that returns the absolute value of the provided number.~~~here is how the func looks like:~~~```htvm~~~Abs(int value)~~~```~~~
double Abs(double value) {
    return std::fabs(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ACos
libs: #include <cmath>
description: math~~~ACos is a function that returns the arc cosine (inverse cosine) of a number, which must be between -1 and 1.~~~here is how the func looks like:~~~```htvm~~~ACos(float)~~~```~~~
double ACos(double value) {
    return std::acos(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ASin
libs: #include <cmath>
description: math~~~ASin is a function that calculates the arcsine (inverse sine) of a given value, throwing an error if the value is outside the range of -1 to 1.~~~here is how the func looks like:~~~```htvm~~~ASin(float value)~~~```~~~
double ASin(double value) {
    if (value < -1.0 || value > 1.0) {
        std::cerr << "Error: Value out of range for arcsine function." << std::endl;
        return NAN;
    }
    return asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ATan
libs: #include <cmath>
description: math~~~ATan is a function that calculates the arctangent of a number, returning the angle in radians.~~~here is how the func looks like:~~~```htvm~~~ATan(float)~~~```~~~
double ATan(double value) {
    return std::atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Ceil
libs: #include <cmath>
description: math~~~Ceil is a function that takes a numerical value and returns the smallest integer greater than or equal to that value.~~~here is how the func looks like:~~~```htvm~~~Ceil(num)~~~```~~~
double Ceil(double value) {
    return std::ceil(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Cos
libs: #include <cmath>
description: math~~~Cos is a function that calculates the cosine of a given angle in radians.~~~here is how the func looks like:~~~```htvm~~~Cos(float angle)~~~```~~~
double Cos(double angle) {
    return std::cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Exp
libs: #include <cmath>
description: math~~~Exp is a function that takes a numeric value and returns the value of e raised to the power of the given value using the Math.exp() function.~~~here is how the func looks like:~~~```htvm~~~Exp(value)~~~```~~~
double Exp(double value) {
    return std::exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Ln
libs: #include <cmath>
description: math~~~Ln is a function that calculates the natural logarithm (base e) of a given value.~~~here is how the func looks like:~~~```htvm~~~Ln(int value)~~~```~~~
double Ln(double value) {
    return std::log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Log
libs: #include <cmath>
description: math~~~Log is a function that calculates the base 10 logarithm of a given value.~~~here is how the func looks like:~~~```htvm~~~Log(int value)~~~```~~~
double Log(double value) {
    return std::log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Round
libs: #include <cmath>
description: math~~~Round is a function that rounds a given numeric value to the nearest integer.~~~here is how the func looks like:~~~```htvm~~~Round(num)~~~```~~~
double Round(double value) {
    return std::round(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sin
libs: #include <cmath>
description: math~~~Sin is a function that takes an angle (in radians) and returns the sine of that angle.~~~here is how the func looks like:~~~```htvm~~~Sin(float)~~~```~~~
double Sin(double angle) {
    return std::sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sqrt
libs: #include <cmath>
description: math~~~Sqrt is a function that calculates the square root of a given numeric value.~~~here is how the func looks like:~~~```htvm~~~Sqrt(num)~~~```~~~
double Sqrt(double value) {
    return std::sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Tan
libs: #include <cmath>
description: math~~~Tan is a function that calculates the tangent of the given angle (in radians).~~~here is how the func looks like:~~~```htvm~~~Tan(float)~~~```~~~
double Tan(double angle) {
    return std::tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: SubStr
libs: #include <string>
description: string~~~SubStr is a function that extracts a substring from a given string, starting from a specified position and for a specified length, adjusting for edge cases like null inputs or missing parameters.~~~here is how the func looks like:~~~```htvm~~~SubStr(str, int startPos, int length [= str.length - startPos + 1])~~~```~~~


std::string SubStr(const std::string& str, int startPos, int length = -1) {
    std::string result;
    size_t strLen = str.size();

    // Handle negative starting positions (counting from the end)
    if (startPos < 0) {
        startPos = strLen + startPos;
        if (startPos < 0) startPos = 0;  // Ensure it doesn't go beyond the start of the string
    }
    else {
        startPos -= 1; // Convert to 0-based index for internal operations
    }

    // Handle length
    if (length < 0) {
        length = strLen - startPos; // Length to the end of the string
    } else if (startPos + length > static_cast<int>(strLen)) {
        length = strLen - startPos; // Adjust length to fit within the string
    }

    // Extract the substring
    result = str.substr(startPos, length);
    return result;
}


funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Trim
libs: #include <string>
description: string~~~Trim is a function that removes leading and trailing whitespace from the input string.~~~here is how the func looks like:~~~```htvm~~~Trim(string)~~~```~~~
std::string Trim(const std::string &inputString) {
    if (inputString.empty()) return "";
    size_t start = inputString.find_first_not_of(" \t\n\r\f\v");
    size_t end = inputString.find_last_not_of(" \t\n\r\f\v");
    return (start == std::string::npos) ? "" : inputString.substr(start, end - start + 1);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrReplace
libs: #include <string>
description: string~~~StrReplace is a function that takes an original string, a substring to find, and a substring to replace it with, returning the modified string.~~~here is how the func looks like:~~~```htvm~~~StrReplace(str originalString, str find, str replaceWith)~~~```~~~
std::string StrReplace(const std::string &originalString, const std::string &find, const std::string &replaceWith) {
    std::string result = originalString;
    size_t pos = 0;
    while ((pos = result.find(find, pos)) != std::string::npos) {
        result.replace(pos, find.length(), replaceWith);
        pos += replaceWith.length();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StringTrimLeft
libs: #include <string>
description: string~~~StringTrimLeft is a function that trims a specified number of characters from the left side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimLeft(str input, int numChars)~~~```~~~
std::string StringTrimLeft(const std::string &input, int numChars) {
    return (numChars <= input.length()) ? input.substr(numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StringTrimRight
libs: #include <string>
description: string~~~StringTrimRight is a function that trims a specified number of characters from the right side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimRight(str input, int numChars)~~~```~~~
std::string StringTrimRight(const std::string &input, int numChars) {
    return (numChars <= input.length()) ? input.substr(0, input.length() - numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrLower
libs: #include <algorithm>|#include <cctype>|#include <string>
description: string~~~StrLower is a function that takes a string as input and converts all characters to lowercase.~~~here is how the func looks like:~~~```htvm~~~StrLower(string)~~~```~~~
std::string StrLower(const std::string &string) {
    std::string result = string;
    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrSplit
libs: #include <string>
description: string~~~StrSplit is a function that splits an input string by a specified delimiter and returns the part at the specified index, or an empty string if the index is out of range.~~~here is how the func looks like:~~~```htvm~~~StrSplit(str inputStr, str delimiter, int num)~~~```~~~
std::string StrSplit(const std::string &inputStr, const std::string &delimiter, int num) {
    size_t start = 0, end = 0, count = 0;
    while ((end = inputStr.find(delimiter, start)) != std::string::npos) {
        if (++count == num) {
            return inputStr.substr(start, end - start);
        }
        start = end + delimiter.length();
    }
    if (count + 1 == num) {
        return inputStr.substr(start);
    }
    return "";
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Chr
libs: #include <string>
description: string~~~Chr is a function that returns the character corresponding to the given Unicode code point or an empty string if the number is out of range.~~~here is how the func looks like:~~~```htvm~~~Chr(int number)~~~```~~~
std::string Chr(int number) {
    return (number >= 0 && number <= 0x10FFFF) ? std::string(1, static_cast<char>(number)) : "";
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Mod
libs: #include <string>
description: math~~~Mod is a function that returns the remainder when the dividend is divided by the divisor.~~~here is how the func looks like:~~~```htvm~~~Mod(int dividend, int divisor)~~~```~~~
int Mod(int dividend, int divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Floor
libs: #include <cmath>|#include <limits>
description: math~~~Floor is a function that returns the largest integer less than or equal to a given number, or NaN if the input is not a number.~~~here is how the func looks like:~~~```htvm~~~Floor(num)~~~```~~~
double Floor(double num) {
    if (std::isnan(num)) {
        return std::numeric_limits<double>::quiet_NaN();
    }
    return std::floor(num);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: Sort
libs: #include <string>|#include <vector>|#include <algorithm>|#include <sstream>|#include <unordered_set>|#include <cctype>
description: string~~~Sort is a function that takes a string and optional options to sort its elements based on various criteria such as numeric, random, alphabetical, case sensitivity, and more, with support for delimiters and unique filtering.~~~here is how the func looks like:~~~```htvm~~~Sort(str varName, [str options = ""])~~~```~~~
// Helper function to trim whitespace from both ends of a string
std::string trim(const std::string& str) {
    const std::string whitespace = " \t\n\r\f\v";
    size_t start = str.find_first_not_of(whitespace);
    if (start == std::string::npos) return "";
    size_t end = str.find_last_not_of(whitespace);
    return str.substr(start, end - start + 1);
}
// Helper function to convert string to lowercase
std::string toLower(const std::string& str) {
    std::string lowerStr = str;
    std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
    return lowerStr;
}
// Function to sort case-insensitively but ensure lowercase items come last
bool customSortCompare(const std::string& a, const std::string& b) {
    std::string lowerA = toLower(a);
    std::string lowerB = toLower(b);
    if (lowerA == lowerB) {
        // If case-insensitive equivalent, ensure lowercase items come last
        if (std::islower(a[0]) && std::isupper(b[0])) {
            return false; // a should come after b
        } else if (std::isupper(a[0]) && std::islower(b[0])) {
            return true; // a should come before b
        }
        return a < b; // Otherwise, sort lexicographically
    }
    return lowerA < lowerB;
}
// Function to remove exact duplicates (case-sensitive)
std::vector<std::string> removeExactDuplicates(const std::vector<std::string>& items) {
    std::unordered_set<std::string> seen;
    std::vector<std::string> uniqueItems;
    for (const auto& item : items) {
        if (seen.find(item) == seen.end()) {
            seen.insert(item);
            uniqueItems.push_back(item);
        }
    }
    return uniqueItems;
}
// Main sorting function
std::string Sort(const std::string& input, const std::string& options) {
    std::string delimiter = "\n";
    bool caseInsensitive = options.find('C') != std::string::npos;
    bool unique = options.find('U') != std::string::npos;
    bool reverse = options.find('R') != std::string::npos;
    bool random = options.find("Random") != std::string::npos;
    bool numeric = options.find('N') != std::string::npos;
    // Custom delimiter
    if (options.find('D') != std::string::npos) {
        size_t delimiterPos = options.find('D') + 1;
        if (delimiterPos < options.size()) {
            delimiter = options.substr(delimiterPos, 1);
        }
    }
    // Split input by delimiter
    std::vector<std::string> items;
    std::stringstream ss(input);
    std::string item;
    while (std::getline(ss, item, delimiter[0])) {
        item = trim(item);  // Trim whitespace from each item
        if (!item.empty()) {
            items.push_back(item);
        }
    }
    // Sort items
    if (numeric) {
        std::sort(items.begin(), items.end(), [](const std::string& a, const std::string& b) {
            return std::stoi(a) < std::stoi(b);
        });
    } else {
        std::sort(items.begin(), items.end(), customSortCompare);
    }
    // Remove exact duplicates if needed
    if (unique) {
        items = removeExactDuplicates(items);
    }
    // Apply reverse order if needed
    if (reverse) {
        std::reverse(items.begin(), items.end());
    }
    // Separate uppercase and lowercase items
    std::vector<std::string> uppercaseItems;
    std::vector<std::string> lowercaseItems;

    for (const auto& item : items) {
        if (std::isupper(item[0])) {
            uppercaseItems.push_back(item);
        } else {
            lowercaseItems.push_back(item);
        }
    }
    // Combine sorted uppercase items with sorted lowercase items
    std::string result;
    for (const auto& item : uppercaseItems) {
        result += item;
        result += delimiter;
    }
    for (const auto& item : lowercaseItems) {
        result += item;
        if (&item != &lowercaseItems.back()) {
            result += delimiter;
        }
    }
    // Remove trailing delimiter if necessary
    if (!result.empty() && result.back() == delimiter[0]) {
        result.pop_back();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: getDataFromAPI
libs: #include <string>|#include <array>|#include <memory>|#include <stdexcept>| #include <cstdio>
description: io~~~getDataFromAPI is a function that asynchronously fetches JSON data from a given URL and returns it, handling errors and non-OK responses.~~~here is how the func looks like:~~~```htvm~~~getDataFromAPI(str url)~~~```~~~
// Function to run a system command
std::string getDataFromAPIRunCMD(const std::string& command) {
    std::array<char, 128> buffer;
    std::string result;
#if defined(_WIN32)
    std::unique_ptr<FILE, decltype(&_pclose)> pipe(_popen(command.c_str(), "r"), _pclose);
#else
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
#endif
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}
// Function to fetch data from API
std::string getDataFromAPI(const std::string& url) {
    std::string command = "curl -s " + url;
    return getDataFromAPIRunCMD(command);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileCreateDir
libs: #include <filesystem>|#include <system_error>
description: file~~~FileCreateDir is a function that checks if a directory exists, and if not, it creates the directory.~~~here is how the func looks like:~~~```htvm~~~FileCreateDir(str directory)~~~```~~~
// Creates a directory if it does not exist
void FileCreateDir(const std::string& path) {
    try {
        std::filesystem::create_directory(path);
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileRemoveDir
libs: #include <filesystem>|#include <system_error>
description: file~~~FileRemoveDir is a function that removes a directory and its contents if the directory exists.~~~here is how the func looks like:~~~```htvm~~~FileRemoveDir(str directory)~~~```~~~
// Removes a directory if it exists
void FileRemoveDir(const std::string& path) {
    try {
        if (std::filesystem::exists(path) && std::filesystem::is_directory(path)) {
            std::filesystem::remove_all(path);
        }
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: FileExist
libs: #include <filesystem>|#include <system_error>
description: file~~~FileExist is a function that checks if a file or directory exists at the specified path.~~~here is how the func looks like:~~~```htvm~~~FileExist(str path)~~~```~~~
// Checks if a file or directory exists
bool FileExist(const std::string& path) {
    try {
        return std::filesystem::exists(path);
    } catch (const std::filesystem::filesystem_error&) {
        // Handle errors silently; return false if an error occurs
        return false;
    }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: isWindows
libs: #include <iostream>
description: other~~~isWindows is a function that checks if the current operating system is Windows by comparing the system name to "windows".~~~here is how the func looks like:~~~```htvm~~~isWindows()~~~```~~~
// Function to check if the operating system is Windows
bool isWindows() {
    #ifdef _WIN32
        return true;
    #else
        return false;
    #endif
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: GetParams
libs: #include <iostream>|#include <vector>|#include <string>|#include <filesystem>
description: io~~~GetParams is a function that retrieves command line arguments, checks if they correspond to existing paths, and returns them as absolute paths in new lines, or as they are if they do not exist.~~~here is how the func looks like:~~~```htvm~~~GetParams()~~~```~~~
#ifdef _WIN32
    #define ARGC __argc
    #define ARGV __argv
#else
    extern char **environ;
    int ARGC;
    char** ARGV;
    __attribute__((constructor)) void init_args(int argc, char* argv[], char* envp[]) {
        ARGC = argc;
        ARGV = argv;
    }
#endif
std::string GetParams() {
    std::vector<std::string> params;
    for (int i = 1; i < ARGC; ++i) {
        std::string arg = ARGV[i];
        if (std::filesystem::exists(arg)) {
            arg = std::filesystem::absolute(arg).string();
        }
        params.push_back(arg);
    }
    std::string result;
    for (const auto& param : params) {
        result += param + "\n";
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: BuildInVars
libs: #include <iostream>|#include <chrono>|#include <ctime>|#include <sstream>|#include <iomanip>|#include <string>|#include <limits>
description: system~~~BuildInVars is a function that retrieves various system-related values or states, including screen dimensions, timestamps, key presses, and more, based on the specified variable name.~~~here is how the func looks like:~~~```htvm~~~BuildInVars(str varName)~~~```~~~
// Store the start time as a global variable
std::chrono::time_point<std::chrono::steady_clock> programStartTime = std::chrono::steady_clock::now();
// Function to get built-in variables
std::string BuildInVars(const std::string& varName) {
    auto now = std::chrono::system_clock::now();
    std::time_t currentTime = std::chrono::system_clock::to_time_t(now);
    std::tm* localTime = std::localtime(&currentTime);
    std::ostringstream oss;
    if (varName == "A_TickCount") {
        // Calculate milliseconds since program start
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() - programStartTime).count();
        if (duration > std::numeric_limits<int>::max()) {
            // Handle overflow case
            return "Value too large";
        } else {
            return std::to_string(static_cast<int>(duration));
        }
    } else if (varName == "A_Now") {
        oss << std::put_time(localTime, "%Y-%m-%d %H:%M:%S");
    } else if (varName == "A_YYYY") {
        oss << std::put_time(localTime, "%Y");
    } else if (varName == "A_MM") {
        oss << std::put_time(localTime, "%m");
    } else if (varName == "A_DD") {
        oss << std::put_time(localTime, "%d");
    } else if (varName == "A_MMMM") {
        oss << std::put_time(localTime, "%B");
    } else if (varName == "A_MMM") {
        oss << std::put_time(localTime, "%b");
    } else if (varName == "A_DDDD") {
        oss << std::put_time(localTime, "%A");
    } else if (varName == "A_DDD") {
        oss << std::put_time(localTime, "%a");
    } else if (varName == "A_Hour") {
        oss << std::put_time(localTime, "%H");
    } else if (varName == "A_Min") {
        oss << std::put_time(localTime, "%M");
    } else if (varName == "A_Sec") {
        oss << std::put_time(localTime, "%S");
    } else if (varName == "A_Space") {
        return " ";
    } else if (varName == "A_Tab") {
        return "\t";
    } else {
        return "";
    }
    return oss.str();
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RegExReplace
libs: #include <string>|#include <regex>|#include <iostream>
description: string~~~RegExReplace is a function that performs a regular expression-based replacement on a string using a given pattern and replacement string.~~~here is how the func looks like:~~~```htvm~~~RegExReplace(str inputStr, str regexPattern, str replacement)~~~```~~~
std::string RegExReplace(const std::string& inputStr, const std::string& regexPattern, const std::string& replacement) {
    std::regex re(regexPattern, std::regex_constants::ECMAScript | std::regex_constants::multiline);
    return std::regex_replace(inputStr, re, replacement);
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RunCMD
libs: #include <iostream>|#include <stdexcept>|#include <string>|#include <array>|#include <memory>|#include <cstdio>
description: io~~~RunCMD is a function that executes a shell command and captures its output or errors.~~~here is how the func looks like:~~~```htvm~~~RunCMD(str command)~~~```~~~
std::string RunCMD(const std::string& command) {
    std::array<char, 128> buffer;
    std::string result;
#if defined(_WIN32)
    std::unique_ptr<FILE, decltype(&_pclose)> pipe(_popen(command.c_str(), "r"), _pclose);
#else
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
#endif
    if (!pipe) {
        throw std::runtime_error("popen() failed!");
    }
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: RegExMatch
libs: #include <regex>|#include <string>|#include <iostream>
description: string~~~RegExMatch is a function that returns the 1-based index of the first regex match or 0 if no match is found.~~~here is how the func looks like:~~~```htvm~~~RegExMatch(str haystack, str needle)~~~```~~~
int RegExMatch(const std::string& haystack, const std::string& needle) {
    std::regex re(needle);
    std::smatch match;
    if (std::regex_search(haystack, match, re)) {
        return match.position(0) + 1; // 1-based index
    }
    return 0; // No match
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: ExitApp
libs: #include <iostream>|#include <cstdlib>
description: system~~~ExitApp is a function that terminates the application immediately.~~~here is how the func looks like:~~~```htvm~~~ExitApp()~~~```~~~
void ExitApp() {
    std::exit(0);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: InStr
libs: null
description: string~~~InStr is a function that finds the position of the substring needle within the string haystack and returns its position (1-based index), or 0 if the substring is not found.~~~here is how the func looks like:~~~```htvm~~~InStr(str haystack, str needle)~~~```~~~
# Function to find the position of needle in haystack (str overload)
def InStr(haystack: str, needle: str) -> int:
    pos = haystack.find(needle)
    return pos + 1 if pos != -1 else 0
funcEND======================funcEND==============
func======================func==============
lang: js
name: InStr
libs: null
description: string~~~InStr is a function that finds the position of the substring needle within the string haystack and returns its position (1-based index), or 0 if the substring is not found.~~~here is how the func looks like:~~~```htvm~~~InStr(str haystack, str needle)~~~```~~~
// Function to find the position of needle in haystack (string overload)
function InStr(haystack, needle) {
    const pos = haystack.indexOf(needle);
    return (pos !== -1) ? pos + 1 : 0;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Random
libs: import random
description: math~~~Random is a function that generates and returns a random integer between a specified minimum and maximum value, inclusive.~~~here is how the func looks like:~~~```htvm~~~Random(min, max)~~~```~~~
def Random(min: int, max: int) -> int:
    # Generate and return a random number within the specified range
    return random.randint(min, max)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Random
libs: null
description: math~~~Random is a function that generates and returns a random integer between a specified minimum and maximum value, inclusive.~~~here is how the func looks like:~~~```htvm~~~Random(min, max)~~~```~~~
// Function to generate a random integer between min and max (inclusive)
function Random(min, max) {
    // Generate and return a random number within the specified range
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sleep
libs: import time
description: system~~~Sleep is a function that pauses execution for a specified number of milliseconds.~~~here is how the func looks like:~~~```htvm~~~Sleep(int milliseconds)~~~```~~~
def Sleep(milliseconds: int) -> None:
    # Sleep for the specified number of milliseconds
    time.sleep(milliseconds / 1000)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sleep
libs: null
description: system~~~Sleep is a function that pauses execution for a specified number of milliseconds.~~~here is how the func looks like:~~~```htvm~~~Sleep(int milliseconds)~~~```~~~
function Sleep(milliseconds) {
    // Sleep for the specified number of milliseconds
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: input
libs: null
description: io~~~input is a function that displays a prompt with the given text and returns the user's input.~~~here is how the func looks like:~~~```htvm~~~input(str promptText)~~~```~~~
// Function to simulate input() in JavaScript
function input(promptText) {
    // Display the prompt and get user input
    return prompt(promptText);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: input
libs: null
description: io~~~input is a function that displays a prompt with the given text and returns the user's input.~~~here is how the func looks like:~~~```htvm~~~input(str promptText)~~~```~~~
# used imput func
funcEND======================funcEND==============
func======================func==============
lang: js
name: FileAppendJs
libs: null
description: file~~~FileAppendJs is a function that appends content to a file by creating a Blob, generating a download link, and triggering a download with the specified filename.~~~here is how the func looks like:~~~```htvm~~~FileAppendJs(str content, str filename)~~~```~~~
function FileAppendJs(content, filename) {
    // Create a Blob from the content
    const blob = new Blob([content], { type: 'text/plain' });
    const link = document.createElement('a');
    // Set the download attribute with the filename
    link.download = filename;
    link.href = URL.createObjectURL(blob);
    link.click();
    // Clean up the URL object
    URL.revokeObjectURL(link.href);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileDelete
libs: import os
description: file~~~FileDelete is a function that checks if a file exists at the given path and deletes it if found, returning True if the file is deleted, otherwise False.~~~here is how the func looks like:~~~```htvm~~~FileDelete(str path)~~~```~~~
def FileDelete(path: str) -> bool:
    # Check if the file exists and remove it
    if os.path.exists(path):
        os.remove(path)
        return True
    return False
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileAppend
libs: null
description: file~~~FileAppend is a function that appends the given content to a file at the specified path and returns a boolean indicating success or failure.~~~here is how the func looks like:~~~```htvm~~~FileAppend(str content, str path)~~~```~~~
def FileAppend(content: str, path: str) -> bool:
    # Open the file in append mode and write the content
    try:
        with open(path, 'a') as file:
            file.write(content)
        return True
    except IOError:
        print("Error: Could not open the file for appending.")
        return False
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileRead
libs: import os
description: file~~~FileRead is a function that reads the content of a file given a path, prepends the current working directory if the path is not absolute, and returns the file content as a string.~~~here is how the func looks like:~~~```htvm~~~FileRead(path: str)~~~```~~~
def FileRead(path: str) -> str:
    # Check if the path is absolute, if not prepend the current working directory
    if not os.path.isabs(path):
        path = os.path.join(os.getcwd(), path)
    # Open and read the file content
    with open(path, 'r') as file:
        return file.read()
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrLen
libs: null
description: string~~~StrLen is a function that takes a string as input and returns its length as a size_t value.~~~here is how the func looks like:~~~```htvm~~~StrLen(str)~~~```~~~
def StrLen(s: str) -> int:
    # Return the length of the given string
    return len(s)
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrLen
libs: null
description: string~~~StrLen is a function that takes a string as input and returns its length as a size_t value.~~~here is how the func looks like:~~~```htvm~~~StrLen(str)~~~```~~~
function StrLen(s) {
    // Return the length of the given string
    return s.length;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Chr
libs: null
description: string~~~Chr is a function that returns the character corresponding to the given Unicode code point or an empty string if the number is out of range.~~~here is how the func looks like:~~~```htvm~~~Chr(int number)~~~```~~~
def Chr(number: int) -> str:
    # Return the character corresponding to the Unicode code point, or an empty string if out of range
    return chr(number) if 0 <= number <= 0x10FFFF else ""
funcEND======================funcEND==============
func======================func==============
lang: js
name: Chr
libs: null
description: string~~~Chr is a function that returns the character corresponding to the given Unicode code point or an empty string if the number is out of range.~~~here is how the func looks like:~~~```htvm~~~Chr(int number)~~~```~~~
function Chr(number) {
    // Return the character corresponding to the Unicode code point, or an empty string if out of range
    return (number >= 0 && number <= 0x10FFFF) ? String.fromCharCode(number) : "";
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Asc
libs: null
description: string~~~Asc is a function that takes a string and returns the ASCII value of its first character, or -1 if the string is empty.~~~here is how the func looks like:~~~```htvm~~~Asc(str s)~~~```~~~
def Asc(s: str) -> int:
    return ord(s[0]) if s else -1
funcEND======================funcEND==============
func======================func==============
lang: py
name: Abs
libs: null
description: math~~~Abs is a function that returns the absolute value of the provided number.~~~here is how the func looks like:~~~```htvm~~~Abs(int value)~~~```~~~
def Abs(value: float) -> float:
    return abs(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ACos
libs: import math
description: math~~~ACos is a function that returns the arc cosine (inverse cosine) of a number, which must be between -1 and 1.~~~here is how the func looks like:~~~```htvm~~~ACos(float)~~~```~~~
def ACos(value: float) -> float:
    return math.acos(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ASin
libs: import math
description: math~~~ASin is a function that calculates the arcsine (inverse sine) of a given value, throwing an error if the value is outside the range of -1 to 1.~~~here is how the func looks like:~~~```htvm~~~ASin(float value)~~~```~~~
def ASin(value: float) -> float:
    if value < -1.0 or value > 1.0:
        raise ValueError("Error: Value out of range for arcsine function.")
    return math.asin(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: ATan
libs: import math
description: math~~~ATan is a function that calculates the arctangent of a number, returning the angle in radians.~~~here is how the func looks like:~~~```htvm~~~ATan(float)~~~```~~~
def ATan(value: float) -> float:
    return math.atan(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Ceil
libs: import math
description: math~~~Ceil is a function that takes a numerical value and returns the smallest integer greater than or equal to that value.~~~here is how the func looks like:~~~```htvm~~~Ceil(num)~~~```~~~
def Ceil(value: float) -> float:
    return math.ceil(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Cos
libs: import math
description: math~~~Cos is a function that calculates the cosine of a given angle in radians.~~~here is how the func looks like:~~~```htvm~~~Cos(float angle)~~~```~~~
def Cos(angle: float) -> float:
    return math.cos(angle)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Exp
libs: import math
description: math~~~Exp is a function that takes a numeric value and returns the value of e raised to the power of the given value using the Math.exp() function.~~~here is how the func looks like:~~~```htvm~~~Exp(value)~~~```~~~
def Exp(value: float) -> float:
    return math.exp(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Ln
libs: import math
description: math~~~Ln is a function that calculates the natural logarithm (base e) of a given value.~~~here is how the func looks like:~~~```htvm~~~Ln(int value)~~~```~~~
def Ln(value: float) -> float:
    return math.log(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Log
libs: import math
description: math~~~Log is a function that calculates the base 10 logarithm of a given value.~~~here is how the func looks like:~~~```htvm~~~Log(int value)~~~```~~~
def Log(value: float) -> float:
    return math.log10(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Round
libs: null
description: math~~~Round is a function that rounds a given numeric value to the nearest integer.~~~here is how the func looks like:~~~```htvm~~~Round(num)~~~```~~~
def Round(value: float) -> float:
    return round(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sin
libs: import math
description: math~~~Sin is a function that takes an angle (in radians) and returns the sine of that angle.~~~here is how the func looks like:~~~```htvm~~~Sin(float)~~~```~~~
def Sin(angle: float) -> float:
    return math.sin(angle)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sqrt
libs: import math
description: math~~~Sqrt is a function that calculates the square root of a given numeric value.~~~here is how the func looks like:~~~```htvm~~~Sqrt(num)~~~```~~~
def Sqrt(value: float) -> float:
    return math.sqrt(value)
funcEND======================funcEND==============
func======================func==============
lang: py
name: Tan
libs: import math
description: math~~~Tan is a function that calculates the tangent of the given angle (in radians).~~~here is how the func looks like:~~~```htvm~~~Tan(float)~~~```~~~
def Tan(angle: float) -> float:
    return math.tan(angle)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Asc
libs: null
description: string~~~Asc is a function that takes a string and returns the ASCII value of its first character, or -1 if the string is empty.~~~here is how the func looks like:~~~```htvm~~~Asc(str s)~~~```~~~
function Asc(s) {
    return s.length > 0 ? s.charCodeAt(0) : -1;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Abs
libs: import math
description: math~~~Abs is a function that returns the absolute value of the provided number.~~~here is how the func looks like:~~~```htvm~~~Abs(int value)~~~```~~~
function Abs(value) {
    return Math.abs(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ACos
libs: import math
description: math~~~ACos is a function that returns the arc cosine (inverse cosine) of a number, which must be between -1 and 1.~~~here is how the func looks like:~~~```htvm~~~ACos(float)~~~```~~~
function ACos(value) {
    return Math.acos(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ASin
libs: null
description: math~~~ASin is a function that calculates the arcsine (inverse sine) of a given value, throwing an error if the value is outside the range of -1 to 1.~~~here is how the func looks like:~~~```htvm~~~ASin(float value)~~~```~~~
function ASin(value) {
    if (value < -1.0 || value > 1.0) {
        throw new RangeError("Error: Value out of range for arcsine function.");
    }
    return Math.asin(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: ATan
libs: null
description: math~~~ATan is a function that calculates the arctangent of a number, returning the angle in radians.~~~here is how the func looks like:~~~```htvm~~~ATan(float)~~~```~~~
function ATan(value) {
    return Math.atan(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Ceil
libs: null
description: math~~~Ceil is a function that takes a numerical value and returns the smallest integer greater than or equal to that value.~~~here is how the func looks like:~~~```htvm~~~Ceil(num)~~~```~~~
function Ceil(value) {
    return Math.ceil(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Cos
libs: null
description: math~~~Cos is a function that calculates the cosine of a given angle in radians.~~~here is how the func looks like:~~~```htvm~~~Cos(float angle)~~~```~~~
function Cos(angle) {
    return Math.cos(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Exp
libs: null
description: math~~~Exp is a function that takes a numeric value and returns the value of e raised to the power of the given value using the Math.exp() function.~~~here is how the func looks like:~~~```htvm~~~Exp(value)~~~```~~~
function Exp(value) {
    return Math.exp(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Ln
libs: null
description: math~~~Ln is a function that calculates the natural logarithm (base e) of a given value.~~~here is how the func looks like:~~~```htvm~~~Ln(int value)~~~```~~~
function Ln(value) {
    return Math.log(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Log
libs: null
description: math~~~Log is a function that calculates the base 10 logarithm of a given value.~~~here is how the func looks like:~~~```htvm~~~Log(int value)~~~```~~~
function Log(value) {
    return Math.log10(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Round
libs: null
description: math~~~Round is a function that rounds a given numeric value to the nearest integer.~~~here is how the func looks like:~~~```htvm~~~Round(num)~~~```~~~
function Round(value) {
    return Math.round(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sin
libs: null
description: math~~~Sin is a function that takes an angle (in radians) and returns the sine of that angle.~~~here is how the func looks like:~~~```htvm~~~Sin(float)~~~```~~~
function Sin(angle) {
    return Math.sin(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sqrt
libs: null
description: math~~~Sqrt is a function that calculates the square root of a given numeric value.~~~here is how the func looks like:~~~```htvm~~~Sqrt(num)~~~```~~~
function Sqrt(value) {
    return Math.sqrt(value);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Tan
libs: null
description: math~~~Tan is a function that calculates the tangent of the given angle (in radians).~~~here is how the func looks like:~~~```htvm~~~Tan(float)~~~```~~~
function Tan(angle) {
    return Math.tan(angle);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: SubStr
libs: null
description: string~~~SubStr is a function that extracts a substring from a given string, starting from a specified position and for a specified length, adjusting for edge cases like null inputs or missing parameters.~~~here is how the func looks like:~~~```htvm~~~SubStr(str, int startPos, int length [= str.length - startPos + 1])~~~```~~~
def SubStr(s, startPos, length=-1):
    result = ""
    strLen = len(s)

    # Handle negative starting positions (counting from the end)
    if startPos < 0:
        startPos = strLen + startPos
        if startPos < 0:
            startPos = 0  # Ensure it doesn't go beyond the start of the string
    else:
        startPos -= 1  # Convert to 0-based index for internal operations

    # Handle length
    if length < 0:
        length = strLen - startPos  # Length to the end of the string
    elif startPos + length > strLen:
        length = strLen - startPos  # Adjust length to fit within the string

    # Extract the substring
    result = s[startPos:startPos + length]
    return result

funcEND======================funcEND==============
func======================func==============
lang: js
name: SubStr
libs: null
description: string~~~SubStr is a function that extracts a substring from a given string, starting from a specified position and for a specified length, adjusting for edge cases like null inputs or missing parameters.~~~here is how the func looks like:~~~```htvm~~~SubStr(str, int startPos, int length [= str.length - startPos + 1])~~~```~~~
function SubStr(str, startPos, length = -1) {
    let result = "";
    let strLen = str.length;

    // Handle negative starting positions (counting from the end)
    if (startPos < 0) {
        startPos = strLen + startPos;
        if (startPos < 0) startPos = 0;  // Ensure it doesn't go beyond the start of the string
    } else {
        startPos -= 1; // Convert to 0-based index for internal operations
    }

    // Handle length
    if (length < 0) {
        length = strLen - startPos; // Length to the end of the string
    } else if (startPos + length > strLen) {
        length = strLen - startPos; // Adjust length to fit within the string
    }

    // Extract the substring
    result = str.substr(startPos, length);
    return result;
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: Trim
libs: null
description: string~~~Trim is a function that removes leading and trailing whitespace from the input string.~~~here is how the func looks like:~~~```htvm~~~Trim(string)~~~```~~~
def Trim(inputString):
    return inputString.strip() if inputString else ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrReplace
libs: null
description: string~~~StrReplace is a function that takes an original string, a substring to find, and a substring to replace it with, returning the modified string.~~~here is how the func looks like:~~~```htvm~~~StrReplace(str originalString, str find, str replaceWith)~~~```~~~
def StrReplace(originalString, find, replaceWith):
    return originalString.replace(find, replaceWith)
funcEND======================funcEND==============
func======================func==============
lang: py
name: StringTrimLeft
libs: null
description: string~~~StringTrimLeft is a function that trims a specified number of characters from the left side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimLeft(str input, int numChars)~~~```~~~
def StringTrimLeft(input, numChars):
    return input[numChars:] if numChars <= len(input) else input
funcEND======================funcEND==============
func======================func==============
lang: py
name: StringTrimRight
libs: null
description: string~~~StringTrimRight is a function that trims a specified number of characters from the right side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimRight(str input, int numChars)~~~```~~~
def StringTrimRight(input, numChars):
    return input[:-numChars] if numChars <= len(input) else input
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrLower
libs: null
description: string~~~StrLower is a function that takes a string as input and converts all characters to lowercase.~~~here is how the func looks like:~~~```htvm~~~StrLower(string)~~~```~~~
def StrLower(string):
    return string.lower()
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrSplit
libs: null
description: string~~~StrSplit is a function that splits an input string by a specified delimiter and returns the part at the specified index, or an empty string if the index is out of range.~~~here is how the func looks like:~~~```htvm~~~StrSplit(str inputStr, str delimiter, int num)~~~```~~~
def StrSplit(inputStr, delimiter, num):
    parts = inputStr.split(delimiter)
    return parts[num - 1] if 0 < num <= len(parts) else ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: Mod
libs: null
description: math~~~Mod is a function that returns the remainder when the dividend is divided by the divisor.~~~here is how the func looks like:~~~```htvm~~~Mod(int dividend, int divisor)~~~```~~~
def Mod(dividend, divisor):
    return dividend % divisor
funcEND======================funcEND==============
func======================func==============
lang: py
name: Floor
libs: import math
description: math~~~Floor is a function that returns the largest integer less than or equal to a given number, or NaN if the input is not a number.~~~here is how the func looks like:~~~```htvm~~~Floor(num)~~~```~~~
def Floor(num):
    return math.floor(num) if not math.isnan(num) else float('nan')
funcEND======================funcEND==============
func======================func==============
lang: js
name: Trim
libs: null
description: string~~~Trim is a function that removes leading and trailing whitespace from the input string.~~~here is how the func looks like:~~~```htvm~~~Trim(string)~~~```~~~
function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrReplace
libs: null
description: string~~~StrReplace is a function that takes an original string, a substring to find, and a substring to replace it with, returning the modified string.~~~here is how the func looks like:~~~```htvm~~~StrReplace(str originalString, str find, str replaceWith)~~~```~~~
function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StringTrimLeft
libs: null
description: string~~~StringTrimLeft is a function that trims a specified number of characters from the left side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimLeft(str input, int numChars)~~~```~~~
function StringTrimLeft(input, numChars) {
    return (numChars <= input.length) ? input.substring(numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StringTrimRight
libs: null
description: string~~~StringTrimRight is a function that trims a specified number of characters from the right side of a given string.~~~here is how the func looks like:~~~```htvm~~~StringTrimRight(str input, int numChars)~~~```~~~
function StringTrimRight(input, numChars) {
    return (numChars <= input.length) ? input.substring(0, input.length - numChars) : input;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrLower
libs: null
description: string~~~StrLower is a function that takes a string as input and converts all characters to lowercase.~~~here is how the func looks like:~~~```htvm~~~StrLower(string)~~~```~~~
function StrLower(string) {
    return string.toLowerCase();
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrSplit
libs: null
description: string~~~StrSplit is a function that splits an input string by a specified delimiter and returns the part at the specified index, or an empty string if the index is out of range.~~~here is how the func looks like:~~~```htvm~~~StrSplit(str inputStr, str delimiter, int num)~~~```~~~
function StrSplit(inputStr, delimiter, num) {
    const parts = inputStr.split(delimiter);
    return (num > 0 && num <= parts.length) ? parts[num - 1] : "";
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Mod
libs: null
description: math~~~Mod is a function that returns the remainder when the dividend is divided by the divisor.~~~here is how the func looks like:~~~```htvm~~~Mod(int dividend, int divisor)~~~```~~~
function Mod(dividend, divisor) {
    return dividend % divisor;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: Floor
libs: null
description: math~~~Floor is a function that returns the largest integer less than or equal to a given number, or NaN if the input is not a number.~~~here is how the func looks like:~~~```htvm~~~Floor(num)~~~```~~~
function Floor(num) {
    return isNaN(num) ? NaN : Math.floor(num);
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: Sort
libs: import random
description: string~~~Sort is a function that takes a string and optional options to sort its elements based on various criteria such as numeric, random, alphabetical, case sensitivity, and more, with support for delimiters and unique filtering.~~~here is how the func looks like:~~~```htvm~~~Sort(str varName, [str options = ""])~~~```~~~
def Sort(var_name, options):
    # Determine delimiter based on options
    delimiter = '\n'
    if 'D' in options:
        delimiter = options[options.index('D') + 1]

    # Split the input variable by delimiter
    items = var_name.split(delimiter)

    # Remove empty items and strip whitespace
    items = [item.strip() for item in items if item.strip()]

    # Apply sorting based on options
    if 'N' in options:
        # Numeric sort
        items.sort(key=lambda x: int(x))
    elif 'Random' in options:
        # Random sort
        random.shuffle(items)
    else:
        # Default alphabetical sort
        items.sort(key=lambda x: x.lower() if 'C' not in options else x)

    # Reverse if 'R' option is present
    if 'R' in options:
        items.reverse()

    # Remove duplicates if 'U' option is present
    if 'U' in options:
        seen = set()
        unique_items = []
        for item in items:
            lower_item = item.lower() if 'C' not in options else item
            if lower_item not in seen:
                seen.add(lower_item)
                unique_items.append(item)
        items = unique_items

    # Join the sorted items back into a string
    sorted_var = delimiter.join(items)

    return sorted_var
funcEND======================funcEND==============
func======================func==============
lang: py
name: getDataFromAPI
libs: import json|import urllib.request|import urllib.error
description: io~~~getDataFromAPI is a function that asynchronously fetches JSON data from a given URL and returns it, handling errors and non-OK responses.~~~here is how the func looks like:~~~```htvm~~~getDataFromAPI(str url)~~~```~~~
def getDataFromAPI(url):
    try:
        with urllib.request.urlopen(url) as response:
            if response.getcode() == 200:
                return response.read()
            else:
                return None
    except urllib.error.URLError as e:
        print(f"Error accessing URL: {e.reason}")
        return None
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileCreateDir
libs: import os
description: file~~~FileCreateDir is a function that checks if a directory exists, and if not, it creates the directory.~~~here is how the func looks like:~~~```htvm~~~FileCreateDir(str directory)~~~```~~~
def FileCreateDir(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileRemoveDir
libs: import shutil
description: file~~~FileRemoveDir is a function that removes a directory and its contents if the directory exists.~~~here is how the func looks like:~~~```htvm~~~FileRemoveDir(str directory)~~~```~~~
def FileRemoveDir(directory):
    if os.path.exists(directory):
        shutil.rmtree(directory)
funcEND======================funcEND==============
func======================func==============
lang: py
name: FileExist
libs: import os
description: file~~~FileExist is a function that checks if a file or directory exists at the specified path.~~~here is how the func looks like:~~~```htvm~~~FileExist(str path)~~~```~~~
def FileExist(path):
    return os.path.exists(path)
funcEND======================funcEND==============
func======================func==============
lang: py
name: isWindows
libs: import platform
description: other~~~isWindows is a function that checks if the current operating system is Windows by comparing the system name to "windows".~~~here is how the func looks like:~~~```htvm~~~isWindows()~~~```~~~
def isWindows():
    return platform.system().lower() == "windows"
funcEND======================funcEND==============
func======================func==============
lang: py
name: GetParams
libs: import os|import sys
description: io~~~GetParams is a function that retrieves command line arguments, checks if they correspond to existing paths, and returns them as absolute paths in new lines, or as they are if they do not exist.~~~here is how the func looks like:~~~```htvm~~~GetParams()~~~```~~~
def GetParams():
    # Check if any command line arguments are provided
    if len(sys.argv) < 2:
        return ""
    # Store the provided command line arguments
    params = []
    for arg in sys.argv[1:]:
        if os.path.exists(arg):
            arg = os.path.abspath(arg)
        params.append(arg)
    return "\\n".join(params)
funcEND======================funcEND==============
func======================func==============
lang: py
name: BuildInVars
libs: import time|from datetime import datetime
description: system~~~BuildInVars is a function that retrieves various system-related values or states, including screen dimensions, timestamps, key presses, and more, based on the specified variable name.~~~here is how the func looks like:~~~```htvm~~~BuildInVars(str varName)~~~```~~~
# Initialize with current timestamp
last_input_time = time.time() * 1000  # Convert to milliseconds
start_timestamp = time.time() * 1000  # Convert to milliseconds
# Function to reset the idle timer
def reset_idle_timer():
    global last_input_time
    last_input_time = time.time() * 1000  # Update last input time in milliseconds
# Function to calculate tick count in milliseconds
def A_TickCount():
    return int(time.time() * 1000 - start_timestamp)
# Function to build in variables
def BuildInVars(varName):
    now = datetime.now()
    if varName == "A_TickCount":
        # Return tick count in milliseconds
        return A_TickCount()
    elif varName == "A_Now":
        # Return current local timestamp
        return now.strftime("%Y-%m-%d %H:%M:%S")
    elif varName == "A_YYYY":
        # Return current year
        return now.strftime("%Y")
    elif varName == "A_MM":
        # Return current month
        return now.strftime("%m")
    elif varName == "A_DD":
        # Return current day
        return now.strftime("%d")
    elif varName == "A_MMMM":
        # Return full month name
        return now.strftime("%B")
    elif varName == "A_MMM":
        # Return short month name
        return now.strftime("%b")
    elif varName == "A_DDDD":
        # Return full day name
        return now.strftime("%A")
    elif varName == "A_DDD":
        # Return short day name
        return now.strftime("%a")
    elif varName == "A_Hour":
        # Return current hour
        return now.strftime("%H")
    elif varName == "A_Min":
        # Return current minute
        return now.strftime("%M")
    elif varName == "A_Sec":
        # Return current second
        return now.strftime("%S")
    elif varName == "A_Space":
        # Return space character
        return " "
    elif varName == "A_Tab":
        # Return tab character
        return "\t"
    else:
        # Handle unknown variable names
        return None
def Floor(number):
    if number > 0:
        return int(number)
    else:
        return int(number) - (1 if number != int(number) else 0)
funcEND======================funcEND==============
func======================func==============
lang: py
name: RegExReplace
libs: import re
description: string~~~RegExReplace is a function that performs a regular expression-based replacement on a string using a given pattern and replacement string.~~~here is how the func looks like:~~~```htvm~~~RegExReplace(str inputStr, str regexPattern, str replacement)~~~```~~~
def RegExReplace(inputStr, regexPattern, replacement):
    # Create a regular expression object using the provided pattern

    regex = re.compile(regexPattern, re.MULTILINE)  # re.MULTILINE for multi-line matching
    # Use the sub() method to perform the regex replacement
    resultStr = regex.sub(replacement, inputStr)
    # Return the modified string
    return resultStr
funcEND======================funcEND==============
func======================func==============
lang: py
name: RunCMD
libs: import subprocess
description: io~~~RunCMD is a function that executes a shell command and captures its output or errors.~~~here is how the func looks like:~~~```htvm~~~RunCMD(str command)~~~```~~~
def RunCMD(command):
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return e.stdout + "\n" + e.stderr
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return ""
funcEND======================funcEND==============
func======================func==============
lang: py
name: RegExMatch
libs: import re
description: string~~~RegExMatch is a function that returns the 1-based index of the first regex match or 0 if no match is found.~~~here is how the func looks like:~~~```htvm~~~RegExMatch(str haystack, str needle)~~~```~~~
def RegExMatch(haystack, needle):
    match = re.search(needle, haystack)
    return match.start() + 1 if match else 0 # 1-based index or 0 if no match
funcEND======================funcEND==============
func======================func==============
lang: py
name: ExitApp
libs: import os
description: system~~~ExitApp is a function that terminates the application immediately.~~~here is how the func looks like:~~~```htvm~~~ExitApp()~~~```~~~
# Function to handle application termination
def ExitApp():
    os._exit(1)
funcEND======================funcEND==============
func======================func==============
lang: js
name: Sort
libs: null
description: string~~~Sort is a function that takes a string and optional options to sort its elements based on various criteria such as numeric, random, alphabetical, case sensitivity, and more, with support for delimiters and unique filtering.~~~here is how the func looks like:~~~```htvm~~~Sort(str varName, [str options = ""])~~~```~~~
function Sort(varName, options = "") {
    let delimiter = '\n'; // Default delimiter
    let delimiterIndex = options.indexOf('D');
    if (delimiterIndex !== -1) {
        let delimiterChar = options[delimiterIndex + 1];
        delimiter = delimiterChar === '' ? ',' : delimiterChar;
    }
    let items = varName.split(new RegExp(delimiter === ',' ? ',' : '\\' + delimiter));
    // Remove empty items and trim whitespace
    items = items.filter(item => item.trim() !== '');
    // Apply sorting based on options
    if (options.includes('N')) {
        // Numeric sort
        items.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
    } else if (options.includes('Random')) {
        // Random sort
        for (let i = items.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [items[i], items[j]] = [items[j], items[i]];
        }
    } else {
        // Default alphabetical sort
        items.sort((a, b) => {
            const keyA = options.includes('C') ? a : a.toLowerCase();
            const keyB = options.includes('C') ? b : b.toLowerCase();
            if (keyA < keyB) return -1;
            if (keyA > keyB) return 1;
            return 0;
        });
    }
    // Reverse if 'R' option is present
    if (options.includes('R')) {
        items.reverse();
    }
    // Remove duplicates if 'U' option is present
    if (options.includes('U')) {
        const seen = new Map();
        items = items.filter(item => {
            const key = options.includes('C') ? item : item.toLowerCase();
            if (!seen.has(key)) {
                seen.set(key, item);
                return true;
            }
            return false;
        });
    }
    // Join the sorted items back into a string
    const sortedVar = items.join(delimiter === ',' ? ',' : '\n');
    return sortedVar;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: getDataFromAPI
libs: null
description: io~~~getDataFromAPI is a function that asynchronously fetches JSON data from a given URL and returns it, handling errors and non-OK responses.~~~here is how the func looks like:~~~```htvm~~~getDataFromAPI(str url)~~~```~~~
async function getDataFromAPI(url) {
	try {
	    const response = await fetch(url);
	    if (!response.ok) {
		    throw new Error("Network response was not ok");
	    }
	    const data = await response.json();
	    return data;
	} catch (error) {
	    console.error("Error fetching data:", error);
	    return null;
	}
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: getUrlParams
libs: null
description: string~~~getUrlParams is a function that extracts and decodes parameter values from the URL query string, returning a combined string of values separated by '&'.~~~here is how the func looks like:~~~```htvm~~~getUrlParams()~~~```~~~
      function getUrlParams() {
        const queryString = window.location.search.substring(1); // Get the query string without the leading '?'
        const paramPairs = queryString.split("&"); // Split the query string into parameter key-value pairs
        // Array to store parameter values starting from the first key's value
        const paramValues = [];
        // Iterate over each parameter pair
        paramPairs.forEach((pair, index) => {
          const pairParts = pair.split("=");
          if (index === 0 && pairParts.length === 2) {
            // For the first parameter pair (index === 0), add the value directly
            const firstValue = decodeURIComponent(pairParts[1]);
            paramValues.push(firstValue);
          } else if (pairParts.length === 1) {
            // For subsequent parameter pairs (values without keys), add the value directly
            const value = decodeURIComponent(pairParts[0]);
            paramValues.push(value);
          }
        });
        // Join the parameter values into a single string separated by '&'
        const resultString = paramValues.join("&");
        return resultString;
      }

funcEND======================funcEND==============
func======================func==============
lang: js
name: BuildInVars
libs: null
description: system~~~BuildInVars is a function that retrieves various system-related values or states, including screen dimensions, timestamps, key presses, and more, based on the specified variable name.~~~here is how the func looks like:~~~```htvm~~~BuildInVars(str varName)~~~```~~~
      var lastKeyPressed = "";
      function trackLastKeyPressed() {
        document.addEventListener("keydown", function (event) {
          lastKeyPressed = event.key;
          // console.log(lastKeyPressed);
        });
      }
      function getLastKeyPressed() {
        return lastKeyPressed;
      }
      // Call the trackLastKeyPressed function to start tracking key presses
      trackLastKeyPressed();
      let lastInputTime = Date.now(); // Initialize with current timestamp
      let startTimestamp = Date.now(); // Initialize with current timestamp
      // Event listener to track user activity
      function resetIdleTimer() {
        lastInputTime = Date.now(); // Update last input time
      }
      document.addEventListener("mousemove", resetIdleTimer);
      document.addEventListener("keypress", resetIdleTimer);
      // Function to calculate time since last input event
      function A_TimeIdle() {
        return Date.now() - lastInputTime; // Calculate time difference
      }
      // Function to calculate tick count in milliseconds
      function A_TickCount() {
        return Date.now() - startTimestamp;
      }
      function BuildInVars(varName) {
        switch (varName) {
          case "A_ScreenWidth":
            // Return screen width
            return window.innerWidth;
          case "A_LastKey":
            // Return screen width
            return getLastKeyPressed();
          case "A_ScreenHeight":
            // Return screen height
            return window.innerHeight;
          case "A_TimeIdle":
            // Return time idle
            return A_TimeIdle();
          case "A_TickCount":
            // Return tick count in milliseconds
            return A_TickCount();
          case "A_Now":
            // Return current local timestamp
            return new Date().toLocaleString();
          case "A_YYYY":
            // Return current year
            return new Date().getFullYear();
          case "A_MM":
            // Return current month
            return (new Date().getMonth() + 1).toString().padStart(2, "0");
          case "A_DD":
            // Return current day
            return new Date().getDate().toString().padStart(2, "0");
          case "A_MMMM":
            // Return full month name
            return new Date().toLocaleDateString(undefined, { month: "long" });
          case "A_MMM":
            // Return short month name
            return new Date().toLocaleDateString(undefined, { month: "short" });
          case "A_DDDD":
            // Return full day name
            return new Date().toLocaleDateString(undefined, { weekday: "long" });
          case "A_DDD":
            // Return short day name
            return new Date().toLocaleDateString(undefined, { weekday: "short" });
          case "A_Hour":
            // Return current hour
            return new Date().getHours().toString().padStart(2, "0");
          case "A_Min":
            // Return current minute
            return new Date().getMinutes().toString().padStart(2, "0");
          case "A_Sec":
            // Return current second
            return new Date().getSeconds().toString().padStart(2, "0");
          case "A_Space":
            // Return space character
            return " ";
          case "A_Tab":
            // Return tab character
            return "\t";
          default:
            // Handle unknown variable names
            return null;
        }
      }
funcEND======================funcEND==============
func======================func==============
lang: js
name: RegExReplace
libs: null
description: string~~~RegExReplace is a function that performs a regular expression-based replacement on a string using a given pattern and replacement string.~~~here is how the func looks like:~~~```htvm~~~RegExReplace(str inputStr, str regexPattern, str replacement)~~~```~~~
      // Function to simulate AutoHotkey's RegExReplace in JavaScript
      function RegExReplace(inputStr, regexPattern, replacement) {
          // Create a regular expression object using the provided pattern
          const regex = new RegExp(regexPattern, 'g'); // 'g' flag for global match
          // Use the replace() method to perform the regex replacement
          const resultStr = inputStr.replace(regex, replacement);
          // Return the modified string
          return resultStr;
      }
funcEND======================funcEND==============
func======================func==============
lang: js
name: RegExMatch
libs: null
description: string~~~RegExMatch is a function that returns the 1-based index of the first regex match or 0 if no match is found.~~~here is how the func looks like:~~~```htvm~~~RegExMatch(str haystack, str needle)~~~```~~~
// RegExMatch
function RegExMatch(haystack, needle) {
    const regex = new RegExp(needle);
    const match = haystack.match(regex);
    return match ? match.index + 1 : 0; // 1-based index or 0 if no match
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: MsgBox
libs: <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
description: gui~~~MsgBox is a function that displays a message box with customizable text, title, buttons, and icons, handling various options based on the provided value and timeout.~~~here is how the func looks like:~~~```htvm~~~MsgBox(str text, str [title = " "], int [value = 0], int [timeout = null])~~~```~~~
function MsgBox(text, title = " ", value = 0, timeout = null) {
    return new Promise((resolve) => {
        // Define default options for the message box
        let defaultOptions = {
            title: title || " ", // Default title is empty
            text: text || "Press OK to continue.", // Default text if not provided
            showCancelButton: false, // Default is to not show Cancel button
            showDenyButton: false, // Default is to not show Deny button
            confirmButtonText: "OK", // Default text for OK button
            focusConfirm: true, // Default focus on OK button
        };
        let numOriginal = value;
        let num = numOriginal;
        let done1 = 0;
        let done2 = 0;
        let done3 = 0;
        let AIndex = 0;
        for (AIndex = 1; AIndex <= 1; AIndex++) {
            // Handle special case for value adjustments
            if (num >= 262144) {
                num = num - 262144;
                numOriginal = numOriginal - 262144;
            }
            if (num >= 256 && num < 500) {
                num = num - 256;
                done3 = 256;
            }
            if (num >= 512) {
                num = num - 512;
                done3 = 512;
            }
            if (num == 0) {
                done1 = 0;
                break;
            }
            if (num <= 6) {
                done1 = num;
                break;
            }
            if (num >= 64 && num < 64 * 2) {
                done2 = 64;
                if (num == 64) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 64;
                    break;
                }
            }
            if (num >= 48 && num < 63) {
                done2 = 48;
                if (num == 48) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 48;
                    break;
                }
            }
            if (num >= 32 && num < 47) {
                done2 = 32;
                if (num == 32) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 32;
                    break;
                }
            }
            if (num >= 16 && num < 30) {
                done2 = 16;
                if (num == 16) {
                    done1 = 0;
                    break;
                } else {
                    done1 = num - 16;
                    break;
                }
            }
        }
        let doneAdded = done1 + done2 + done3;
        if (doneAdded !== numOriginal) {
            // displayMessage("The calc was wrong!");
        } else {
            // displayMessage("num was: " + numOriginal + "\ndone1: " + done1 + "\ndone2: " + done2 + "\ndone3: " + done3);
        }
        // Parse the value to determine the options for the message box
        if (done1 === 1) defaultOptions.showCancelButton = true;
        if (done1 === 3) {
            defaultOptions.showCancelButton = true;
            defaultOptions.showDenyButton = true;
        }
        if (done1 === 4) {
            defaultOptions.showDenyButton = true;
        }
        if (done1 === 5) {
            defaultOptions.showCancelButton = true;
        }
        if (done2 === 16) defaultOptions.icon = "error";
        if (done2 === 32) defaultOptions.icon = "question";
        if (done2 === 48) defaultOptions.icon = "warning";
        if (done2 === 64) defaultOptions.icon = "info";
        if (done3 === 256) defaultOptions.focusDeny = true;
        if (done3 === 512) defaultOptions.focusCancel = true;
        // Set timeout if provided
        if (timeout) {
            defaultOptions.timer = timeout * 1000; // Convert timeout to milliseconds
        }
        // Display the message box with the constructed options
        Swal.fire(defaultOptions).then((result) => {
            if (result.isConfirmed) {
                resolve("OK");
            } else if (result.isDenied) {
                resolve("No");
            } else {
                resolve("Cancel");
            }
        });
    });
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: guiInit
libs: null
description: null

/**
 * GUI System State
 * Stores references to elements, counters, and layout information.
 */
const guiState = {
    initialized: false,
    backgroundDiv: null,
    elements: {}, // Stores all GUI elements keyed by their ID { id: { elementRef, type, parentId, properties, children?, lastAutoPosChildElement? ... } }
    elementCounters: {}, // Stores counters for generating default IDs { div: 0, button: 0, text: 0, ... }
    lastAutoPosElement: { // For the top-level grid layout system
        id: null,
        x: 0, // Pixel value
        y: 0, // Pixel value
        width: 0, // Pixel value
        height: 0 // Pixel value
    },
    currentZIndex: 0, // For default z-index generation for top-level guiAdd divs
    autoPosGap: 20, // Gap for automatic grid layout
    idsInUse: new Set() // Keep track of all manually set and generated IDs
};

/**
 * Generates a unique default ID for an element type.
 * @param {string} elementType - The type of the element (e.g., 'div', 'button', 'text').
 * @returns {string} A unique ID (e.g., 'button0', 'text1').
 */
function generateDefaultId(elementType) {
    if (guiState.elementCounters[elementType] === undefined) {
        guiState.elementCounters[elementType] = 0;
    }
    let id;
    do {
        id = `${elementType}${guiState.elementCounters[elementType]++}`;
    } while (guiState.idsInUse.has(id)); // Ensure uniqueness
    guiState.idsInUse.add(id);
    return id;
}

/**
 * Parses a CSS property string (like '10px' or '50%') into value and unit.
 * Assumes 'px' if no unit is provided for numbers. Returns null for 'auto' or invalid.
 * @param {string | number | null} value - The value to parse.
 * @param {string} [defaultUnit='px'] - The default unit if only a number is given.
 * @returns {{value: number, unit: string} | null} - Parsed value and unit or null if not parsable numerically.
 */
function parseCssValue(value, defaultUnit = 'px') {
    if (value === null || value === undefined) return null;
    if (typeof value === 'number') {
        return { value: value, unit: defaultUnit };
    }
    if (typeof value === 'string') {
        const trimmedValue = value.trim().toLowerCase();
        if (trimmedValue === 'auto') {
            return null; // Cannot parse 'auto' numerically
        }
        const match = trimmedValue.match(/^(\d*\.?\d+)\s*([a-z%]*)$/);
        if (match) {
            const num = parseFloat(match[1]);
            const unit = match[2] || defaultUnit;
            return { value: num, unit: unit };
        }
    }
    // Allow number 0 specifically
    if (value === 0) {
        return { value: 0, unit: defaultUnit };
    }
    // console.warn(`Could not parse CSS value numerically: ${value}`); // Reduce noise
    return null; // Indicate parsing failure
}


/**
 * Applies raw CSS string to an element.
 * @param {HTMLElement} element - The element to apply styles to.
 * @param {string | null} rawCss - The raw CSS string (e.g., "color: red; font-weight: bold;").
 */
function applyRawCss(element, rawCss) {
    if (typeof rawCss === 'string' && rawCss.trim() !== '') {
        const styles = rawCss.split(';');
        styles.forEach(style => {
            if (style.trim() !== '') {
                const [property, value] = style.split(':').map(s => s.trim());
                if (property && value) {
                    const camelCaseProperty = property.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                    try {
                        // Special handling for common properties that might have existing values cleared
                        if (element.style[camelCaseProperty] !== undefined) {
                             element.style[camelCaseProperty] = value;
                        } else {
                             // Use setProperty for custom properties or less common ones
                             element.style.setProperty(property, value);
                        }
                    } catch (e) {
                        console.warn(`Failed to apply raw CSS style: ${property}:${value}`, e);
                    }
                }
            }
        });
    }
}

/**
 * Parses the border string ("size color" or "size|color"). Prefers CSS standard space separation.
 * @param {string | null} borderString
 * @param {string} [defaultSize='1px'] - Default border size
 * @param {string} [defaultColor='transparent'] - Default border color
 * @returns {{ size: string, style: string, color: string } | null}
 */
function parseBorder(borderString, defaultSize = '1px', defaultColor = 'transparent') {
    if (borderString === null || borderString === undefined || String(borderString).trim() === '') return null;

    const str = String(borderString);
    // Prioritize pipe, then space
    const parts = str.includes('|') ? str.split('|').map(s => s.trim()) : str.split(/\s+/).map(s => s.trim());

    // Basic parsing: assumes size [style] color or just size or size color
    let size = defaultSize;
    let style = 'solid';
    let color = defaultColor;

    if (parts.length === 1) {
        // Is it a color or a size? Assume size if it looks like a CSS unit value
        if (parseCssValue(parts[0])) {
            size = parts[0];
        } else {
            color = parts[0]; // Assume it's a color name/hex
        }
    } else if (parts.length === 2) {
        // Assume "size color" or "size style" or "style color" - prioritize size/color
        // If first part looks like size, assume "size color"
        if (parseCssValue(parts[0])) {
             size = parts[0];
             color = parts[1];
        } else { // Assume "style color" or "color size"? Less common, default to size/color interpretation
            size = parts[0]; // May not be a valid size, CSS handles it
            color = parts[1];
        }
    } else if (parts.length >= 3) {
        size = parts[0];
        style = parts[1]; // Add style parsing if needed
        color = parts[2];
    }

    // Ensure size has a unit if it's just a number string that's not 0
     const parsedSize = parseCssValue(size, 'px');
     if (parsedSize && parsedSize.unit === 'px' && String(size) === String(parsedSize.value) && parsedSize.value !== 0) {
         size = `${parsedSize.value}px`;
     }


    return { size: size, style: style, color: color };
}

// ==========================================================================
// HELPER: APPLY ENABLED/DISABLED STYLES (REVISED FOR CURSOR)
// ==========================================================================
/**
 * Applies visual and functional styles based on the element's effective enabled state.
 * @param {HTMLElement} element - The DOM element.
 * @param {string} elementType - The type of the element ('button', 'text', 'div', etc.).
 * @param {boolean} isEffectivelyEnabled - The calculated enabled state (considering parent).
 * @param {object} properties - The element's stored properties (needed for callback check).
 */
function _applyEnabledStyles(element, elementType, isEffectivelyEnabled, properties) {
    // Visual indication (Opacity applies universally)
    element.style.opacity = isEffectivelyEnabled ? '1' : '0.5';

    // Functional indication (Pointer events & Cursor)
    if (elementType === 'div') {
        // --- Container DIV Specific Logic ---
        if (!isEffectivelyEnabled) {
            // Disabled Container:
            // - Apply 'not-allowed' cursor via class.
            // - *DO NOT* set pointer-events: none, so hover for cursor works.
            // - Interaction is blocked because children will have pointer-events: none.
            element.classList.add('gui-container-disabled');
            // Ensure pointer-events is not 'none' if previously set
            if (element.style.pointerEvents === 'none') {
                 element.style.pointerEvents = 'auto'; // Or '', restore default behaviour
            }
        } else {
            // Enabled Container:
            // - Remove class.
            // - Restore default pointer events.
            // - Reset cursor (let children define theirs).
            element.classList.remove('gui-container-disabled');
            element.style.pointerEvents = ''; // Default browser handling
            element.style.cursor = '';
        }
    } else {
        // --- Child Element Specific Logic ---
        element.style.pointerEvents = isEffectivelyEnabled ? 'auto' : 'none';

        // Specific disabled attribute for form elements
        if (element.tagName === 'BUTTON' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || element.tagName === 'INPUT') {
            element.disabled = !isEffectivelyEnabled;
        }

        // Cursor for child elements
        element.style.cursor = ''; // Reset first

        if (isEffectivelyEnabled) {
            // Set appropriate cursor only if enabled
            const isInteractive = (
                ['button', 'toggle', 'picture', 'dropdown'].includes(elementType) ||
                ((elementType === 'rectangle' || elementType === 'circle') && properties?.callback)
            );
            if (isInteractive) {
                element.style.cursor = 'pointer';
            } else if (elementType === 'text') {
                element.style.cursor = 'default';
            } else if (elementType === 'edit'){
                element.style.cursor = 'text';
            }
        } else {
            // Child element is effectively disabled
            element.style.cursor = 'default'; // Use 'default' cursor for disabled children
        }
    }
}


// ==========================================================================
// GUI INIT FUNCTION
// ==========================================================================

/**
 * Initializes the main GUI background layer.
 * @param {string | null} [backgroundColor=null] - Background color (hex). Defaults to '#202020'.
 * @param {string | null} [centerText=null] - Text to display in the center. Defaults to null (no text).
 */
function guiInit(backgroundColor = null, centerText = null) {
    if (guiState.initialized) {
        console.warn("GUI already initialized. Re-initializing.");
        if (guiState.backgroundDiv && guiState.backgroundDiv.parentNode) {
            guiState.backgroundDiv.parentNode.removeChild(guiState.backgroundDiv);
        }
        // Reset state if re-initializing cleanly
        Object.keys(guiState.elements).forEach(id => {
             if (guiState.elements[id].elementRef && guiState.elements[id].elementRef.parentNode) {
                 guiState.elements[id].elementRef.parentNode.removeChild(guiState.elements[id].elementRef);
             }
        });
        guiState.elements = {};
        guiState.elementCounters = {};
        guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
        guiState.currentZIndex = 0;
        guiState.idsInUse.clear();
    }

    const finalBgColor = backgroundColor === null ? '#202020' : backgroundColor; // Match body style bg

    const bgDiv = document.createElement('div');
    bgDiv.id = 'gui-background';
    bgDiv.style.position = 'fixed';
    bgDiv.style.top = '0';
    bgDiv.style.left = '0';
    bgDiv.style.width = '100vw';
    bgDiv.style.height = '100vh';
    bgDiv.style.backgroundColor = finalBgColor;
    bgDiv.style.zIndex = '-1'; // Behind other content
    bgDiv.style.overflow = 'hidden'; // Prevent scrollbars

    if (typeof centerText === 'string' && centerText.trim() !== '') {
        const textElement = document.createElement('div');
        textElement.textContent = centerText;
        textElement.style.position = 'absolute';
        textElement.style.top = '50%';
        textElement.style.left = '50%';
        textElement.style.transform = 'translate(-50%, -50%)';
        textElement.style.color = 'white'; // Default color
        textElement.style.fontSize = '20px'; // Default size
        textElement.style.fontFamily = 'sans-serif'; // Default font
        textElement.style.textAlign = 'center';
        textElement.style.pointerEvents = 'none'; // Ignore clicks
        bgDiv.appendChild(textElement);
    }

    document.body.appendChild(bgDiv);
    guiState.backgroundDiv = bgDiv;
    guiState.initialized = true;
    console.log("GUI Initialized.");
}


funcEND======================funcEND==============
func======================func==============
lang: js
name: guiAdd
libs: null
description: null

// ==========================================================================
// GUI ADD FUNCTION (Adds top-level DIVs)
// ==========================================================================
/**
 * Adds or updates a main GUI container element (div).
 * If ID exists, updates the element (enters edit mode).
 * If x and y are null during creation, uses automatic grid layout.
 *
 * @param {object} options - Configuration options for the element.
 * @param {string | number | null} [options.id=null] - Element ID. Auto-generated if null. Reuses if existing.
 * @param {string | number | null} [options.x=null] - Left position ('50px', '50%'). Defaults to auto grid layout on create, center on update if null.
 * @param {string | number | null} [options.y=null] - Top position ('50px', '50%'). Defaults to auto grid layout on create, center on update if null.
 * @param {string | number | null} [options.width='50%'] - Width ('100px', '50%').
 * @param {string | number | null} [options.height='50%'] - Height ('100px', '50%').
 * @param {number | string | null} [options.zIndex=null] - Stacking order. Auto-increments if null during creation. Defaults to 'auto'.
 * @param {string | null} [options.backgroundColor=null] - Background color (hex). Defaults to transparent.
 * @param {number | string | null} [options.rounding=10] - Border radius ('px' or '%'). Null or < 0 for no rounding. Default 10px.
 * @param {string | null} [options.border=null] - Border style ("size [style] color", e.g., "1px white"). Null for no border.
 * @param {string | null} [options.rawCss=null] - Additional raw CSS string.
 * @param {boolean | null} [options.isDeleting=false] - If true, removes the element.
 * @param {boolean | null} [options.isEnabled=true] - If false, visually disables the element (opacity, pointer-events) AND ITS CHILDREN.
 * @param {boolean | null} [options.isVisible=true] - If false, hides the element (display: none).
 */
function guiAdd({
    id = null,
    x = null,
    y = null,
    width = '45%', // Default for guiAdd
    height = '45%', // Default for guiAdd
    zIndex = null, // Default to null -> auto-increment or keep existing
    backgroundColor = "#121212",
    rounding = 10, // Default rounding 10px for guiAdd
    border = null, // Default no border for guiAdd
    rawCss = null,
    isDeleting = false,
    isEnabled = true, // Default to enabled
    isVisible = true
} = {}) {

    if (!guiState.initialized) {
        console.error("GUI Add Error: guiInit() must be called first.");
        return;
    }

    let elementId = id;
    let isEditMode = false;
    let existingElementData = null;

    // --- ID Handling ---
    if (elementId === null) {
        elementId = generateDefaultId('div'); // Default type is div for guiAdd
    } else {
        elementId = String(elementId);
        if (guiState.elements[elementId]) {
            isEditMode = true;
            existingElementData = guiState.elements[elementId];
             if (existingElementData.type !== 'div') {
                 console.warn(`GUI Add Warning: Attempting to update element '${elementId}' which is not a 'div' using guiAdd. Use guiControl or guiAddElement.`);
                 // Allow update for flexibility, but warn.
             }
        } else {
            if (guiState.idsInUse.has(elementId)) {
                console.warn(`GUI Add: Provided ID ${elementId} collides with a previously generated or used ID. Behaviour might be unexpected.`);
            }
            guiState.idsInUse.add(elementId);
        }
    }

    // --- Deleting ---
    if (isDeleting) {
        if (isEditMode) {
            // Recursively delete children first (cleaner state)
            if (existingElementData.children) {
                Object.keys(existingElementData.children).forEach(childId => {
                     // Use guiControl for proper deletion logic of children if needed,
                     // but simpler to just remove element and data here
                     const childData = existingElementData.children[childId];
                     if (childData && childData.elementRef && childData.elementRef.parentNode) {
                         childData.elementRef.parentNode.removeChild(childData.elementRef);
                     }
                     guiState.idsInUse.delete(childId);
                     // No need to delete from parent's children map, as parent is being deleted
                });
            }

            const elRef = existingElementData.elementRef;
            if (elRef && elRef.parentNode) {
                elRef.parentNode.removeChild(elRef);
            }
            delete guiState.elements[elementId];
            guiState.idsInUse.delete(elementId);
            if (guiState.lastAutoPosElement.id === elementId) {
                 guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
            }
            console.log(`GUI Add: Deleted element ID: ${elementId} and its children.`);
        } else {
            if (id !== null) {
                 console.warn(`GUI Add: Attempted to delete non-existent element ID: ${elementId}`);
            }
        }
        return; // Stop execution after deletion
    }

    let divElement;
    let properties = {};
    let oldIsEnabled = true; // Assume true initially or from existing state

    if (isEditMode) {
        divElement = existingElementData.elementRef;
        properties = { ...existingElementData.properties }; // Clone properties for modification
        oldIsEnabled = properties.isEnabled; // Capture old state before potential update
    } else {
        divElement = document.createElement('div');
        divElement.id = elementId;
        divElement.style.position = 'absolute';
        divElement.style.boxSizing = 'border-box';
        divElement.style.overflow = 'hidden'; // Prevent content spill by default
        properties = {};
        // Initialize children map and layout tracker for new elements
        guiState.elements[elementId] = { // Temporarily add to state for children iteration later
            elementRef: divElement,
            type: 'div',
            parentId: null,
            properties: properties, // Reference, will be updated
            children: {},
            lastAutoPosChildElement: { x: 0, y: 0, width: 0, height: 0 }
        };
    }

    // --- Apply Properties (Create or Edit) ---

    // Visibility (Apply early)
    const finalIsVisible = isVisible !== null ? isVisible : (isEditMode ? properties.isVisible : true);
    divElement.style.display = finalIsVisible ? '' : 'none';
    properties.isVisible = finalIsVisible;

    // Size (Width, Height)
    const finalWidth = width !== null ? String(width) : (isEditMode ? properties.width : '50%');
    const finalHeight = height !== null ? String(height) : (isEditMode ? properties.height : '50%');
    divElement.style.width = finalWidth;
    divElement.style.height = finalHeight;
    properties.width = finalWidth;
    properties.height = finalHeight;

    // Position (X, Y)
    let finalX = x !== null ? String(x) : (isEditMode ? properties.x : null);
    let finalY = y !== null ? String(y) : (isEditMode ? properties.y : null);
    let needsCenteringTransform = false;
    let isAutoLayout = false;

    if (finalX === null && finalY === null && !isEditMode) {
        isAutoLayout = true;
        const last = guiState.lastAutoPosElement;
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;

        let currentW_px = 0;
        let currentH_px = 0;
        let wasAddedTemporarily = false;
        if (!document.body.contains(divElement)) {
            divElement.style.visibility = 'hidden'; divElement.style.left = '-9999px';
            document.body.appendChild(divElement); wasAddedTemporarily = true;
        }
        currentW_px = divElement.offsetWidth;
        currentH_px = divElement.offsetHeight;
        if (wasAddedTemporarily) {
            document.body.removeChild(divElement);
            divElement.style.visibility = ''; divElement.style.left = '';
        }
         if (currentW_px <= 0) {
              const parsedW = parseCssValue(finalWidth);
              currentW_px = parsedW ? ((parsedW.unit === '%') ? (screenWidth * parsedW.value / 100) : parsedW.value) : 200;
         }
         if (currentH_px <= 0) {
              const parsedH = parseCssValue(finalHeight);
              currentH_px = parsedH ? ((parsedH.unit === '%') ? (screenHeight * parsedH.value / 100) : parsedH.value) : 100;
         }

        if (last.id !== null && guiState.elements[last.id]) {
            let nextX = last.x + last.width + guiState.autoPosGap;
            let nextY = last.y;
            if (nextX + currentW_px > screenWidth - guiState.autoPosGap) {
                nextX = guiState.autoPosGap;
                nextY = last.y + last.height + guiState.autoPosGap;
            }
            finalX = nextX + 'px';
            finalY = nextY + 'px';
        } else {
            finalX = guiState.autoPosGap + 'px';
            finalY = guiState.autoPosGap + 'px';
        }
        guiState.lastAutoPosElement = {
            id: elementId, x: parseFloat(finalX), y: parseFloat(finalY),
            width: currentW_px, height: currentH_px
        };
    } else if (!isAutoLayout && (finalX === null || finalY === null || String(finalX).includes('%') || String(finalY).includes('%'))) {
         finalX = finalX ?? (isEditMode ? properties.x : '50%');
         finalY = finalY ?? (isEditMode ? properties.y : '50%');
         needsCenteringTransform = true;
    }

    divElement.style.left = finalX !== null ? String(finalX) : '';
    divElement.style.top = finalY !== null ? String(finalY) : '';
    properties.x = finalX;
    properties.y = finalY;
    divElement.style.transform = needsCenteringTransform ? `translate(-50%, -50%)` : '';

    // Z-Index
    let finalZIndex = zIndex !== null ? String(zIndex) : (isEditMode ? properties.zIndex : null);
    if (finalZIndex === null && !isEditMode) {
        finalZIndex = String(guiState.currentZIndex++);
    } else if (finalZIndex === null && isEditMode) {
         finalZIndex = properties.zIndex;
    }
    divElement.style.zIndex = finalZIndex ?? 'auto';
    properties.zIndex = finalZIndex;

    // Background Color
    const finalBgColor = backgroundColor !== null ? backgroundColor : (isEditMode ? properties.backgroundColor : null);
    divElement.style.backgroundColor = finalBgColor || 'transparent';
    properties.backgroundColor = finalBgColor;

    // Rounding
    const finalRounding = rounding !== null ? rounding : (isEditMode ? properties.rounding : 10);
    if (finalRounding !== null) {
         if (typeof finalRounding === 'string' && finalRounding.includes('%')) {
            divElement.style.borderRadius = finalRounding;
         } else if (!isNaN(parseFloat(finalRounding)) && parseFloat(finalRounding) >= 0) {
             divElement.style.borderRadius = `${parseFloat(finalRounding)}px`;
         } else {
             divElement.style.borderRadius = '0px';
         }
    } else {
        divElement.style.borderRadius = '0px';
    }
    properties.rounding = finalRounding;

    // Border
    const finalBorder = border !== null ? border : (isEditMode ? properties.border : null);
    const parsedBorder = parseBorder(finalBorder);
    divElement.style.border = parsedBorder ? `${parsedBorder.size} ${parsedBorder.style} ${parsedBorder.color}` : 'none';
    properties.border = finalBorder;

    // Raw CSS
    const finalRawCss = rawCss !== null ? rawCss : (isEditMode ? properties.rawCss : null);
    applyRawCss(divElement, finalRawCss);
    properties.rawCss = finalRawCss;

    // Enabled State (Store intent, apply effective state below)
    const finalIsEnabled = isEnabled !== null ? isEnabled : (isEditMode ? properties.isEnabled : true);
    properties.isEnabled = finalIsEnabled; // Store the element's own intended state

    // Apply enabled styles to the div itself
    _applyEnabledStyles(divElement, 'div', finalIsEnabled, properties); // Pass its own properties

    // --- Cascade Enabled State to Children (Only if state changed) ---
    const enabledStateChanged = finalIsEnabled !== oldIsEnabled;
    // Ensure we are referencing the correct element data, especially if just created
    const currentElementData = guiState.elements[elementId];

    if (enabledStateChanged && currentElementData && currentElementData.children) {
        // console.log(`Cascading isEnabled=${finalIsEnabled} from ${elementId} to children`);
        Object.values(currentElementData.children).forEach(childData => {
            if (childData && childData.elementRef) {
                // Calculate child's effective state: its own state AND parent's new state
                const childEffectiveEnabled = childData.properties.isEnabled && finalIsEnabled;
                // Apply styles based on the *effective* state, passing child's properties
                _applyEnabledStyles(childData.elementRef, childData.type, childEffectiveEnabled, childData.properties);
            }
        });
    }

    // --- Add to DOM and State (if new) ---
    if (!isEditMode) {
        document.body.appendChild(divElement); // Add to body
        // Update the properties in the already created state entry
        guiState.elements[elementId].properties = properties;
    } else {
         // Update state for edited element (properties already updated)
         existingElementData.properties = properties; // Ensure update if reference changed
    }
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: guiAddElement
libs: null
description: null


// ==========================================================================
// GUI ADD ELEMENT FUNCTION (MODIFIED to handle optional parentId)
// ==========================================================================

/**
 * Adds or updates an element (button, text, etc.).
 * If parentId is provided, adds inside that container.
 * If parentId is NOT provided, adds directly to the main background.
 * Handles effective enabled state based on parent (if any).
 * Uses global auto-layout if no parentId AND no x/y provided.
 * Uses parent's auto-layout if parentId is provided AND no x/y provided.
 *
 * @param {object} options - Configuration options for the element.
 * @param {string | number | null} [options.parentId=null] - ID of the parent container (optional). If null/omitted, adds to background.
 * @param {string} options.elementType - Required type of element ('button', 'text', etc.).
 * @param {string | number | null} [options.id=null] - Element ID. Auto-generated if null. Reuses if existing (within parent or globally if no parent).
 * @param {string | number | null} [options.x=null] - Left position. Relative to parent if parentId given, otherwise absolute. Auto-layout if null.
 * @param {string | number | null} [options.y=null] - Top position. Relative to parent if parentId given, otherwise absolute. Auto-layout if null.
 * @param {string | number | null} [options.width=null] - Width. Defaults vary by elementType.
 * @param {string | number | null} [options.height=null] - Height. Defaults vary by elementType.
 * @param {number | string | null} [options.zIndex=null] - Stacking order. Auto-increments globally if null & no parentId. Defaults 'auto' inside parent.
 * @param {any} [options.value=null] - Content/state (text, URL, boolean, options string). Defaults vary.
 * @param {string | null} [options.placeholder=null] - Placeholder text (for 'edit').
 * @param {function | string | null} [options.callback=null] - Interaction callback function or name.
 * @param {string | null} [options.backgroundColor=null] - Background color. Defaults vary.
 * @param {string | null} [options.color=null] - Text color. Defaults vary.
 * @param {number | string | null} [options.rounding=null] - Border radius. Defaults vary.
 * @param {string | null} [options.border=null] - Border style. Defaults vary.
 * @param {string | null} [options.rawCss=null] - Additional raw CSS string.
 * @param {number | null} [options.size=null] - Font size (for text-based elements). Defaults vary.
 * @param {boolean | null} [options.isDeleting=false] - If true, removes the element.
 * @param {boolean | null} [options.isEnabled=true] - Element's own intended enabled state.
 * @param {boolean | null} [options.isVisible=true] - Visibility (display: none).
 */
function guiAddElement({
    // Core Identification & Placement
    id = null,
    parentId = null, // <<< MADE OPTIONAL (default null)
    elementType, // Required
    x = null,
    y = null,
    zIndex = null, // Handled differently if top-level

    // Dimensions
    width = null,
    height = null,
    size = null, // Font size

    // Content & State
    value = null,
    placeholder = null,
    isEnabled = true, // Element's own desired state
    isVisible = true,

    // Styling
    backgroundColor = null,
    color = null,
    rounding = null,
    border = null,
    rawCss = null,

    // Interaction & Deletion
    callback = null,
    isDeleting = false

} = {}) { // <<< Added default empty object for destructuring

    // --- INITIAL CHECKS ---
    if (!guiState.initialized) {
        console.error("GUI Add Element Error: guiInit() must be called first.");
        return;
    }
    const validElementTypes = ['button', 'text', 'edit', 'picture', 'toggle', 'rectangle', 'circle', 'video', 'dropdown', 'iframe'];
    if (!elementType || !validElementTypes.includes(elementType)) {
        console.error(`GUI Add Element Error: Invalid or missing elementType. Must be one of: ${validElementTypes.join(', ')}`); return;
    }

    // --- DETERMINE PARENT CONTEXT ---  <<< NEW SECTION >>>
    let parentData = null;
    let parentElement = null;
    let parentIdStr = parentId !== null ? String(parentId) : null; // Keep track if a parent was intended
    let isTopLevelElement = false; // Flag if added directly to background

    if (parentIdStr !== null) {
        // Parent ID provided: Validate and get parent data/element (Original Logic)
        if (!guiState.elements[parentIdStr] || guiState.elements[parentIdStr].type !== 'div') {
            console.error(`GUI Add Element Error: Parent container with ID '${parentIdStr}' not found or is not a div.`); return;
        }
        parentData = guiState.elements[parentIdStr];
        parentElement = parentData.elementRef;
        isTopLevelElement = false;
    } else {
        // No parent ID provided: Use background div
        parentElement = guiState.backgroundDiv;
        parentData = null; // No structured parent data in guiState.elements for the background itself
        isTopLevelElement = true;
        if (!parentElement) {
            // This check prevents adding to background if guiInit wasn't called
            console.error("GUI Add Element Error: Cannot add element without parentId because guiInit() has not been called or backgroundDiv is missing.");
            return;
        }
    }
    // --- END NEW SECTION ---


    // --- ID Handling --- <<< MODIFIED >>>
    let elementId = id;
    let isEditMode = false;
    let existingElementData = null;
    let oldIsEnabled = true; // For checking change later

    if (elementId === null) {
        elementId = generateDefaultId(elementType); // Global uniqueness check happens here
    } else {
        elementId = String(elementId);
        // Check for existing element: either in parent's children OR in global state if top-level
        if (!isTopLevelElement && parentData.children && parentData.children[elementId]) {
            // Existing child element within the specified parent
            isEditMode = true;
            existingElementData = parentData.children[elementId];
            if (existingElementData.type !== elementType) {
                 console.warn(`GUI Add Element Warning: Attempting to change elementType for child ID '${elementId}' from '${existingElementData.type}' to '${elementType}'.`);
            }
        } else if (isTopLevelElement && guiState.elements[elementId]) {
            // Existing top-level element (could be a div OR a non-div added previously without parentId)
            existingElementData = guiState.elements[elementId];
            // Prevent controlling divs with guiAddElement, guide user to guiAdd/guiControl
            if (existingElementData.type === 'div') {
                 console.warn(`GUI Add Element Warning: Attempting to control a 'div' element '${elementId}' using guiAddElement. Use guiAdd or guiControl instead.`);
                 return; // Stop execution to prevent incorrect control
            }
             if (existingElementData.type !== elementType) {
                 console.warn(`GUI Add Element Warning: Attempting to change elementType for top-level element ID '${elementId}' from '${existingElementData.type}' to '${elementType}'.`);
             }
            isEditMode = true; // It exists globally and is not a div
        } else {
             // New element ID, ensure it's globally unique before adding
             if (guiState.idsInUse.has(elementId)) {
                 // Warn about collision, specifying context
                 const locationMsg = isTopLevelElement ? "globally" : `for parent ${parentIdStr}`;
                 console.warn(`GUI Add Element: Provided ID ${elementId} ${locationMsg} collides with a previously generated or used ID.`);
             }
             // Add to the global set regardless of where it will be stored in the state tree
             guiState.idsInUse.add(elementId);
        }

        // Capture old state if editing an existing element
        if(isEditMode && existingElementData) {
             oldIsEnabled = existingElementData.properties.isEnabled;
             // No automatic type change handling here beyond the warning above
        }
    }

     // --- Deleting --- <<< MODIFIED >>>
    if (isDeleting) {
        // We only proceed with deletion if we found the element in edit mode
        if (isEditMode && existingElementData) {
            const elRef = existingElementData.elementRef;
            if (elRef && elRef.parentNode) {
                elRef.parentNode.removeChild(elRef); // Remove from DOM
            }
            // Remove from state: either parent's children or global state
            if (!isTopLevelElement) {
                delete parentData.children[elementId]; // Remove from parent's children map
            } else {
                delete guiState.elements[elementId]; // Remove from global elements map
                 // Recalculate global last auto-pos element if the deleted one was the last
                if (guiState.lastAutoPosElement.id === elementId) {
                    // Simple reset - a more complex recalculation might be needed for perfect layout
                    guiState.lastAutoPosElement = { id: null, x: 0, y: 0, width: 0, height: 0 };
                }
            }
            guiState.idsInUse.delete(elementId); // Free up the ID
            const locationMsg = isTopLevelElement ? "globally" : `from parent ${parentIdStr}`;
            console.log(`GUI Add Element: Deleted element ID: ${elementId} ${locationMsg}`);
        } else {
            // Only warn if an explicit ID was given for deletion but not found
            if (id !== null) {
                 console.warn(`GUI Add Element: Attempted to delete non-existent element ID: ${elementId}`);
            }
        }
        return; // Stop execution after deletion attempt
    }

    // --- Element Creation / Property Setup --- <<< MODIFIED to use existingElementData for edit mode >>>
    let element;
    let properties = {};

    if (isEditMode) {
        element = existingElementData.elementRef;
        properties = { ...existingElementData.properties }; // Clone existing properties for modification
    } else {
        // Create the actual DOM element based on type
        // ... (switch statement for element creation, exactly as before, assigns to 'element') ...
        switch (elementType) {
             case 'button': element = document.createElement('button'); element.style.textAlign = 'center'; element.style.padding = '5px'; break;
             case 'text': element = document.createElement('p'); element.style.margin = '0'; element.style.padding = '0'; element.style.userSelect = 'none'; break;
             case 'edit': element = document.createElement('textarea'); element.style.resize = 'none'; element.style.padding = '5px'; element.style.fontFamily = 'inherit'; element.style.fontSize = 'inherit'; break;
             case 'picture': element = document.createElement('img'); element.style.objectFit = 'contain'; element.style.display = 'block'; element.style.userSelect = 'none'; element.style.maxWidth = '100%'; element.style.maxHeight = '100%'; break;
             case 'toggle': element = document.createElement('div'); element.classList.add('gui-toggle'); element.style.position = 'relative'; element.style.overflow = 'hidden'; element.style.transition = 'background-color 0.3s'; element.style.userSelect = 'none'; const slider = document.createElement('div'); slider.classList.add('gui-toggle-slider'); slider.style.position = 'absolute'; slider.style.backgroundColor = 'white'; slider.style.borderRadius = '50%'; slider.style.transition = 'transform 0.3s ease'; element.appendChild(slider); break;
             case 'rectangle': element = document.createElement('div'); element.style.userSelect = 'none'; break;
             case 'circle': element = document.createElement('div'); element.style.userSelect = 'none'; break;
             case 'video': element = document.createElement('iframe'); element.setAttribute('frameborder', '0'); element.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share'); element.setAttribute('allowfullscreen', ''); element.setAttribute('referrerpolicy','strict-origin-when-cross-origin'); break;
             case 'dropdown': element = document.createElement('select'); element.style.padding = '5px'; element.style.fontFamily = 'inherit'; element.style.fontSize = 'inherit'; break;
             case 'iframe': element = document.createElement('iframe'); element.setAttribute('frameborder', '0'); element.setAttribute('referrerpolicy','strict-origin-when-cross-origin'); break;
             default: console.warn("GUI Add Element: Unknown element type fallback:", elementType); element = document.createElement('div'); break;
        }
        element.id = elementId;
        element.style.position = 'absolute'; // All elements are absolutely positioned
        element.style.boxSizing = 'border-box';
        properties = {}; // Start fresh properties for new element
    }


    // --- Element Type Specific Defaults --- <<< MOVED definition up, logic remains similar >>>
    let defaultWidth, defaultHeight, defaultBgColor, defaultColor, defaultRounding, defaultBorder, defaultValue, defaultPlaceholder, defaultFontSize, defaultZIndex = 'auto'; // default zIndex for children
    // Assign defaults based on elementType (same switch as before, just getting values)
     switch (elementType) {
         case 'button': defaultWidth = '100px'; defaultHeight = '30px'; defaultBgColor = '#4CAF50'; defaultColor = 'white'; defaultRounding = 5; defaultValue = `Button`; defaultBorder = null; defaultFontSize = 14; break;
         case 'text': defaultWidth = 'auto'; defaultHeight = 'auto'; defaultColor = 'white'; defaultBgColor = 'transparent'; defaultRounding = 0; defaultValue = `Text`; defaultBorder = null; defaultFontSize = 16; break;
         case 'edit': defaultWidth = '150px'; defaultHeight = '30px'; defaultBgColor = 'white'; defaultColor = 'black'; defaultRounding = 3; defaultValue = ''; defaultPlaceholder = ''; defaultBorder = '1px solid #ccc'; defaultFontSize = 14; break;
         case 'picture': defaultWidth = 'auto'; defaultHeight = 'auto'; defaultBgColor = 'transparent'; defaultRounding = 0; defaultValue = null; defaultBorder = null; break;
         case 'toggle': defaultWidth = '60px'; defaultHeight = '30px'; defaultBgColor = '#ccc'; defaultRounding = 15; defaultValue = false; defaultBorder = null; break;
         case 'rectangle': defaultWidth = '100px'; defaultHeight = '50px'; defaultBgColor = '#555'; defaultRounding = 0; defaultBorder = null; break;
         case 'circle': defaultWidth = '50px'; defaultHeight = '50px'; defaultBgColor = '#555'; defaultRounding = '50%'; defaultBorder = null; break;
         case 'video': defaultWidth = '320px'; defaultHeight = '180px'; defaultRounding = 0; defaultBorder = null; defaultValue = ''; break;
         case 'dropdown': defaultWidth = '150px'; defaultHeight = '30px'; defaultRounding = 3; defaultBorder = '1px solid #ccc'; defaultColor = 'black'; defaultBgColor = 'white'; defaultValue = ''; defaultFontSize = 14; break;
         case 'iframe': defaultWidth = '300px'; defaultHeight = '200px'; defaultRounding = 0; defaultBorder = '1px solid #ccc'; defaultValue = ''; break;
         default: defaultWidth = 'auto'; defaultHeight = 'auto'; defaultBgColor = 'transparent'; defaultColor = 'white'; defaultRounding = 0; defaultBorder = null; defaultValue = ''; defaultFontSize = 14; break; // Generic fallback defaults
    }


    // --- Apply Common Properties (Merging Options, Defaults, Existing) ---

    // 1. Visibility (Apply early for measurement)
    const finalIsVisible = isVisible !== null ? isVisible : (isEditMode ? properties.isVisible : true);
    properties.isVisible = finalIsVisible; // Store intent

    // 2. Size (Width, Height)
    const finalWidth = width !== null ? String(width) : (isEditMode ? properties.width : defaultWidth);
    const finalHeight = height !== null ? String(height) : (isEditMode ? properties.height : defaultHeight);
    element.style.width = finalWidth !== null ? finalWidth : '';
    element.style.height = finalHeight !== null ? finalHeight : '';
    properties.width = finalWidth;
    properties.height = finalHeight;

    // 3. Position (X, Y) - Handles different auto-layout contexts <<< MODIFIED >>>
    let finalX = x !== null ? String(x) : (isEditMode ? properties.x : null);
    let finalY = y !== null ? String(y) : (isEditMode ? properties.y : null);
    let isAutoLayout = false;
    let needsCenteringTransform = false; // Flag for applying translate(-50%, -50%)

    if (finalX === null && finalY === null && !isEditMode) { // Only apply auto-layout on creation
        isAutoLayout = true;
        // Temporarily add to parent (could be background or a div) to measure
        let currentW_px = 0, currentH_px = 0, wasAddedTemporarily = false;
        // Ensure element is displayable for measurement, even if finalIsVisible is false
        const originalDisplay = element.style.display;
        if (!parentElement.contains(element)) {
             element.style.visibility = 'hidden'; element.style.display = ''; // Ensure display for offsetWidth/Height
             element.style.position = 'absolute'; element.style.left = '-9999px';
             parentElement.appendChild(element); wasAddedTemporarily = true;
        }
        currentW_px = element.offsetWidth;
        currentH_px = element.offsetHeight;
        if (wasAddedTemporarily) { parentElement.removeChild(element); element.style.visibility = ''; element.style.left = ''; }
        element.style.display = originalDisplay; // Restore original intended display

        // Fallback size calculation if measurement failed (e.g., parent not visible yet)
        if (currentW_px <= 0) { const parsedW = parseCssValue(finalWidth); const parentWidthPx = parentElement.clientWidth || window.innerWidth; currentW_px = parsedW ? ((parsedW.unit === '%') ? (parentWidthPx * parsedW.value / 100) : parsedW.value) : (parseCssValue(defaultWidth)?.value || 100); }
        if (currentH_px <= 0) { const parsedH = parseCssValue(finalHeight); const parentHeightPx = parentElement.clientHeight || window.innerHeight; currentH_px = parsedH ? ((parsedH.unit === '%') ? (parentHeightPx * parsedH.value / 100) : parsedH.value) : (parseCssValue(defaultHeight)?.value || 30); }


        if (isTopLevelElement) {
            // *** Use GLOBAL auto-layout ***
            const last = guiState.lastAutoPosElement; // Use global tracker
            const screenWidth = window.innerWidth;
            if (last.id !== null && guiState.elements[last.id]) { // Check if there WAS a previous element
                let nextX = last.x + last.width + guiState.autoPosGap;
                let nextY = last.y;
                 // Wrap condition based on screen width
                 if (nextX + currentW_px > screenWidth - guiState.autoPosGap) {
                    nextX = guiState.autoPosGap;
                    nextY = last.y + last.height + guiState.autoPosGap; // Simple wrap Y based on last element height
                }
                finalX = nextX + 'px';
                finalY = nextY + 'px';
            } else { // First top-level auto-positioned element
                finalX = guiState.autoPosGap + 'px';
                finalY = guiState.autoPosGap + 'px';
            }
            // Update GLOBAL tracker
            guiState.lastAutoPosElement = { id: elementId, x: parseFloat(finalX), y: parseFloat(finalY), width: currentW_px, height: currentH_px };
        } else {
            // *** Use PARENT's auto-layout ***
             if (!parentData.lastAutoPosChildElement) { parentData.lastAutoPosChildElement = { x: 0, y: 0, width: 0, height: 0 }; } // Initialize if needed
            const last = parentData.lastAutoPosChildElement;
            const parentWidthPx = parentElement.clientWidth; // Use actual parent width for wrapping
            let nextX = 0; let nextY = 0;
            if (last && last.width > 0 ) { // Check if there WAS a previous auto-pos child in this parent
                nextX = last.x + last.width + guiState.autoPosGap; nextY = last.y;
                // Wrap condition within the PARENT
                if (parentWidthPx > 0 && (nextX + currentW_px > parentWidthPx - guiState.autoPosGap)) {
                    nextX = guiState.autoPosGap; nextY = last.y + last.height + guiState.autoPosGap;
                }
            } else { // First auto-pos child in this parent
                 nextX = guiState.autoPosGap; nextY = guiState.autoPosGap;
            }
            finalX = nextX + 'px'; finalY = nextY + 'px';
            // Update PARENT'S tracker
            parentData.lastAutoPosChildElement = { x: nextX, y: nextY, width: currentW_px, height: currentH_px };
        }
    } else if (!isAutoLayout && (finalX === null || finalY === null || String(finalX).includes('%') || String(finalY).includes('%'))) {
         // Centering logic (applies whether top-level or child if % or null used, unless explicit px given for both)
         finalX = finalX ?? (isEditMode ? properties.x : '50%'); // Default to 50% for centering if null
         finalY = finalY ?? (isEditMode ? properties.y : '50%'); // Default to 50% for centering if null
         needsCenteringTransform = true; // Assume centering needed
         // Avoid transform if specific pixel values are given for BOTH x and y
         if(parseCssValue(finalX)?.unit !== '%' && parseCssValue(finalY)?.unit !== '%'){
             needsCenteringTransform = false;
         }
    }

    element.style.left = finalX !== null ? String(finalX) : '';
    element.style.top = finalY !== null ? String(finalY) : '';
    properties.x = finalX;
    properties.y = finalY;
    element.style.transform = needsCenteringTransform ? `translate(-50%, -50%)` : ''; // Apply centering transform if needed

    // 4. Apply final display state now positioning is done
    element.style.display = finalIsVisible ? '' : 'none';

    // 5. Z-Index <<< MODIFIED >>>
    let finalZIndex = zIndex !== null ? String(zIndex) : (isEditMode ? properties.zIndex : null);
    if (finalZIndex === null && !isEditMode) {
         // Assign z-index from global counter ONLY for new top-level elements
         if (isTopLevelElement) {
             finalZIndex = String(guiState.currentZIndex++);
         } else {
             finalZIndex = defaultZIndex; // Use element's default ('auto') for children
         }
    } else if (finalZIndex === null && isEditMode) {
         // Keep existing z-index if null is passed during an update
         finalZIndex = properties.zIndex;
    }
    element.style.zIndex = finalZIndex ?? 'auto'; // Fallback to auto
    properties.zIndex = finalZIndex;


    // 6. Value / Content / Source / Placeholder (Logic mostly unchanged)
    const finalValue = value !== null ? value : (isEditMode ? properties.value : defaultValue);
    properties.value = finalValue; // Always store the final value intent
    const finalPlaceholder = placeholder !== null ? placeholder : (isEditMode ? properties.placeholder : defaultPlaceholder);
    properties.placeholder = finalPlaceholder; // Store placeholder intent

    // Apply value based on type (logic largely unchanged, added checks for element existence)
    if (elementType === 'edit' && element) {
        element.value = finalValue !== null ? String(finalValue) : '';
        element.placeholder = finalPlaceholder !== null ? String(finalPlaceholder) : '';
    } else if ((elementType === 'button' || elementType === 'text') && element) {
        element.textContent = finalValue !== null ? String(finalValue) : '';
    } else if (elementType === 'picture' && element) {
        const newSrc = finalValue !== null ? String(finalValue) : '';
        if (element.src !== newSrc) element.src = newSrc;
        element.alt = elementId; // Use ID as alt text
        element.onerror = () => { console.warn(`GUI Picture Error: Failed to load image for ID '${elementId}' from src: ${element.src}`); element.style.border = '1px dashed red'; };
    } else if ((elementType === 'video' || elementType === 'iframe') && element) {
        let srcUrl = finalValue !== null ? String(finalValue) : '';
        // YouTube embed conversion (only for video type)
        if(elementType === 'video') {
             const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
             const match = srcUrl.match(youtubeRegex);
             if (match && match[1]) {
                 srcUrl = `https://www.youtube.com/embed/${match[1]}`;
             }
        }
        // Set src only if changed
        if (element.src !== srcUrl) {
             element.src = srcUrl;
        }
    } else if (elementType === 'dropdown' && element) {
        const optionsString = finalValue !== null ? String(finalValue) : '';
        const options = optionsString.split('|').map(opt => opt.trim()).filter(opt => opt !== '');
        // Determine selected value - prioritize current element.value if options change slightly, then stored, then first option
         let targetSelectedValue = null;
         const currentElementValue = element.value; // Value currently selected in the DOM element
         const storedSelectedValue = properties.selectedValue; // Value we intended last time

         if (options.includes(currentElementValue)) { // If current DOM value is still valid
              targetSelectedValue = currentElementValue;
         } else if (options.includes(storedSelectedValue)) { // If previous stored value is still valid
              targetSelectedValue = storedSelectedValue;
         } else if (options.length > 0) { // Otherwise, default to first new option
              targetSelectedValue = options[0];
         }

         // Rebuild options only if they have actually changed
         let optionsChanged = false;
         if (element.options.length !== options.length) {
              optionsChanged = true;
         } else {
              for (let i = 0; i < options.length; i++) {
                   if (!element.options[i] || element.options[i].value !== options[i]) {
                        optionsChanged = true;
                        break;
                   }
              }
         }

         if (optionsChanged) {
              element.innerHTML = ''; // Clear existing options
              options.forEach(optText => {
                   const option = document.createElement('option');
                   option.value = optText;
                   option.textContent = optText;
                   element.appendChild(option);
              });
         }

         properties.selectedValue = targetSelectedValue; // Store the intended selection
         if (targetSelectedValue !== null) {
              element.value = targetSelectedValue; // Apply selection to the DOM element
         } else if (element.options.length > 0) {
             element.selectedIndex = -1; // Deselect if target is null
         }
    } else if (elementType === 'toggle' && element) {
         // Ensure stored value is strictly boolean
         properties.value = finalValue === true || String(finalValue).toLowerCase() === 'true';
         element.dataset.value = properties.value; // Use data attribute for state visualization if needed
    }


    // 7. Background Color
    const finalBgColor = backgroundColor !== null ? backgroundColor : (isEditMode ? properties.backgroundColor : defaultBgColor);
     if (elementType !== 'toggle') { // Toggle background is handled based on state later
        element.style.backgroundColor = finalBgColor || ''; // Use default or transparent if null/empty
     }
    properties.backgroundColor = finalBgColor; // Store base color (used by toggle for off state)

    // 8. Text Color
    const finalColor = color !== null ? color : (isEditMode ? properties.color : defaultColor);
    element.style.color = finalColor || '';
    properties.color = finalColor;

    // 9. Font Size
    const finalFontSize = size !== null ? size : (isEditMode ? properties.size : defaultFontSize);
    if (['text', 'button', 'edit', 'dropdown'].includes(elementType) && finalFontSize !== null) {
        element.style.fontSize = `${parseFloat(finalFontSize)}px`;
        properties.size = finalFontSize;
    } else {
         // Clear font size if explicitly set back to null during edit
         if (isEditMode && properties.size !== null && size === null) { element.style.fontSize = ''; }
         properties.size = finalFontSize; // Store null if cleared
    }

    // 10. Rounding
    const finalRounding = rounding !== null ? rounding : (isEditMode ? properties.rounding : defaultRounding);
     if (finalRounding !== null) {
          if (elementType === 'circle') { element.style.borderRadius = '50%'; } // Force circle
          else if (typeof finalRounding === 'string' && finalRounding.includes('%')) { element.style.borderRadius = finalRounding; }
          else if (!isNaN(parseFloat(finalRounding)) && parseFloat(finalRounding) >= 0) { element.style.borderRadius = `${parseFloat(finalRounding)}px`; }
          else { element.style.borderRadius = '0px'; } // Default to 0 if invalid
     } else { element.style.borderRadius = '0px'; } // Default to 0 if null
    properties.rounding = finalRounding;

    // 11. Border
    const finalBorder = border !== null ? border : (isEditMode ? properties.border : defaultBorder);
    const parsedBorder = parseBorder(finalBorder);
    element.style.border = parsedBorder ? `${parsedBorder.size} ${parsedBorder.style} ${parsedBorder.color}` : 'none';
    properties.border = finalBorder;

    // 12. Raw CSS (Apply last before enabled state/visual updates)
    const finalRawCss = rawCss !== null ? rawCss : (isEditMode ? properties.rawCss : null);
    applyRawCss(element, finalRawCss); // Applies the new styles
    properties.rawCss = finalRawCss;

    // 13. Enabled State (Store intent, calculate effective state) <<< MODIFIED >>>
    const finalIsEnabled = isEnabled !== null ? isEnabled : (isEditMode ? properties.isEnabled : true);
    properties.isEnabled = finalIsEnabled; // Store the element's own intended state

    // Calculate effective state based on self AND parent (if exists)
    // Assume background (parent if isTopLevelElement) is always enabled
    const parentIsEnabled = !isTopLevelElement ? parentData.properties.isEnabled : true;
    const effectiveIsEnabled = finalIsEnabled && parentIsEnabled;

    // Apply styles based on the EFFECTIVE state
    // This happens *before* toggle visual update, as toggle needs correct dimensions/opacity
    _applyEnabledStyles(element, elementType, effectiveIsEnabled, properties);


    // --- Special Visual Updates (Toggle - after styles applied) ---
    if (elementType === 'toggle') {
         const slider = element.querySelector('.gui-toggle-slider');
         if (slider) {
             const isOn = properties.value; // Use the processed boolean value
             const offBg = properties.backgroundColor || defaultBgColor || '#ccc'; // Use stored base color for off state
             const onBg = '#4CAF50'; // Hardcoded 'on' color
             element.style.backgroundColor = isOn ? onBg : offBg; // Set background based on state

             // Measure and position slider (only if visible and dimensions are valid)
             // Use effective visibility for this check
             const computedStyle = window.getComputedStyle(element);
             if(computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {
                 let needsMeasure = !parentElement.contains(element); // Check if attached for measurement
                 if (needsMeasure) { element.style.visibility = 'hidden'; parentElement.appendChild(element); }

                 const elementHeightPx = element.clientHeight; const elementWidthPx = element.clientWidth;
                 if (elementHeightPx > 0 && elementWidthPx > 0) {
                      const padding = 4; const sliderSize = Math.max(1, elementHeightPx - padding); // Ensure size is at least 1px
                      slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                      slider.style.left = `${padding / 2}px`; slider.style.bottom = `${padding / 2}px`;
                      // Calculate max translation distance correctly
                      const maxTranslate = Math.max(0, elementWidthPx - sliderSize - padding);
                      const sliderTranslateX = isOn ? maxTranslate : 0;
                      slider.style.transform = `translateX(${sliderTranslateX}px)`;
                 } else {
                      console.warn(`GUI Toggle Warning: Cannot accurately size slider for toggle '${elementId}' (measured height/width is zero).`);
                      // Apply fallback size based on defaults if measurement fails
                      const fallbackH = parseCssValue(finalHeight)?.value || parseCssValue(defaultHeight)?.value || 30; const sliderSize = Math.max(1, fallbackH - 4); slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                 }

                 if (needsMeasure) { parentElement.removeChild(element); element.style.visibility = ''; }
             } else {
                 // If not visible, set a fallback size without positioning
                 const fallbackH = parseCssValue(finalHeight)?.value || parseCssValue(defaultHeight)?.value || 30; const sliderSize = Math.max(1, fallbackH - 4); slider.style.height = `${sliderSize}px`; slider.style.width = `${sliderSize}px`;
                 slider.style.transform = 'translateX(0px)'; // Reset position
             }
         } else if(!isEditMode && element) { // Check element exists for new toggles
              console.error(`GUI Toggle Error: Could not find .gui-toggle-slider for new toggle '${elementId}'.`);
         }
    }

    // 14. Callback / Event Listener <<< MODIFIED >>>
    const finalCallback = callback !== null ? callback : (isEditMode ? properties.callback : null);
    properties.callback = finalCallback; // Store the callback reference/name

    // Remove previous listener before adding a new one (important for updates)
    const listenerInfo = element.__guiListenerInfo;
    if (listenerInfo) { element.removeEventListener(listenerInfo.type, listenerInfo.handler); element.__guiListenerInfo = null; }

    let eventType = null; let eventListener = null;

    if (finalCallback) {
        // Resolve callback function (either direct reference or name string)
        const callbackFunction = (typeof finalCallback === 'function') ? finalCallback : window[finalCallback];

        if (typeof callbackFunction === 'function') {
            const currentElementId = elementId; // Capture ID for the closure
            const currentParentIdStr = parentIdStr; // <<< Capture parent ID status for the closure >>>

            const eventHandlerWrapper = (event) => {
                 // <<< Get current element and parent data AT EVENT TIME >>>
                 let elementDataNow = null;
                 let parentDataNow = null; // Will be null if top-level
                 if (currentParentIdStr !== null && guiState.elements[currentParentIdStr]) {
                      // It's a child element, get parent and then child data
                      parentDataNow = guiState.elements[currentParentIdStr];
                      elementDataNow = parentDataNow?.children?.[currentElementId];
                 } else {
                      // It's a top-level element, get directly from global state
                      elementDataNow = guiState.elements[currentElementId];
                 }

                 // If element data was somehow removed between adding listener and event firing
                 if (!elementDataNow) {
                     console.warn(`Callback for ${currentElementId} triggered, but element data not found in state.`);
                     return;
                 }

                 // Check the effective enabled state AT THE TIME OF THE EVENT
                 const currentParentIsEnabled = parentDataNow ? (parentDataNow.properties?.isEnabled ?? true) : true; // Assume background enabled
                 const elementIsEnabled = elementDataNow.properties?.isEnabled ?? true; // Default to true if property missing

                 if (elementIsEnabled && currentParentIsEnabled) { // Check BOTH states
                     try {
                         // Logic to update state and call user function based on type
                         if (elementType === 'edit') {
                             const newValue = event.target.value;
                             elementDataNow.properties.value = newValue; // Update state
                             callbackFunction(currentElementId, newValue, event);
                         } else if (elementType === 'dropdown') {
                             const newValue = event.target.value;
                              elementDataNow.properties.selectedValue = newValue; // Update selected state
                             callbackFunction(currentElementId, newValue, event);
                         } else if (elementType === 'toggle') {
                             const newState = !elementDataNow.properties.value; // Calculate new state
                             elementDataNow.properties.value = newState; // Update state first
                             element.dataset.value = newState; // Update data attribute

                             // Update toggle visuals immediately within the handler for responsiveness
                             const slider = element.querySelector('.gui-toggle-slider');
                             const offBg = elementDataNow.properties.backgroundColor || defaultBgColor || '#ccc';
                             const onBg = '#4CAF50';
                             element.style.backgroundColor = newState ? onBg : offBg;
                             if (slider) {
                                 const elementHeightPx = element.clientHeight; const elementWidthPx = element.clientWidth; const padding = 4; const sliderSize = Math.max(1, elementHeightPx - padding);
                                 const maxTranslate = Math.max(0, elementWidthPx - sliderSize - padding);
                                 const sliderTranslateX = newState ? maxTranslate : 0;
                                 slider.style.transform = `translateX(${sliderTranslateX}px)`;
                              }
                             callbackFunction(currentElementId, newState, event); // Call user callback AFTER state/visuals updated
                         } else { // Button, Picture, Rectangle, Circle
                              callbackFunction(currentElementId, event);
                         }
                     } catch (e) {
                         console.error(`Error executing callback for element ${currentElementId}:`, e);
                     }
                 } else {
                      // Interaction blocked due to disabled state
                      // console.log(`Interaction blocked for ${currentElementId} (elementEnabled: ${elementIsEnabled}, parentEnabled: ${currentParentIsEnabled})`);
                      event.preventDefault(); // Prevent default actions if needed (like form submission if inside form)
                      event.stopPropagation(); // Stop event bubbling
                 }
            };

            // Determine event type based on element
            if (['button', 'picture', 'rectangle', 'circle', 'toggle'].includes(elementType)) { eventType = 'click'; }
            else if (elementType === 'edit') { eventType = 'input'; }
            else if (elementType === 'dropdown') { eventType = 'change'; }

            // Add the listener if an event type was determined
            if (eventType) {
                 eventListener = eventHandlerWrapper;
                 element.addEventListener(eventType, eventListener);
                 // Store listener info on the element itself for easy removal later
                 element.__guiListenerInfo = { type: eventType, handler: eventListener };
            }
        } else if (typeof finalCallback === 'string' && finalCallback.trim() !== ''){
            // Warn if callback name provided but function not found globally
            console.warn(`GUI Add Element Warning: Callback function name '${finalCallback}' for ID '${elementId}' was not found globally.`);
        }
    }

    // --- Add to Parent DOM and State (if new) --- <<< MODIFIED >>>
    if (!isEditMode) {
        // Append to the correct parent element (background or container div)
        parentElement.appendChild(element);

        // Store state in the correct location with correct parentId reference
        const elementStateData = {
            elementRef: element,
            type: elementType,
            parentId: parentIdStr, // <<< Store null if top-level, actual parentId if child >>>
            properties: properties,
            // Note: Non-container elements don't have .children or .lastAutoPosChildElement props added here
        };

        if (isTopLevelElement) {
            // Add to global elements map if it has no parent container
            guiState.elements[elementId] = elementStateData;
        } else {
            // Add to parent's children map if it has a parent container
            if (!parentData.children) parentData.children = {}; // Ensure children map exists on parent data
            parentData.children[elementId] = elementStateData;
        }
    } else {
         // Update properties in the existing state data reference (already done by cloning earlier)
         // Ensure the reference in the state tree points to the updated properties object
         existingElementData.properties = properties;
    }
}

funcEND======================funcEND==============
func======================func==============
lang: js
name: guiControl
libs: null
description: null


// ==========================================================================
// GUI CONTROL FUNCTION (Strict Object Syntax with parentId)
// ==========================================================================

/**
 * Controls (updates) an existing GUI element using a single options object
 * that MUST include both `id` and `parentId`.
 * - For children of a guiAdd container, `parentId` is the container's ID.
 * - For elements added directly to the background (guiAddElement with no parentId),
 *   `parentId` MUST be `null`.
 * - For controlling top-level containers (created by guiAdd), `parentId` MUST be `null`.
 *
 * Merges existing properties with new options. Handles cascading isEnabled state.
 *
 * @param {object} controlOptions - An object containing the properties to update.
 * @param {string | number} controlOptions.id - The ID of the element to control. REQUIRED.
 * @param {string | number | null} controlOptions.parentId - The ID of the parent container, or `null` if controlling a top-level div or a background element. REQUIRED.
 * @param {boolean} [controlOptions.isDeleting=false] - Set to true to delete the element.
 * @param {any} [controlOptions.property_name] - Other properties to update (e.g., value, isVisible, isEnabled, etc.).
 */
function guiControl(controlOptions) {

    // --- Input Validation ---
    if (typeof controlOptions !== 'object' || controlOptions === null) {
        console.error("GUI Control Error: Input must be an object.");
        return;
    }
    if (!controlOptions.hasOwnProperty('id') || (controlOptions.id === null || controlOptions.id === undefined)) {
        console.error("GUI Control Error: Input object must have an 'id' property.");
        return;
    }
    if (!controlOptions.hasOwnProperty('parentId')) {
        // Allow parentId to be explicitly null, but it must be present
        console.error("GUI Control Error: Input object must have a 'parentId' property (use null for top-level/background elements).");
        return;
    }

    const elementId = String(controlOptions.id);
    const parentId = controlOptions.parentId === null ? null : String(controlOptions.parentId); // Normalize null or string
    const options = { ...controlOptions }; // Clone for modification

    // Remove structural properties from the options object passed to adders
    delete options.id;
    delete options.parentId;

    // --- Initialization Check ---
    if (!guiState.initialized) { console.error("GUI Control Error: guiInit() must be called first."); return; }

    // --- Warn about changing immutable properties ---
    if (options.hasOwnProperty('elementType')) { console.warn(`GUI Control Warning (${elementId}): Property 'elementType' cannot be changed via guiControl. Ignoring.`); delete options.elementType; }


    // --- Element Lookup & Validation ---
    let targetElementData = null;
    let foundContextCorrect = false; // Flag to ensure lookup matches provided parentId context

    if (parentId === null) {
        // Expecting a top-level element (div OR background element)
        if (guiState.elements[elementId]) {
            targetElementData = guiState.elements[elementId];
            // Check if the found element's actual parentId matches the expected null context
            if (targetElementData.parentId === null) {
                 foundContextCorrect = true;
            } else {
                 console.error(`GUI Control Error: Element '${elementId}' found, but it belongs to parent '${targetElementData.parentId}', not the top-level/background (parentId: null was provided).`);
                 return;
            }
        }
    } else {
        // Expecting a child element within a specific parent div
        if (guiState.elements[parentId] && guiState.elements[parentId].type === 'div') {
            const parentData = guiState.elements[parentId];
            if (parentData.children && parentData.children[elementId]) {
                targetElementData = parentData.children[elementId];
                // Check if the found element's recorded parentId matches the provided parentId
                if (targetElementData.parentId === parentId) {
                     foundContextCorrect = true;
                } else {
                     // This case should be rare if state is consistent, but good to check
                     console.error(`GUI Control Error: Element '${elementId}' found under parent '${parentId}', but its stored parentId is inconsistent ('${targetElementData.parentId}').`);
                     return; // Indicates a state management issue
                }
            }
        } else if (guiState.elements[parentId]) {
             console.error(`GUI Control Error: Provided parentId '${parentId}' exists but is not a 'div' container.`);
             return;
        }
    }

    // --- Handle Element Not Found (in the specified context) ---
    if (!targetElementData || !foundContextCorrect) {
        // Allow deletion attempt even if not found (maybe already deleted)
        if (!(options.isDeleting === true && Object.keys(options).length === 1)) {
            const contextMsg = parentId === null ? "in the top-level/background context" : `under parent '${parentId}'`;
             console.error(`GUI Control Error: Element with ID '${elementId}' not found ${contextMsg}.`);
        } else {
             // If just deleting, ensure ID is removed from use tracking if it exists there
             if (guiState.idsInUse.has(elementId)) {
                  guiState.idsInUse.delete(elementId);
             }
             console.log(`GUI Control: Attempted to delete element '${elementId}' (context: parentId=${parentId}). If it existed, it's gone.`);
        }
        return; // Stop execution if element not found (and not just deleting)
    }

    // --- Element Found: Merge Options ---
    const updateOptions = {
         ...targetElementData.properties, // Start with existing properties
         ...options                      // Overwrite with new properties from input (excluding id, parentId)
    };

    // --- Call Appropriate Adder Function ---
    if (targetElementData.type === 'div') {
        // Must be a top-level div (found with parentId: null)
        // Call guiAdd, passing the merged options PLUS the elementId back in.
        guiAdd({ ...updateOptions, id: elementId });
    } else {
        // Any other element type (found either with parentId: null OR a specific parentId)
        // Call guiAddElement, passing merged options, PLUS id, elementType, and the original parentId context.
        guiAddElement({
            ...updateOptions,
            id: elementId,
            elementType: targetElementData.type,
            parentId: parentId // Pass the validated parentId context (null or string)
        });
    }
}


funcEND======================funcEND==============
func======================func==============
lang: js
name: MakeHotKey
libs: null
description: other~~~MakeHotKey is a function that listens for a specific key combination (hotkey) and triggers a callback when the hotkey is pressed. It handles modifiers like Ctrl, Shift, and Alt, as well as specific keys such as arrows and backspace. The callback function is invoked with the hotkey in either uppercase or lowercase, depending on the Shift modifier.~~~here is how the func looks like:~~~```htvm~~~MakeHotKey(str hotkey, function callback)~~~```~~~
// Define the MakeHotKey function separately
function MakeHotKey(hotkey, callback) {
    document.addEventListener("keydown", function (event) {
        const keys = hotkey.split("+").map((key) => key.trim().toLowerCase());
        const modifiers = {
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
        };
        let hotkeyPressed = true;
        keys.forEach((key) => {
            if (key === "ctrl" || key === "shift" || key === "alt") {
                if (!modifiers[key]) {
                    hotkeyPressed = false;
                }
            } else if (key === "backspace") {
                if (event.key !== "Backspace") {
                    hotkeyPressed = false;
                }
            } else if (key === "esc" || key === "escape") {
                if (event.key !== "Escape") {
                    hotkeyPressed = false;
                }
            } else if (key.startsWith("arrow")) {
                const arrowDirection = key.replace("arrow", "");
                if (arrowDirection === "up" && event.key !== "ArrowUp") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "down" && event.key !== "ArrowDown") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "left" && event.key !== "ArrowLeft") {
                    hotkeyPressed = false;
                } else if (arrowDirection === "right" && event.key !== "ArrowRight") {
                    hotkeyPressed = false;
                }
            } else if (key === "enter") {
                if (event.key !== "Enter") {
                    hotkeyPressed = false;
                }
            } else if (!event.key.match(/^[0-9a-zA-Z]$/) && event.key !== key) {
                hotkeyPressed = false;
            } else if (event.key.toLowerCase() !== key && event.key.match(/^[a-zA-Z]$/)) {
                hotkeyPressed = false;
            }
        });
        if (hotkeyPressed) {
            if (modifiers["shift"]) {
                callback(hotkey.toUpperCase());
            } else {
                callback(hotkey.toLowerCase());
            }
        }
    });
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: sortArr
libs: #include <iostream>|#include <vector>|#include <string>|#include <set>|#include <algorithm>
description: string~~~sortArr is a function that takes an array, removes any duplicate values using a Set, and returns the array sorted in ascending order.~~~here is how the func looks like:~~~```htvm~~~sortArr(arr str stringArray)~~~```~~~
// Function to sort and remove duplicates
std::vector<std::string> sortArr(const std::vector<std::string>& input) {
    std::set<std::string> uniqueSorted(input.begin(), input.end());
    return std::vector<std::string>(uniqueSorted.begin(), uniqueSorted.end());
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: sortArr
libs: null
description: string~~~sortArr is a function that takes an array, removes any duplicate values using a Set, and returns the array sorted in ascending order.~~~here is how the func looks like:~~~```htvm~~~sortArr(arr str stringArray)~~~```~~~
// Function to sort and remove duplicates
function sortArr(inputArray) {
    // Remove duplicates using Set and sort the array
    return [...new Set(inputArray)].sort();
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: sortArr
libs: null
description: string~~~sortArr is a function that takes an array, removes any duplicate values using a Set, and returns the array sorted in ascending order.~~~here is how the func looks like:~~~```htvm~~~sortArr(arr str stringArray)~~~```~~~
# Function to sort and remove duplicates
def sortArr(input_list):
    """
    Function to sort a list of strings and remove duplicates.
    """
    return sorted(set(input_list))
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: sortArrByLenOnly
libs: #include <iostream>|#include <vector>|#include <string>|#include <algorithm>
description: string~~~sortArrByLenOnly is a function that sorts an array of strings by length in descending order~~~here is how the func looks like:~~~```htvm~~~sortArrByLenOnly(arr str array)~~~```~~~
// Function to sort an array of strings by length in descending order
void sortArrByLenOnly(std::vector<std::string>& array) {
    std::sort(array.begin(), array.end(), [](const std::string& a, const std::string& b) {
        return a.length() > b.length();
    });
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: sortArrByLenOnly
libs: null
description: string~~~sortArrByLenOnly is a function that sorts an array of strings by length in descending order~~~here is how the func looks like:~~~```htvm~~~sortArrByLenOnly(arr str array)~~~```~~~
// Function to sort an array of strings by length in descending order
function sortArrByLenOnly(array) {
    return array.sort((a, b) => b.length - a.length);
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: sortArrByLenOnly
libs: null
description: string~~~sortArrByLenOnly is a function that sorts an array of strings by length in descending order~~~here is how the func looks like:~~~```htvm~~~sortArrByLenOnly(arr str array)~~~```~~~
# Function to sort an array of strings by length in descending order
def sortArrByLenOnly(array):
    array.sort(key=len, reverse=True)
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: countChars
libs: #include <iostream>|#include <string>
description: string~~~countChars is a function that counts the occurrences of a specific character (`theChar`) in a given string.~~~here is how the func looks like:~~~```htvm~~~countChars(str string, str theChar)~~~```~~~
// Overload for counting a single character
int countChars(const std::string& str, char theChar) {
    int count = 0;
    for (char c : str) {
        if (c == theChar) {
            count++;
        }
    }
    return count;
}
// Overload for counting a substring
int countChars(const std::string& str, const std::string& substring) {
    if (substring.empty()) return 0; // Avoid infinite loop
    int count = 0;
    size_t pos = 0;
    // Find occurrences of the substring
    while ((pos = str.find(substring, pos)) != std::string::npos) {
        count++;
        pos += substring.length(); // Move past the found substring
    }
    return count;
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: countChars
libs: null
description: string~~~countChars is a function that counts the occurrences of a specific character (`theChar`) in a given string.~~~here is how the func looks like:~~~```htvm~~~countChars(str string, str theChar)~~~```~~~
def countChars(string, theChar):
    return string.count(theChar)
funcEND======================funcEND==============
func======================func==============
lang: js
name: countChars
libs: null
description: string~~~countChars is a function that counts the occurrences of a specific character (`theChar`) in a given string.~~~here is how the func looks like:~~~```htvm~~~countChars(str string, str theChar)~~~```~~~
function countChars(string, theChar) {
    let count = 0;
    for (let char of string) {
        if (char === theChar) {
            count++;
        }
    }
    return count;
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: StrTitleCase
libs: #include <iostream>|#include <sstream>|#include <cctype>|#include <string>
description: string~~~StrTitleCase is a function that takes an input string and converts each word to title case, capitalizing the first letter of each word while making the rest lowercase.~~~here is how the func looks like:~~~```htvm~~~StrTitleCase(str inputString)~~~```~~~
std::string StrTitleCase(const std::string& input) {
    std::string result;
    bool newWord = true;
    for (char ch : input) {
        if (std::isspace(ch)) {
            newWord = true; // next character starts a new word
            result += ch;
        } else if (newWord) {
            result += std::toupper(ch); // capitalize the first letter of the word
            newWord = false;
        } else {
            result += std::tolower(ch); // make other letters lowercase
        }
    }
    return result;
}
funcEND======================funcEND==============
func======================func==============
lang: js
name: StrTitleCase
libs: null
description: string~~~StrTitleCase is a function that takes an input string and converts each word to title case, capitalizing the first letter of each word while making the rest lowercase.~~~here is how the func looks like:~~~```htvm~~~StrTitleCase(str inputString)~~~```~~~
function StrTitleCase(inputString) {
    return inputString.split(' ')  // Split the string into words
        .map(word => {
            if (word) {  // Avoid empty words (multiple spaces)
                return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();  // Capitalize first letter
            }
            return word;  // If it's an empty string (spaces), keep it as is
        })
        .join(' ');  // Join the words back together with spaces
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: StrTitleCase
libs: null
description: string~~~StrTitleCase is a function that takes an input string and converts each word to title case, capitalizing the first letter of each word while making the rest lowercase.~~~here is how the func looks like:~~~```htvm~~~StrTitleCase(str inputString)~~~```~~~
def StrTitleCase(input_string):
    words = input_string.split(' ')  # Split the input string into words
    result = []
    for word in words:
        if word:  # Ignore empty strings (in case of multiple spaces)
            result.append(word[0].upper() + word[1:].lower())  # Capitalize first letter, lowercase others
        else:
            result.append(word)  # Preserve spaces as is
    return ' '.join(result)  # Join the list of words back into a string
funcEND======================funcEND==============







func======================func==============
lang: py
name: createBackendInit
libs: from flask import Flask, request, send_file|import os
description: backend~~~createBackendInit is a function that initializes a Flask app, sets up a default route to serve an `index.html` file, and registers a custom 404 error handler and uses the app variable so never use the app variable please~~~here is how the func looks like:~~~```htvm~~~createBackendInit([filename = "index.html"])~~~```~~~Here is an exmaple how to use the backend~~~```py~~~# Initialize Flask app~~~createBackendInit()~~~# Define your custom endpoint functions using camelCase~~~def helloWord(data):~~~    # Handle data and return plain text response~~~    return f"Hello, you sent: {data['message']}"~~~def uppercaseText(data):~~~    # Handle data and return plain text response~~~    return data['text'].upper()~~~# Register the endpoints~~~addEndpoint(helloWord)~~~addEndpoint(uppercaseText)~~~# Start the server~~~startServer()~~~```~~~~~~This exmaple is in python but the funcs works in HTVM like normal funcs.
# Declare the global app variable
app = None

def createBackendInit(filename="index.html"):
    """Initialize the Flask app with an optional filename to be served."""
    global app  # Use the global app variable
    app = Flask(__name__)

    # Define a route to serve the file, defaulting to 'index.html'
    def appRoute():
        file_path = os.path.join(os.path.dirname(__file__), filename)
        return send_file(file_path), 200

    # Add URL rule with the route that calls appRoute
    app.add_url_rule('/', 'appRoute', appRoute, methods=["GET"])

    # Handle 404 errors
    def notFound(e):
        return "Page not found", 404
    app.register_error_handler(404, notFound)

funcEND======================funcEND==============

func======================func==============
lang: py
name: addEndpoint
libs: from flask import Flask, request, send_file|import os
description: backend~~~addEndpoint is a function that registers a given function as an endpoint with a specified HTTP method (default is POST).~~~here is how the func looks like:~~~```htvm~~~addEndpoint(func func, str method [default = "POST"])~~~```~~~Here is an exmaple how to use the backend~~~```py~~~# Initialize Flask app~~~createBackendInit()~~~# Define your custom endpoint functions using camelCase~~~def helloWord(data):~~~    # Handle data and return plain text response~~~    return f"Hello, you sent: {data['message']}"~~~def uppercaseText(data):~~~    # Handle data and return plain text response~~~    return data['text'].upper()~~~# Register the endpoints~~~addEndpoint(helloWord)~~~addEndpoint(uppercaseText)~~~# Start the server~~~startServer()~~~```~~~~~~This exmaple is in python but the funcs works in HTVM like normal funcs.
def addEndpoint(func, method="POST"):
    """Register a function as an endpoint with a single HTTP method."""
    endpoint = f"/{func.__name__}"

    def handle_request():
        if request.method == "GET":
            # Extract raw query string
            raw_query = request.query_string.decode('utf-8')  # Get query string like "WAESRDG="
            if raw_query:
                # Split by "=" and get everything before the "="
                key = raw_query.split('=')[0]
                return func(key)  # Pass the extracted key to the function
            else:
                return "No query string provided", 400

        elif request.method in {"POST", "PUT", "PATCH"}:
            data = request.get_json()
            return func(data)

        elif request.method == "DELETE":
            data = request.args.to_dict() if not request.is_json else request.get_json()
            return func(data)

        else:
            return f"Method {request.method} not supported", 405

    app.add_url_rule(
        endpoint,
        endpoint,
        handle_request,
        methods=[method]
    )
funcEND======================funcEND==============


func======================func==============
lang: py
name: startServer
libs: from flask import Flask, request, send_file|import os
description: backend~~~startServer is a function that runs a Flask web application on a specified host and port, with default values for the host and port parameters.~~~here is how the func looks like:~~~```htvm~~~startServer([port=8000], [host="0.0.0.0"])~~~```~~~Here is an exmaple how to use the backend~~~```py~~~# Initialize Flask app~~~createBackendInit()~~~# Define your custom endpoint functions using camelCase~~~def helloWord(data):~~~    # Handle data and return plain text response~~~    return f"Hello, you sent: {data['message']}"~~~def uppercaseText(data):~~~    # Handle data and return plain text response~~~    return data['text'].upper()~~~# Register the endpoints~~~addEndpoint(helloWord)~~~addEndpoint(uppercaseText)~~~# Start the server~~~startServer()~~~```~~~~~~This exmaple is in python but the funcs works in HTVM like normal funcs.
def startServer(port=8000, host="0.0.0.0"):
    """Run the Flask app."""
    app.run(host=host, port=port, debug=True)
funcEND======================funcEND==============



func======================func==============
lang: js
name: getDataFromEndpoint
libs: null
description: backend~~~getDataFromEndpoint is a function that fetches data from a specified endpoint using a provided HTTP method (default is POST), sends the data as a JSON string, and parses the response based on its content type.~~~here is how the func looks like:~~~```htvm~~~getDataFromEndpoint(data, endpoint, method = "POST")~~~```~~~
async function getDataFromEndpoint(data, endpoint, method = "POST") {
  let url = endpoint;
  let requestOptions = {
    method, // Use the provided method
    headers: {
      "Content-Type": "application/json",
    },
  };

  // If the method is GET, append data as query parameters
  if (method === "GET") {
    const queryParams = new URLSearchParams(data).toString();
    url += `?${queryParams}`;
  } else {
    // For POST/PUT, include the body
    requestOptions.body = JSON.stringify(data);
  }

  // Fetch data
  const response = await fetch(url, requestOptions);

  // Handle response
  if (!response.ok) {
    throw new Error(`Failed to fetch data from ${url}. Status: ${response.status}`);
  }

  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("application/json")) {
    return response.json();
  } else {
    return response.text();
  }
}
funcEND======================funcEND==============
func======================func==============
lang: cpp
name: HTVM_getLang_HTVM
libs: null
description: system~~~HTVM_getLang_HTVM is a func that returns the current language of HTVM as a string~~~here is how the func looks like:~~~```htvm~~~HTVM_getLang_HTVM()~~~```~~~
std::string HTVM_getLang_HTVM() {
    return "cpp";
}
funcEND======================funcEND==============
func======================func==============
lang: py
name: HTVM_getLang_HTVM
libs: null
description: system~~~HTVM_getLang_HTVM is a func that returns the current language of HTVM as a string~~~here is how the func looks like:~~~```htvm~~~HTVM_getLang_HTVM()~~~```~~~
def HTVM_getLang_HTVM():
    return "py"
funcEND======================funcEND==============
func======================func==============
lang: js
name: HTVM_getLang_HTVM
libs: null
description: system~~~HTVM_getLang_HTVM is a func that returns the current language of HTVM as a string~~~here is how the func looks like:~~~```htvm~~~HTVM_getLang_HTVM()~~~```~~~
function HTVM_getLang_HTVM() {
    return "js";
}
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_v2_HTVM
libs: #include <algorithm>|#include <any>|#include <cstdint>|#include <filesystem>|#include <iostream>|#include <optional>|#include <regex>|#include <sstream>|#include <string>|#include <type_traits>|#include <vector>
description: other~~~HTVM_v2_HTVM is a func that will help me make HTVM v2 DONT USE IT!!!
bool noParams = false;
std::string allArgs = "";
// in allArgs will look like:
// full/path/code/
// HTVM-Instruction.txt file
// lang to convert to
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE
// HTVM-Instruction.txt file MORE and more

#ifdef _WIN32
    #define ARGC __argc
    #define ARGV __argv
#else
    extern char **environ;
    int ARGC;
    char** ARGV;
    __attribute__((constructor)) void init_args(int argc, char* argv[], char* envp[]) {
        ARGC = argc;
        ARGV = argv;
    }
#endif
std::string GetParams() {
    std::vector<std::string> params;
    for (int i = 1; i < ARGC; ++i) {
        std::string arg = ARGV[i];
        if (std::filesystem::exists(arg)) {
            arg = std::filesystem::absolute(arg).string();
        }
        params.push_back(arg);
    }
    std::string result;
    for (const auto& param : params) {
        result += param + "\n";
    }
    return result;
}


void HTVM_v2_HTVM() {
    std::string params = Trim(GetParams());
    if (params == "") {
	noParams = true;
        print("Usage: HTVM <yourCodeFileName.yourExtension> <HTVM-instructions.txt> [optional LangToTranspileTo]\n\nOptions:\n  <yourCodeFileName.yourExtension>  The source code file to transpile.\n  <HTVM-instructions.txt>              The instructions file for transpilation.\n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js, go, lua, cs, java, kt, rb, nim, ahk, swift, dart, ts, groovy, htvm or <yourExtension>).\n\nExample:\n  HTVM main.htvm HTVM-instructions.txt cpp\n");
        return;
    }
    std::vector<std::string> items1 = LoopParseFunc(params, "\n", "\r");
    for (size_t A_Index1 = 0; A_Index1 < items1.size() + 0; A_Index1++) {
        std::string A_LoopField1 = items1[A_Index1 - 0];
        allArgs += Trim(A_LoopField1) + "\n";
    }
    allArgs = StringTrimRight(allArgs, 1);
}

funcEND======================funcEND==============
func======================func==============
lang: py
name: HTVM_v2_HTVM
libs: import os|import re|import sys
description: other~~~HTVM_v2_HTVM is a func that will help me make HTVM v2 DONT USE IT!!!

noParams = False
allArgs = ""
# in allArgs will look like:
# full/path/code/
# HTVM-Instruction.txt file
# lang to convert to
# HTVM-Instruction.txt file MORE
# HTVM-Instruction.txt file MORE
# HTVM-Instruction.txt file MORE and more

def GetParams():
    # Check if any command line arguments are provided
    if len(sys.argv) < 2:
        return ""
    # Store the provided command line arguments
    params = []
    for arg in sys.argv[1:]:
        if os.path.exists(arg):
            arg = os.path.abspath(arg)
        params.append(arg)
    return "\\n".join(params)

def HTVM_v2_HTVM():
    global noParams, allArgs
    params = Trim(GetParams())
    if (params == ""):
        noParams = True
       	print("Usage: HTVM <yourCodeFileName.yourExtension> <HTVM-instructions.txt> [optional LangToTranspileTo]\n\nOptions:\n  <yourCodeFileName.yourExtension>  The source code file to transpile.\n  <HTVM-instructions.txt>              The instructions file for transpilation.\n  [LangToTranspileTo]                Optional: Specify the target language (cpp, py, js, go, lua, cs, java, kt, rb, nim, ahk, swift, dart, ts, groovy, htvm or <yourExtension>).\n\nExample:\n  HTVM main.htvm HTVM-instructions.txt cpp\n")
        return
    items1 = LoopParseFunc(params, "\n", "\r")
    for A_Index1 , A_LoopField1 in enumerate(items1, start=0):
        allArgs += Trim(A_LoopField1) + "\n"
    allArgs = StringTrimRight(allArgs, 1)

funcEND======================funcEND==============
func======================func==============
lang: js
name: HTVM_v2_HTVM
libs: null
description: null

// HTVM_v2_HTVM()

let allArgs = "";
let noParams = false;

function HTVM_v2_HTVM() {
return
}

funcEND======================funcEND==============


func======================func==============
lang: cpp
name: HTVM_Append
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Append(std::vector<std::string>& arr, const std::string& value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<std::string>& arr, const char* value) {
    arr.push_back(std::string(value));
}

void HTVM_Append(std::vector<int>& arr, int value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<float>& arr, float value) {
    arr.push_back(value);
}

void HTVM_Append(std::vector<bool>& arr, bool value) {
    arr.push_back(value);
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Pop
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Pop(std::vector<std::string>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<int>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<float>& arr) {
    if (!arr.empty()) arr.pop_back();
}

void HTVM_Pop(std::vector<bool>& arr) {
    if (!arr.empty()) arr.pop_back();
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Size
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null


size_t HTVM_Size(const std::vector<std::string>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<int>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<float>& arr) {
    return arr.size();
}

size_t HTVM_Size(const std::vector<bool>& arr) {
    return arr.size();
}

funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Insert
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

void HTVM_Insert(std::vector<std::string>& arr, size_t index, const std::string& value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<std::string>& arr, size_t index, const char* value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, std::string(value));
}

void HTVM_Insert(std::vector<int>& arr, size_t index, int value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<float>& arr, size_t index, float value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}

void HTVM_Insert(std::vector<bool>& arr, size_t index, bool value) {
    if (index <= arr.size()) arr.insert(arr.begin() + index, value);
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_Remove
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

// Remove by index for std::vector<std::string>
void HTVM_Remove(std::vector<std::string>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<int>
void HTVM_Remove(std::vector<int>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<float>
void HTVM_Remove(std::vector<float>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}

// Remove by index for std::vector<bool>
void HTVM_Remove(std::vector<bool>& arr, size_t index) {
    if (index < arr.size()) {
        arr.erase(arr.begin() + index);
    }
}


funcEND======================funcEND==============

func======================func==============
lang: cpp
name: HTVM_IndexOf
libs: #include <iostream>|#include <vector>|#include <algorithm>
description: null

// IndexOf for std::vector<std::string>
int HTVM_IndexOf(const std::vector<std::string>& arr, const std::string& value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// Overload for string literals
int HTVM_IndexOf(const std::vector<std::string>& arr, const char* value) {
    return HTVM_IndexOf(arr, std::string(value));
}

// IndexOf for std::vector<int>
int HTVM_IndexOf(const std::vector<int>& arr, int value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// IndexOf for std::vector<float>
int HTVM_IndexOf(const std::vector<float>& arr, float value) {
    auto it = std::find(arr.begin(), arr.end(), value);
    return (it != arr.end()) ? static_cast<int>(std::distance(arr.begin(), it)) : -1;
}

// IndexOf for std::vector<bool>
int HTVM_IndexOf(const std::vector<bool>& arr, bool value) {
    for (size_t i = 0; i < arr.size(); ++i) {
        if (arr[i] == value) {
            return static_cast<int>(i);
        }
    }
    return -1;
}

funcEND======================funcEND==============


func======================func==============
lang: py
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value):
    arr.append(value)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr):
    if arr:
        arr.pop()

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr):
    return len(arr)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value):
    arr.insert(index, value)

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(arr, index):
    if 0 <= index < len(arr):
        del arr[index]

funcEND======================funcEND==============

func======================func==============
lang: py
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value):
    return arr.index(value) if value in arr else -1

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Append
libs: null
description: null

function HTVM_Append(arr, value) {
    arr.push(value);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop(arr) {
    arr.pop();
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Size
libs: null
description: null

function HTVM_Size(arr) {
    return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert(arr, index, value) {
    arr.splice(index, 0, value);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr, index) {
    if (index >= 0 && index < arr.length) arr.splice(index, 1);
}

funcEND======================funcEND==============

func======================func==============
lang: js
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf(arr, value) {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Append
libs: null
description: null

// Append to a slice
func HTVM_Append[T any](arr *[]T, value T) {
    *arr = append(*arr, value)
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Pop
libs: null
description: null

// Pop the last element from a slice
func HTVM_Pop[T any](arr *[]T) {
    if len(*arr) > 0 {
        *arr = (*arr)[:len(*arr)-1]
    }
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Size
libs: null
description: null

// Get the size of a slice
func HTVM_Size[T any](arr []T) int {
    return len(arr)
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Insert
libs: null
description: null

// Insert a value at a specific index in a slice
func HTVM_Insert[T any](arr *[]T, index int, value T) {
    if index >= 0 && index <= len(*arr) {
        *arr = append((*arr)[:index], append([]T{value}, (*arr)[index:]...)...)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_Remove
libs: null
description: null


// Remove an element at a specific index in a slice
func HTVM_Remove[T any](arr *[]T, index int) {
    if index >= 0 && index < len(*arr) {
        *arr = append((*arr)[:index], (*arr)[index+1:]...)
    }
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: HTVM_IndexOf
libs: null
description: null

// Find the index of a value in a slice
func HTVM_IndexOf[T comparable](arr []T, value T) int {
    for i, v := range arr {
        if v == value {
            return i
        }
    }
    return -1
}


funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Append
libs: null
description: null

function HTVM_Append(arr, value)
    table.insert(arr, value)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop(arr)
    table.remove(arr)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Size
libs: null
description: null

function HTVM_Size(arr)
    return #arr
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert(arr, index, value)
    table.insert(arr, index, value)
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr, index)
    if index >= 1 and index <= #arr then
        table.remove(arr, index)
    end
end

funcEND======================funcEND==============

func======================func==============
lang: lua
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf(arr, value)
    for i, v in ipairs(arr) do
        if v == value then
            return i
        end
    end
    return -1
end

funcEND======================funcEND==============


func======================func==============
lang: cs
name: HTVM_Append
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Append<T>(List<T> arr, T value) {
    arr.Add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Pop
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Pop<T>(List<T> arr) {
    if (arr.Count > 0) arr.RemoveAt(arr.Count - 1);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Size
libs: using System;|using System.Collections.Generic;
description: null

public static int HTVM_Size<T>(List<T> arr) {
    return arr.Count;
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Insert
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Insert<T>(List<T> arr, int index, T value) {
    arr.Insert(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_Remove
libs: using System;|using System.Collections.Generic;
description: null

public static void HTVM_Remove<T>(List<T> arr, int index)
{
    if (index >= 0 && index < arr.Count)
    {
        arr.RemoveAt(index);
    }
}
funcEND======================funcEND==============

func======================func==============
lang: cs
name: HTVM_IndexOf
libs: using System;|using System.Collections.Generic;
description: null

public static int HTVM_IndexOf<T>(List<T> arr, T value) {
    return arr.IndexOf(value);
}

funcEND======================funcEND==============


func======================func==============
lang: java
name: HTVM_Append
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Append(ArrayList<T> arr, T value) {
    arr.add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Pop
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Pop(ArrayList<T> arr) {
    if (!arr.isEmpty()) arr.remove(arr.size() - 1);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Size
libs: import java.util.ArrayList;
description: null

public static <T> int HTVM_Size(ArrayList<T> arr) {
    return arr.size();
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Insert
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Insert(ArrayList<T> arr, int index, T value) {
    arr.add(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_Remove
libs: import java.util.ArrayList;
description: null

public static <T> void HTVM_Remove(ArrayList<T> arr, int index) {
    if (index >= 0 && index < arr.size()) {
        arr.remove(index);
    }
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: HTVM_IndexOf
libs: import java.util.ArrayList;
description: null

public static <T> int HTVM_IndexOf(ArrayList<T> arr, T value) {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Append
libs: null
description: null

fun <T> HTVM_Append(arr: MutableList<T>, value: T) {
    arr.add(value)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Pop
libs: null
description: null

fun <T> HTVM_Pop(arr: MutableList<T>) {
    if (arr.isNotEmpty()) arr.removeAt(arr.lastIndex)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Size
libs: null
description: null

fun <T> HTVM_Size(arr: List<T>): Int {
    return arr.size
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Insert
libs: null
description: null

fun <T> HTVM_Insert(arr: MutableList<T>, index: Int, value: T) {
    arr.add(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_Remove
libs: null
description: null

fun <T> HTVM_Remove(arr: MutableList<T>, index: Int) {
    if (index in arr.indices) {
        arr.removeAt(index)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: kt
name: HTVM_IndexOf
libs: null
description: null

fun <T> HTVM_IndexOf(arr: List<T>, value: T): Int {
    return arr.indexOf(value)
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value)
  arr << value
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr)
  arr.pop
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr)
  arr.size
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value)
  arr.insert(index, value)
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(arr, index)
  arr.delete_at(index) if index >= 0 && index < arr.length
end

funcEND======================funcEND==============

func======================func==============
lang: rb
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value)
  arr.index(value) || -1
end

funcEND======================funcEND==============


func======================func==============
lang: nim
name: HTVM_Append
libs: null
description: null

proc HTVM_Append[T](arr: var seq[T], value: T) =
  arr.add(value)



funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Pop
libs: null
description: null

proc HTVM_Pop[T](arr: var seq[T]) =
  if arr.len > 0: arr.setLen(arr.len - 1)

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Size
libs: null
description: null

proc HTVM_Size[T](arr: seq[T]): int =
  return arr.len

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Insert
libs: null
description: null

proc HTVM_Insert[T](arr: var seq[T], index: int, value: T) =
  if index >= 0 and index <= arr.len:
    arr.insert(value, index)  # Correct order


funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_Remove
libs: null
description: null

proc HTVM_Remove[T](arr: var seq[T], index: int) =
  if index >= 0 and index < arr.len:
    arr.delete(index)

funcEND======================funcEND==============

func======================func==============
lang: nim
name: HTVM_IndexOf
libs: null
description: null

proc HTVM_IndexOf[T](arr: seq[T], value: T): int =
  for i, v in arr:
    if v == value:
      return i
  return -1

funcEND======================funcEND==============


func======================func==============
lang: ahk
name: HTVM_Append
libs: null
description: null

HTVM_Append(arr, value) {
    arr.Push(value)
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Pop
libs: null
description: null

HTVM_Pop(arr) {
    arr.RemoveAt(arr.MaxIndex())
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Size
libs: null
description: null

HTVM_Size(arr) {
    return arr.Length()
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Insert
libs: null
description: null

HTVM_Insert(arr, index, value) {
    arr.InsertAt(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_Remove
libs: null
description: null

HTVM_Remove(arr, index) {
    if (index >= 1 && index <= arr.Length())
        arr.RemoveAt(index)
    return arr
}

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: HTVM_IndexOf
libs: null
description: null

HTVM_IndexOf(arr, value) {
    for k, v in arr {
        if (v = value)
            return k
    }
    return -1
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Append
libs: null
description: null

func HTVM_Append<T>(_ arr: inout [T], _ value: T) {
    arr.append(value)
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Pop
libs: null
description: null

func HTVM_Pop<T>(_ arr: inout [T]) {
    if !arr.isEmpty {
        arr.removeLast()
    }
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Size
libs: null
description: null

func HTVM_Size<T>(_ arr: [T]) -> Int {
    return arr.count
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_Insert
libs: null
description: null

func HTVM_Insert<T>(_ arr: inout [T], _ index: Int, _ value: T) {
    arr.insert(value, at: index)
}

funcEND======================funcEND==============


func======================func==============
lang: swift
name: HTVM_Remove
libs: null
description: null

func HTVM_Remove<T>(_ arr: inout [T], _ index: Int) {
    if index >= 0 && index < arr.count {
        arr.remove(at: index)
    }
}


funcEND======================funcEND==============

func======================func==============
lang: swift
name: HTVM_IndexOf
libs: null
description: null


func HTVM_IndexOf<T: Equatable>(_ arr: [T], _ value: T) -> Int {
    if let index = arr.firstIndex(of: value) {
        return index
    } else {
        return -1 // Return a default value if not found
    }
}


funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Append
libs: null
description: null

void HTVM_Append<T>(List<T> arr, T value) {
  arr.add(value);
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Pop
libs: null
description: null

void HTVM_Pop<T>(List<T> arr) {
  if (arr.isNotEmpty) arr.removeLast();
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Size
libs: null
description: null

int HTVM_Size<T>(List<T> arr) {
  return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Insert
libs: null
description: null

void HTVM_Insert<T>(List<T> arr, int index, T value) {
  arr.insert(index, value);
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_Remove
libs: null
description: null

void HTVM_Remove<T>(List<T> arr, int index) {
    if (index >= 0 && index < arr.length) {
        arr.removeAt(index);
    }
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: HTVM_IndexOf
libs: null
description: null

int HTVM_IndexOf<T>(List<T> arr, T value) {
  return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Append
libs: null
description: null

function HTVM_Append<T>(arr: T[], value: T): void {
    arr.push(value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Pop
libs: null
description: null

function HTVM_Pop<T>(arr: T[]): void {
    arr.pop();
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Size
libs: null
description: null

function HTVM_Size<T>(arr: T[]): number {
    return arr.length;
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Insert
libs: null
description: null

function HTVM_Insert<T>(arr: T[], index: number, value: T): void {
    arr.splice(index, 0, value);
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_Remove
libs: null
description: null

function HTVM_Remove(arr: any[], value: any): void {
    const index = arr.indexOf(value);
    if (index !== -1) arr.splice(index, 1);
}


funcEND======================funcEND==============

func======================func==============
lang: ts
name: HTVM_IndexOf
libs: null
description: null

function HTVM_IndexOf<T>(arr: T[], value: T): number {
    return arr.indexOf(value);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Append
libs: null
description: null

def HTVM_Append(arr, value) {
    arr.add(value)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Pop
libs: null
description: null

def HTVM_Pop(arr) {
    if (!arr.isEmpty()) arr.remove(arr.size() - 1)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Size
libs: null
description: null

def HTVM_Size(arr) {
    return arr.size()
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Insert
libs: null
description: null

def HTVM_Insert(arr, index, value) {
    arr.add(index, value)
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_Remove
libs: null
description: null

def HTVM_Remove(list, index) {
    if (index >= 0 && index < list.size()) {
        list.remove(index)
    }
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: HTVM_IndexOf
libs: null
description: null

def HTVM_IndexOf(arr, value) {
    return arr.indexOf(value)
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: ErrorMsg
libs: null
description: null

// Function that throws an error with a string message
func ErrorMsg(_ message: String) throws {
    throw NSError(domain: "", code: 0, userInfo: [NSLocalizedDescriptionKey: message])
}
funcEND======================funcEND==============

func======================func==============
lang: cpp
name: fstr
libs: null
description: null

template<typename T>
std::string fstr(const T& val) {
    std::ostringstream oss;
    oss << val;
    return oss.str();
}

funcEND======================funcEND==============

func======================func==============
lang: py
name: fstr
libs: null
description: null

def fstr(val):
    return str(val)

funcEND======================funcEND==============

func======================func==============
lang: js
name: fstr
libs: null
description: null

function fstr(val) {
    return String(val);
}

funcEND======================funcEND==============

func======================func==============
lang: go
name: fstr
libs: null
description: null

func fstr(val interface{}) string {
    return fmt.Sprintf("%v", val)
}

funcEND======================funcEND==============

func======================func==============
lang: lua
name: fstr
libs: null
description: null

function fstr(val)
    return tostring(val)
end

funcEND======================funcEND==============

func======================func==============
lang: cs
name: fstr
libs: null
description: null

string fstr(object val) {
    return val?.ToString() ?? "null";
}

funcEND======================funcEND==============

func======================func==============
lang: java
name: fstr
libs: null
description: null

public static String fstr(Object val) {
    return String.valueOf(val);
}

funcEND======================funcEND==============

func======================func==============
lang: kt
name: fstr
libs: null
description: null

fun fstr(val: Any?): String {
    return val.toString()
}

funcEND======================funcEND==============

func======================func==============
lang: rb
name: fstr
libs: null
description: null

def fstr(val)
  val.to_s
end

funcEND======================funcEND==============

func======================func==============
lang: nim
name: fstr
libs: null
description: null

proc fstr(val: auto): string =
  $val

funcEND======================funcEND==============

func======================func==============
lang: ahk
name: fstr
libs: null
description: null

fstr(val) {
    return val . ""
}

funcEND======================funcEND==============

func======================func==============
lang: swift
name: fstr
libs: null
description: null

func fstr(_ val: Any) -> String {
    return String(describing: val)
}

funcEND======================funcEND==============

func======================func==============
lang: dart
name: fstr
libs: null
description: null

String fstr(dynamic val) {
  return val.toString();
}

funcEND======================funcEND==============

func======================func==============
lang: ts
name: fstr
libs: null
description: null

function fstr(val: any): string {
    return String(val);
}

funcEND======================funcEND==============

func======================func==============
lang: groovy
name: fstr
libs: null
description: null

def fstr(val) {
    return val.toString()
}

funcEND======================funcEND==============