<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HTVM</title>
        <style>
            body {
                background-color: #202020;
                font-family:
                    "Open Sans",
                    -apple-system,
                    BlinkMacSystemFont,
                    "Segoe UI",
                    Roboto,
                    Oxygen-Sans,
                    Ubuntu,
                    Cantarell,
                    "Helvetica Neue",
                    Helvetica,
                    Arial,
                    sans-serif;
            }
        </style>

</head>
    <body>
<script>


function LoopParseFunc(varString, delimiter1="", delimiter2="") {
    let items;
    if (!delimiter1 && !delimiter2) {
        // If no delimiters are provided, return an array of characters
        items = [...varString];
    } else {
        // Construct the regular expression pattern for splitting the string
        let pattern = new RegExp('[' + delimiter1.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + delimiter2.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ']+');
        // Split the string using the constructed pattern
        items = varString.split(pattern);
    }
    return items;
}

function print(value) {
    console.log(value)
}

// Convert value to string
function STR(value) {
    if (value === null || value === undefined) {
        return ""; // Return a string for null or undefined
    } else if (typeof value === 'number') {
        return value.toString();
    } else if (typeof value === 'boolean') {
        return value ? "1" : "0";
    } else if (typeof value === 'string') {
        return value; // Return the string as is
    } else {
        // Handle any unexpected types gracefully
        return String(value); // Convert any other type to a string
    }
}

// Convert value to float
function FLOAT(value) {
    const floatValue = parseFloat(value);
    if (isNaN(floatValue)) {
        throw new TypeError("Cannot convert to float");
    }
    return floatValue;
}

// Function to find the position of needle in haystack (string overload)
function InStr(haystack, needle) {
    const pos = haystack.indexOf(needle);
    return (pos !== -1) ? pos + 1 : 0;
}

// Function to simulate input() in JavaScript
function input(promptText) {
    // Display the prompt and get user input
    return prompt(promptText);
}

function StrLen(s) {
    // Return the length of the given string
    return s.length;
}

function Exp(value) {
    return Math.exp(value);
}

function SubStr(str, startPos, length) {
    // If str is null or undefined, return an empty string
    if (str === null || str === undefined) {
        return "";
    }
    // If length is not provided or is blank, default to "all characters"
    if (length === undefined || length === "") {
        length = str.length - startPos + 1;
    }
    // If startPos is less than 1, adjust it to start from the end of the string
    if (startPos < 1) {
        startPos = str.length + startPos;
    }
    // Extract the substring based on startPos and length
    return str.substr(startPos - 1, length);
}

function Trim(inputString) {
    return inputString ? inputString.trim() : "";
}

function StrReplace(originalString, find, replaceWith) {
    return originalString.split(find).join(replaceWith);
}

function StringTrimLeft(input, numChars) {
    return (numChars <= input.length) ? input.substring(numChars) : input;
}

function StringTrimRight(input, numChars) {
    return (numChars <= input.length) ? input.substring(0, input.length - numChars) : input;
}

// RegExMatch
function RegExMatch(haystack, needle) {
    const regex = new RegExp(needle);
    const match = haystack.match(regex);
    return match ? match.index + 1 : 0; // 1-based index or 0 if no match
}


//Shunting Yard Algorithm
var str1 = "";
var str2 = "";
var str3 = "";
var str4 = "";
var str5 = "";
var str6 = "";
var str7 = "";
var str8 = "";
var str9 = "";
var str10 = "";
var int1 = 0;
var int2 = 0;
var int3 = 0;
var int4 = 0;
var int5 = 0;
var int6 = 0;
var int7 = 0;
var float1 = 0.0;
var float2 = 0.0;
var float3 = 0.0;
var float4 = 0.0;
var float5 = 0.0;
async function  swapLast2StrArrayElement(theStrArray) {
    // Check if the array has at least two elements
    if (theStrArray.length < 2) {
        return theStrArray;
    }
    // Get the indices of the last two elements
    var lastIndex = theStrArray.length - 1;
    var secondLastIndex = lastIndex - 1;
    // Swap the last two elements
    var temp = theStrArray[lastIndex];
    theStrArray[lastIndex] = theStrArray[secondLastIndex];
    theStrArray[secondLastIndex] = temp;
    // Return the modified array
    return theStrArray;
}
async function  popFirstStrArrayElement(theStrArray) {
    let out123 = [];
    for (let A_Index1 = 0; A_Index1 < theStrArray.length + 0; A_Index1++) {
        if (A_Index1 > 0) {
            out123.push(theStrArray[A_Index1]);
        }
    }
    return out123;
}
async function ExpresionEvalNoParentesis(expresion) {
    var expresionOut = "";
    let holdingStack = [];
    let outputTemp = [];
    let solvingStack = [];
    var input = "0";
    var arithmeticOperations = "+-/*";
    var arithmeticOperationStrength = 0;
    var tempPopHoldingStack = "";
    var indexOfexpresionLoop = 0;
    var tempHoldingStackNumFIX = 0;
    var expresion = StrReplace(expresion, " ", "");
    expresion = StrReplace(expresion, "-", " - ");
    expresion = StrReplace(expresion, "+", " + ");
    expresion = StrReplace(expresion, "*", " * ");
    expresion = StrReplace(expresion, "/", " / ");
    expresion = StrReplace(expresion, "(", " ( ");
    expresion = StrReplace(expresion, ")", " ) ");
    var addNegativeNums = "";
    let addNegativeNumsFurture = [];
    expresion = Trim(expresion);
    items2 = LoopParseFunc(expresion, " ")
    for (let A_Index2 = 0; A_Index2 < items2.length + 0; A_Index2++) {
        const A_LoopField2 = items2[A_Index2 - 0];
        addNegativeNumsFurture.push(A_LoopField2);
    }
    var skip = 0;
    addNegativeNumsFurture.push("");
    items3 = LoopParseFunc(expresion, " ")
    for (let A_Index3 = 0; A_Index3 < items3.length + 0; A_Index3++) {
        const A_LoopField3 = items3[A_Index3 - 0];
        if (A_Index3 == 0 && A_LoopField3 == "-") {
            addNegativeNums += Trim(A_LoopField3) + addNegativeNumsFurture[A_Index3 + 1] + " ";
            skip = 1;
        }
        else if (A_LoopField3 == "-" && (addNegativeNumsFurture[A_Index3 - 1] == "*" || addNegativeNumsFurture[A_Index3 - 1] == "/" || addNegativeNumsFurture[A_Index3 - 1] == "-" || addNegativeNumsFurture[A_Index3 - 1] == "+")) {
            addNegativeNums += Trim(A_LoopField3) + addNegativeNumsFurture[A_Index3 + 1] + " ";
            skip = 1;
        } else {
            if (skip != 1) {
                addNegativeNums += A_LoopField3 + " ";
                skip = 0;
            } else {
                skip = 0;
            }
        }
    }
    expresion = StringTrimRight(addNegativeNums, 1);
    expresion = Trim(expresion);
    //print("DEBUGGGGGGGGGGGG:" . expresion)
    let output234543 = [];
    items4 = LoopParseFunc(expresion, " ")
    for (let A_Index4 = 0; A_Index4 < items4.length + 0; A_Index4++) {
        const A_LoopField4 = items4[A_Index4 - 0];
        indexOfexpresionLoop = A_Index4 + 1;
        input = A_LoopField4;
        if (InStr(arithmeticOperations, input) == 0) {
            // numbers
            //print(input)
            outputTemp.push(input);
        } else {
            // arithmeticOperation
            //print(input)
            if (holdingStack.length == 0) {
                holdingStack.push(input);
            } else {
                if (InStr(arithmeticOperations, input) == InStr(arithmeticOperations, holdingStack[holdingStack.length - 1])) {
                    outputTemp.push(input);
                }
                else if (InStr(arithmeticOperations, holdingStack[holdingStack.length - 1]) < InStr(arithmeticOperations, input)) {
                    holdingStack.push(input);
                } else {
                    // what do we do
                    // add the last
                    for (let A_Index5 = 0; ; A_Index5++) {
                        if (holdingStack.length > 0 && InStr(arithmeticOperations, holdingStack[holdingStack.length - 1]) > InStr(arithmeticOperations, input)) {
                            tempHoldingStackNumFIX = holdingStack.length;
                            for (let A_Index6 = 0; A_Index6 < tempHoldingStackNumFIX + 0; A_Index6++) {
                                tempPopHoldingStack = holdingStack[holdingStack.length - 1];
                                holdingStack.pop();
                                outputTemp.push(tempPopHoldingStack);
                            }
                        } else {
                            break;
                        }
                    }
                    holdingStack.push(input);
                }
                // 2 else and 1 loop end
            }
        }
    }
    if (holdingStack.length != 0 || STR(holdingStack.length) != "") {
        for (let A_Index7 = 0; A_Index7 < holdingStack.length + 0; A_Index7++) {
            if (Trim(holdingStack[holdingStack.length - 1 - A_Index7]) != "") {
                outputTemp.push(holdingStack[holdingStack.length - 1 - A_Index7]);
            }
        }
    }
    var fixOutputTempRMparanesises = outputTemp.length;
    let outputTemp2 = [];
    for (let A_Index8 = 0; A_Index8 < fixOutputTempRMparanesises + 0; A_Index8++) {
        if (Trim(outputTemp[A_Index8]) != "") {
            outputTemp2.push(outputTemp[A_Index8]);
        }
    }
    outputTemp = outputTemp2;
    print(outputTemp);
    for (let A_Index9 = 0; ; A_Index9++) {
        if (outputTemp.length == 0 || STR(outputTemp.length) == "") {
            break;
        }
        tempPopHoldingStack = outputTemp[0];
        outputTemp = await popFirstStrArrayElement(outputTemp);
        solvingStack.push(tempPopHoldingStack);
        if (InStr(arithmeticOperations, solvingStack[solvingStack.length - 1]) != 0) {
            solvingStack = await swapLast2StrArrayElement(solvingStack);
            float1 = FLOAT(solvingStack[solvingStack.length - 3]);
            str2 = solvingStack[solvingStack.length - 2];
            float3 = FLOAT(solvingStack[solvingStack.length - 1]);
            solvingStack.pop();
            solvingStack.pop();
            solvingStack.pop();
            if (str2 == "-") {
                float4 = float1 - float3;
                solvingStack.push(STR(float4));
            }
            if (str2 == "+") {
                float4 = float1 + float3;
                solvingStack.push(STR(float4));
            }
            if (str2 == "*") {
                float4 = float1 * float3;
                solvingStack.push(STR(float4));
            }
            if (str2 == "/") {
                float4 = float1 / float3;
                solvingStack.push(STR(float4));
            }
        }
    }
    expresionOut = Trim(solvingStack[solvingStack.length - 1]);
    if (SubStr(expresionOut, 1, 2) == "- ") {
        expresionOut = StringTrimLeft(expresionOut, 2);
        expresionOut = "-" + expresionOut;
    }
    if (Trim(expresionOut) == "") {
        expresionOut = "null";
    }
    return expresionOut;
}
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
async function expresionEvalHelp(expression) {
    var startIndex = 0;
    var endIndex = 0;
    var innerExpression = "";
    var innerResult = "";
    var openCount = 0;
    var char123 = "";
    // Remove spaces for consistency
    var expression = StrReplace(expression, " ", "");
    // Loop until no more parentheses are left
    while (InStr(expression, "(")) {
        // Find the position of the first '('
        startIndex = InStr(expression, "(");
        // Now, find the matching closing ')'
        openCount = 1;
        endIndex = startIndex + 1;
        // Loop to find the matching closing ')'
        while (openCount > 0 && endIndex <= StrLen(expression)) {
            char123 = SubStr(expression, endIndex, 1);
            if (char123 == "(") {
                openCount++;
            }
            else if (char123 == ")") {
                openCount--;
            }
            endIndex++;
        }
        // Extract the inner expression
        innerExpression = SubStr(expression, startIndex + 1, endIndex - startIndex - 2);
        print(innerExpression);
        // Evaluate the inner expression (this is where recursion handles nested parentheses)
        innerResult = await expresionEvalHelp(innerExpression);
        // Replace the entire parentheses with the result
        expression = SubStr(expression, 1, startIndex - 1) + innerResult + SubStr(expression, endIndex);
    }
    // Now evaluate the expression without parentheses
    return await ExpresionEvalNoParentesis(expression);
}
async function callFunc(funcParams) {
    // just test
    var funcParamsOut = "";
    var funcParams = Trim(funcParams);
    funcParams = StringTrimRight(funcParams, 1);
    items10 = LoopParseFunc(funcParams, " ")
    for (let A_Index10 = 0; A_Index10 < items10.length + 0; A_Index10++) {
        const A_LoopField10 = items10[A_Index10 - 0];
        if (A_Index10 > 1) {
            funcParamsOut += A_LoopField10 + " ";
        }
    }
    funcParamsOut = StringTrimRight(funcParamsOut, 1);
    funcParams = Trim(StrReplace(Trim(funcParamsOut), " ", ""));
    funcParamsOut = "";
    items11 = LoopParseFunc(funcParams, ",")
    for (let A_Index11 = 0; A_Index11 < items11.length + 0; A_Index11++) {
        const A_LoopField11 = items11[A_Index11 - 0];
        funcParamsOut += await expresionEvalHelp(A_LoopField11) + "+";
    }
    funcParamsOut = StringTrimRight(funcParamsOut, 1);
    return await expresionEvalHelp(funcParamsOut);
}
async function expresionEval(expresion) {
    print("=========================");
    print(expresion);
    print("=========================");
    expresion = Trim(StrReplace(expresion, " ", ""));
    expresion = Trim(StrReplace(expresion, "(", " ( "));
    expresion = Trim(StrReplace(expresion, ")", " ) "));
    expresion = Trim(StrReplace(expresion, "+", " + "));
    expresion = Trim(StrReplace(expresion, "-", " - "));
    expresion = Trim(StrReplace(expresion, "/", " / "));
    expresion = Trim(StrReplace(expresion, "*", " * "));
    expresion = Trim(StrReplace(expresion, ",", " , "));
    let expresionForFuncLookInF = [];
    items12 = LoopParseFunc(expresion, " ")
    for (let A_Index12 = 0; A_Index12 < items12.length + 0; A_Index12++) {
        const A_LoopField12 = items12[A_Index12 - 0];
        expresionForFuncLookInF.push(A_LoopField12);
    }
    expresionForFuncLookInF.push("");
    var foundFunc = 0;
    var foundFunc2 = 0;
    var didWeSeeAfunc = 0;
    var countParentheses = 0;
    var countParenthesesOnceHelper = 0;
    var funcEndEnd = 0;
    var funcPosIndex1 = 0;
    var funcPosIndex2 = 0;
    var expresionReplaceHelper = "";
    var expresionReplaceHelper1 = "";
    for (let A_Index13 = 0; A_Index13 < 20 + 0; A_Index13++) {
        foundFunc = 0;
        foundFunc2 = 0;
        didWeSeeAfunc = 0;
        countParentheses = 0;
        countParenthesesOnceHelper = 0;
        funcEndEnd = 0;
        funcPosIndex1 = 0;
        funcPosIndex2 = 0;
        items14 = LoopParseFunc(expresion, " ")
        for (let A_Index14 = 0; A_Index14 < items14.length + 0; A_Index14++) {
            const A_LoopField14 = items14[A_Index14 - 0];
            if (foundFunc == 1) {
                if (RegExMatch(A_LoopField14, "^[A-Za-z_][A-Za-z0-9_]*$") && expresionForFuncLookInF[A_Index14 + 1] == "(" && foundFunc == 1) {
                    foundFunc2 = 1;
                    funcPosIndex1 = A_Index14;
                    countParentheses = 0;
                    countParenthesesOnceHelper = 0;
                    print("debug in: " + A_LoopField14);
                }
                if (A_LoopField14 == "(") {
                    countParentheses++;
                    countParenthesesOnceHelper++;
                }
                if (A_LoopField14 == ")") {
                    countParentheses--;
                }
                if (countParenthesesOnceHelper != 0) {
                    if (countParentheses == 0) {
                        funcEndEnd = 1;
                        funcPosIndex2 = A_Index14;
                        break;
                    }
                }
            }
            // Check if the variable matches the regex pattern
            if (RegExMatch(A_LoopField14, "^[A-Za-z_][A-Za-z0-9_]*$") && expresionForFuncLookInF[A_Index14 + 1] == "(" && foundFunc == 0) {
                foundFunc = 1;
                funcPosIndex1 = A_Index14;
                //print(A_LoopField14)
            }
        }
        if (foundFunc != 1) {
            print("no more funcs");
            expresion = Trim(expresion);
            expresion = Trim(await expresionEvalHelp(expresion));
            // eval
            // eval
            // eval
            // eval
            // eval
            // eval
            break;
        }
        expresionReplaceHelper1 = "";
        expresionReplaceHelper = "";
        items15 = LoopParseFunc(expresion, " ")
        for (let A_Index15 = 0; A_Index15 < items15.length + 0; A_Index15++) {
            const A_LoopField15 = items15[A_Index15 - 0];
            if (A_Index15 >= funcPosIndex1 && A_Index15 < funcPosIndex2) {
                expresionReplaceHelper1 += A_LoopField15 + " ";
                print("found: " + A_LoopField15);
            }
            else if (A_Index15 == funcPosIndex2) {
                expresionReplaceHelper1 += A_LoopField15 + " ";
                print("found: " + A_LoopField15);
                expresionReplaceHelper += await callFunc(Trim(expresionReplaceHelper1)) + " ";
            } else {
                expresionReplaceHelper += A_LoopField15 + " ";
            }
        }
        expresion = Trim(expresionReplaceHelper);
        print("=========================");
        print(expresion);
        print("=========================");
        if (InStr(Trim(expresion), " ")) {
            continue;
        } else {
            break;
        }
    }
    // eval too
    // eval too
    // eval too
    // eval too
    expresion = Trim(expresion);
    // eval too
    expresion = Trim(await expresionEvalHelp(expresion));
    return expresion;
}
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
async function main() {
    print("Shunting Yard Algorithm");
    var expresion = "1+2*4-3";
    print(await expresionEvalHelp(expresion));
    var testExpresions = "3+5|12-4|7*3|18/6|4+92|10-23|15+3-2|87-9|6+8/4|32+5|18-4/2|6/3+8|14-62|5+9/3|75-3|8+43|9/3+42|12+6*2-3|16-4/2+3|1+2*4-3";
    var answersOfTheTestExpresions = "8|8|21|3|96|-13|16|78|8|37|16|10|-48|8|72|51|45|21|17|6";
    var testIndexTestExpresions = 0;
    var TEMPanswersOfTheTestExpresions = "";
    var DidWePassTheTestExpresions = 1;
    var DidWePassTheTestExpresionsCOUNT = 0;
    var DidWePassTheTestExpresionsCOUNTMAX = 0;
    items16 = LoopParseFunc(testExpresions, "|")
    for (let A_Index16 = 0; A_Index16 < items16.length + 0; A_Index16++) {
        const A_LoopField16 = items16[A_Index16 - 0];
        DidWePassTheTestExpresionsCOUNT++;
        DidWePassTheTestExpresionsCOUNTMAX++;
        testIndexTestExpresions = A_Index16;
        items17 = LoopParseFunc(answersOfTheTestExpresions, "|")
        for (let A_Index17 = 0; A_Index17 < items17.length + 0; A_Index17++) {
            const A_LoopField17 = items17[A_Index17 - 0];
            if (A_Index17 == testIndexTestExpresions) {
                TEMPanswersOfTheTestExpresions = A_LoopField17;
            }
        }
        print(STR(A_Index16 + 1) + " ===============================");
        print(A_LoopField16);
        print(await expresionEvalHelp(A_LoopField16));
        if (FLOAT(await expresionEvalHelp(A_LoopField16)) == FLOAT(TEMPanswersOfTheTestExpresions)) {
            print("true");
        } else {
            print("false");
            DidWePassTheTestExpresionsCOUNT--;
            DidWePassTheTestExpresions = 0;
        }
    }
    print("==================================");
    print("==================================");
    if (DidWePassTheTestExpresions == 0) {
        print("TestExpresions NOT PASSED!!! " + STR(DidWePassTheTestExpresionsCOUNT) + "/" + STR(DidWePassTheTestExpresionsCOUNTMAX));
    } else {
        print("TestExpresions PASSED!!!" + STR(DidWePassTheTestExpresionsCOUNT) + "/" + STR(DidWePassTheTestExpresionsCOUNTMAX));
    }
    print("5+(5+5)*1");
    print(await expresionEvalHelp("5+(5+5)*1"));
    print("6+((8/2+6+((8/2)*3+6+((8+6+((8/2+6+((8/2)*3+6+((8/2)*3)))*3)/2)*3)))*3)");
    print(await expresionEvalHelp("6+((8/2+6+((8/2)*3+6+((8+6+((8/2+6+((8/2)*3+6+((8/2)*3)))*3)/2)*3)))*3)"));
    print("((3 + 5) * (10 - 4) / 2) + (-7 * (3 + 2)) - (4 / (6 - 2)) * -3");
    print(await expresionEvalHelp("((3 + 5) * (10 - 4) / 2) + (-7 * (3 + 2)) - (4 / (6 - 2)) * -3"));
    print("-((1+2)/((6*-7)+(7*-4)/2)-3)");
    print(FLOAT(await expresionEvalHelp("-((1+2)/((6*-7)+(7*-4)/2)-3)")));
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    print("=-=-=-=-=-=-=-=-=-=-=-=-=-=");
    print(await expresionEval("-5+func1(45+1, 5+5+(58+5/2--2), func2(56, func3(func4(5))))"));
}
main();
</script>
</body>
</html>
