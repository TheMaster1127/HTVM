### Arrays

[Go back](#htvm-documentation)

Dive into working with arrays, one of the most essential data structures in HTVM. Arrays are simple to declare and manipulate, enabling you to store and process collections of data easily.

### **Arrays in HTVM**

Arrays in HTVM are collections of values stored in a single variable. Arrays can hold multiple values of the same type. HTVM supports a variety of array types and offers flexibility, especially in dynamic languages. Here's an overview of how arrays work in HTVM:

---

### **Supported Array Types**  

HTVM supports the following array types:

| Type        | Description |
|-------------|------------|
| `%%%doc_keyWordArrayOfIntegersDefinition%%%`     | Array of integers (regular size depends on the target language) |
| `%%%doc_keyWordArrayOfFloatingPointNumbersDefinition%%%`   | Array of floating-point numbers |
| `%%%doc_keyWordArrayOfBooleansDefinition%%%`    | Array of booleans (true or false) |
| `%%%doc_keyWordArrayOfStringsDefinition%%%`  | Array of strings (text) |

> **Note:** In dynamic languages like JavaScript and Python, you can use arrays without explicitly defining the type. The type will be inferred or stripped out, depending on the language.

---

### **The Generic Array Type**  

In addition to the specific array types above, HTVM provides a more flexible **generic array** keyword which is `%%%doc_keyWordArrayDefinition%%%`. This allows you to create arrays without specifying a type. When you use this keyword:

- In **dynamically typed languages** (e.g., JavaScript, Python), HTVM will infer the type based on the values you assign.
- In **statically typed languages** (e.g., C++, Java), HTVM will convert it into a `std::vector&lt;std::string>` / `string[]`.

This provides flexibility, but also means you lose type checking, and you’ll need to ensure the elements in the array match the expected type.

Example (Dynamic Language):
```htvm
%%%htvmSnippet20%%%

```

---

### **Array Methods in HTVM**

| **Method**                          | **Description**                                                                                |
|-------------------------------------|------------------------------------------------------------------------------------------------|
| `%%%doc_keyWordArrayAppend%%%()`    | Adds an element to the end of the array.                                                       |
| `%%%doc_keyWordArrayPop%%%()`       | Removes and returns the last element of the array.                                             |
| `%%%doc_keyWordArraySize%%%()`      | Returns the number of elements in the array.                                                   |
| `%%%doc_keyWordArrayInsert%%%()`    | Inserts an element at a specific index.                                                        |
| `%%%doc_keyWordArrayRemove%%%()`    | Removes the element at the specified index.                                                    |
| `%%%doc_keyWordArrayIndexOf%%%()`   | Returns the index of the first occurrence of the specified element. Returns `-1` if not found. |

---

### **Array Methods in Detail**

HTVM provides a set of useful methods to manipulate arrays in your programs. These methods follow a consistent `.method()` syntax, making it easy to interact with arrays. Below are the array methods supported in HTVM:

1. **`%%%doc_keyWordArrayAppend%%%()`**  

Adds an element to the end of the array.  
Example:
```htvm
%%%htvmSnippet21%%%

```

2. **`%%%doc_keyWordArrayPop%%%()`**  

Removes and returns the last element of the array.  
Example:
```htvm
%%%htvmSnippet22%%%

```

3. **`%%%doc_keyWordArraySize%%%()`**  

Returns the number of elements in the array.  
Example:
```htvm
%%%htvmSnippet23%%%

```

4. **`%%%doc_keyWordArrayInsert%%%()`** 
 
Inserts an element at a specific index. The index is the first argument, and the element to insert is the second argument.  
Example:
```htvm
%%%htvmSnippet24%%%

```

5. **`%%%doc_keyWordArrayRemove%%%()`**  

Removes the element at the specified index.  
Example:
```htvm
%%%htvmSnippet25%%%

```

6. **`%%%doc_keyWordArrayIndexOf%%%()`**  

Returns the index of the first occurrence of the specified element. If the element is not found, it returns `-1`.  
Example:
```htvm
%%%htvmSnippet26%%%

```

---

### **Example of Using Array Methods in HTVM**

```htvm
%%%htvmSnippet27%%%

```

In the example above, you can see how various methods like `.push()`, `.rm()`, and `.insert()` are used in sequence to manipulate the array.

---

### **Summary of Array Methods**

- **`%%%doc_keyWordArrayAppend%%%()`**: Adds an element to the end of the array.
- **`%%%doc_keyWordArrayPop%%%()`**: Removes and returns the last element of the array.
- **`%%%doc_keyWordArraySize%%%()`**: Returns the size of the array.
- **`%%%doc_keyWordArrayInsert%%%(index, element)`**: Inserts an element at the specified index.
- **`%%%doc_keyWordArrayRemove%%%(index)`**: Removes the element at the specified index.
- **`%%%doc_keyWordArrayIndexOf%%%(element)`**: Finds the index of the first occurrence of the specified element.

---

### **Arrays in Programming Blocks**  

Just like variables, arrays can be accessed and modified inside **programming blocks**. Programming blocks in HTVM are directly written in the target language and do not undergo conversion. The following behaviors apply to arrays inside programming blocks:

- **Arrays persist across blocks**, meaning changes made to an array within a block are retained when the block ends.
- **Arrays are not scoped**—they are part of the target language’s code.
- **Different programming languages do not share arrays across blocks**, just like variables.

Example (Converting to Python):

```htvm
%%%htvmSnippet28%%%

```

This will convert to:

```python
myArray = [1, 2, 3]
myArray.append(4)  # Python block stays intact
print(myArray)  # Output: [1, 2, 3, 4]
```

---

### **No Type Checking for Arrays**  

HTVM **does not perform type checking** for arrays. It will **not warn you** if you accidentally try to mix types within an array or if you make other mistakes related to array types. You will only notice errors during runtime in the target language.

Example:

```htvm
%%%htvmSnippet29%%%

```

In **JavaScript**, this would become:

```javascript
let myArray = [1, "two", 3];  // Valid in JavaScript, but mixed types
```

However, you might get unexpected results in a **statically typed language**, like **C++**.

---

### **No `const` Arrays**  

HTVM does not support **constant arrays** or array immutability like some languages might (e.g., `const` arrays in JavaScript). If you want to have immutable arrays, you will need to **use programming blocks** and ensure the logic prevents modification.

Example:

```htvm
%%%htvmSnippet30%%%


```

If you want immutability or similar behavior, you must handle it manually within programming blocks or by controlling logic in your code.

---

### **Arrays in Multiple Language Conversions**  

When converting to **multiple languages**, arrays function similarly to variables in programming blocks. However, you cannot directly **share arrays between different language blocks**. Each block is isolated in its respective language, so any array manipulations within one block will not affect another block.

Example (Invalid cross-language access):

```htvm
%%%htvmSnippet31%%%

```

You’ll need to manually synchronize arrays between programming blocks if needed.

---

### **Summary**  

- HTVM supports **integer arrays**, **floating-point arrays**, **boolean arrays**, and **string arrays**.
- **Array Methods in HTVM**
- HTVM offers a **generic array type**, which is flexible but removes type checking in dynamic languages.
- **Arrays in programming blocks persist**, but they are not scoped across blocks.
- **No type checking** is performed on arrays, so errors related to mismatched types will not be caught until runtime.
- **No support for constant arrays**—you need to manage immutability yourself using programming blocks.
- **Arrays cannot be shared across different language blocks** in multiple language conversions.

#### ⚠️ WARNING: We can't use nested arrays or multiline arrays (like arrays inside arrays or 2D/3D arrays). To achieve that, use a programming block.

---