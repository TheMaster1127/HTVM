# OSP (Ordinal Struct Programming)

[Go back](#htvm-documentation)

OSP is HTVM's built-in system for organizing data using **structs** and **instances**. It provides a clean, developer-friendly way to define data structures and create multiple independent copies of them with minimal syntax.

---

## Table of Contents

1. [Structs: The Basics](#structs-the-basics)
2. [Type Inference](#type-inference)
3. [Instances: Creating Data](#instances-creating-data)
4. [Arrays in Structs](#arrays-in-structs)
5. [Organization with `crew` and `alliance`](#organization-with-crew-and-alliance)
6. [Syntax Styles: New vs. Old](#syntax-styles-new-vs-old)
7. [The Formatter (Optional Tool)](#the-formatter-optional-tool)
8. [Complete Examples](#complete-examples)
9. [Common Patterns](#common-patterns)

---

## Structs: The Basics

A `struct` is a container for related data. You define it once, then create multiple independent **instances** of it.

**Basic struct definition:**

```htvm
struct Player
    health: 100
    mana: 50
subout
```

This defines a struct named `Player` with two properties: `health` and `mana`, both initialized to their respective values.

**Key rule:** Always close a struct with `subout` (the end kryword is `NOT` allowed for the new syntax with `subout`).

---

## Type Inference

When you use the new syntax (colon-style with `subout`), HTVM automatically infers types from the initial values:

- **`int`** ← inferred from numeric values (e.g., `100`, `50`)
- **`str`** ← inferred from string values (e.g., `"hello"`)
- **`float`** ← inferred from floating-point values (e.g., `3.14`, `2.5`)

**Examples of inference:**

```htvm
struct Character
    name: "Warrior"           ; Inferred as str
    level: 5                  ; Inferred as int
    experience: 1250.75       ; Inferred as float
subout
```

### What About Booleans and Arrays?

**Booleans and arrays are NOT inferred.** You must use the `prop` keyword explicitly for these types:

```htvm
struct Player
    health: 100              ; Inferred as int
    prop bool isAlive        ; Must use prop for bool
    prop arr str inventory   ; Must use prop for arrays
subout
```

---

## Instances: Creating Data

⚠️ **CRITICAL BEFORE YOU START:** If you plan to use `instance` anywhere in your code, **NEVER use `crew` or `alliance` in that project.** Mixing them causes bugs. You must choose one approach: either instances with standalone structs, OR crews/alliances for organization (no instances at all).

An **instance** is an independent copy of a struct with its own data. You create instances using the `instance` keyword:

**Basic instance creation:**

```htvm
struct Player
    health: 100
    mana: 50
subout

main
    instance Player as hero
    instance Player as goblin
    hero.health := 200
    goblin.health := 30
    print("Hero health: " . STR(hero.health))
    print("Goblin health: " . STR(goblin.health))
```

**How it works:**

- `instance Player as hero` creates a new variable `hero` with all of `Player`'s properties
- Each instance is **completely independent** — modifying `hero.health` does NOT affect `goblin.health`
- All instances are **globally accessible** by their name (below the point of creation)
- Instance names become global variables that hold the struct's data

---

## Arrays in Structs

Arrays must be declared using the `prop` keyword. You cannot use type inference for arrays.

**Declaring array properties:**

```htvm
struct Inventory
    prop arr str items
    prop arr int quantities
subout

main
    instance Inventory as backpack
    backpack.items.add("sword")
    backpack.items.add("shield")
    backpack.quantities.add(1)
    backpack.quantities.add(1)
```

**Array methods:**

- **`.add(value)`** or **`.push(value)`** — Add an item to the array (both work the same)
- **`.size()`** — Get the array length
- **`[index]`** — Access element by index (zero-based)

**Complete array example:**

```htvm
struct Player
    health: 100
    prop arr str spells
subout

main
    instance Player as wizard
    wizard.spells.add("Fireball")
    wizard.spells.add("Ice Storm")
    wizard.spells.add("Lightning")
    
    Loop, % wizard.spells.size()
        print(wizard.spells[A_Index])
    end
```

---

## Organization with `crew` and `alliance`

For larger projects, you can organize structs using `crew` and `alliance` containers:

- **`alliance`** — Top-level organizational container
- **`crew`** — Sub-container within an alliance (or standalone)

**Purpose:** Group related structs logically and avoid naming conflicts.

**Important:** Crew and alliance use end keyword syntax, not `subout`.

**Using `crew`:**

```htvm
crew Audio
    struct Settings
        volume: 80
        pitch: 1.0
    subout
end

main
    ; Access the struct's default properties directly
    Audio.Settings.volume := 100
    print("Audio volume: " . STR(Audio.Settings.volume))
```

**Using `alliance`:**

```htvm
alliance Game
    crew Entities
        struct Player
            health: 100
            mana: 50
        subout
    end
    
    crew UI
        struct Button
            x: 0
            y: 0
            label: "Click me"
        subout
    end
end

main
    ; Access struct properties using their full path
    Game.Entities.Player.health := 200
    Game.UI.Button.label := "Start Game"
    print("Player health: " . STR(Game.Entities.Player.health))
```

### ⚠️ CRITICAL: Never Mix Crew/Alliance with Instances

**If you use `instance` in your code, you CANNOT use `crew` or `alliance` anywhere in that same project.** This applies even to standalone structs. Mixing them causes bugs.

You must choose ONE approach:
- **Option A:** Use standalone structs + instances (NO crews/alliances anywhere)
- **Option B:** Use crews/alliances for organization (NO instances anywhere)

**This causes bugs:**
```htvm
crew Audio
    struct Settings
        volume: 80
    subout
end

struct Player
    health: 100
subout

main
    ; DON'T mix them like this
    instance Player as hero  ; This will cause bugs if you have crew/alliance
    Audio.Settings.volume := 100
```

**Option A (instances only):**
```htvm
struct Player
    health: 100
subout

struct Settings
    volume: 80
subout

main
    instance Player as hero
    instance Settings as config
```

**Option B (crew/alliance only):**
```htvm
crew Audio
    struct Settings
        volume: 80
    subout
end

crew Game
    struct Player
        health: 100
    subout
end

main
    ; Access properties directly, no instances
    Game.Player.health := 200
    Audio.Settings.volume := 100
```

---

## Syntax Styles: New vs. Old

HTVM supports two syntax styles. You can use them separately or mix them in the same struct.

### New Style (Inference with `subout`):

```htvm
struct Player
    health: 100
    mana: 50
    name: "Hero"
subout
```

Clean, minimal, types inferred automatically.

### Old Style (Explicit with `prop` and `end`):

```htvm
struct Player
    prop int health := 100
    prop int mana := 50
    prop str name := "Hero"
subout
```

Verbose, but explicit types.

### Mixed Style:

```htvm
struct Player
    health: 100
    name: "Hero"
    prop bool isAlive
    prop arr str inventory
subout
```

Use inference for simple types, `prop` for complex ones.

---

## The Formatter (Optional Tool)

The formatter is a **code beautification tool**. It is **completely optional** and does NOT affect compilation.

**What the formatter does:**

- Converts new syntax (`health: 100` with `subout`) to old syntax (`prop int health := 100` with `end`)
- Adds explicit types to all properties
- Removes indentation from `main` blocks (standard formatting)
- Keeps instance declarations clean and unchanged

**Using the formatter:**

In HT-IDE, press `Ctrl+Shift+F` to format your code.

**Important:** You do NOT need to use the formatter. Your code compiles the same way with or without formatting.

### ⚠️ Important: You Don't Have to Convert Everything

After formatting, **you do NOT have to convert every struct back to inference syntax.** The old syntax with end keyword and `prop` keywords works fine and compiles without any issues.

**You can:**
- Keep some structs in old syntax (end keyword with `prop`)
- Convert only the structs you want to inference syntax
- Mix both syntaxes in the same file

**Example: Mixed syntax in one file:**
```htvm
; Old style (formatted) — perfectly fine to leave as-is
struct Audio
    prop int volume := 80
    prop float pitch := 1.0
end

; New style (inference) — you converted this one
struct Player
    health: 100
    mana: 50
subout

; Another old style — no need to convert
struct Settings
    prop str theme := "dark"
end
```

Both syntaxes compile identically. Convert only when you want to, not because you have to.

**If you want to selectively convert a struct back to new syntax:**

1. Replace the end keyword whit `subout`
2. *Optional:* Remove `prop` keywords and explicit types (or keep them — both work)

Example of converting back:
```htvm
; Before (formatted style)
struct Player
    prop int health := 100
    prop int mana := 50
end

; After (new inference style, prop removed)
struct Player
    health: 100
    mana: 50
subout
```

Or keep `prop` if you prefer (both are valid):

```htvm
; New style with prop kept
struct Player
    prop int health := 100
    prop int mana := 50
subout
```

**Bottom line:** Don't feel obligated to rewrite all your structs. The formatter output works fine as-is.

---

## Complete Examples

### Example 1: Simple Character System

```htvm
struct Character
    name: "Adventurer"
    level: 1
    experience: 0.0
    prop bool isAlive
subout

main
    instance Character as hero
    instance Character as enemy
    
    hero.level := 10
    hero.experience := 5000.5
    enemy.level := 5
    
    print("Hero: " . hero.name . " (Level " . STR(hero.level) . ")")
    print("Enemy: " . enemy.name . " (Level " . STR(enemy.level) . ")")
    print("Experience: " . STR(hero.experience))
```

### Example 2: Inventory System

```htvm
struct Item
    name: "Sword"
    value: 50
subout

struct Player
    name: "Warrior"
    gold: 1000
    prop arr str inventory
subout

main
    instance Player as adventurer
    
    adventurer.inventory.add("Iron Sword")
    adventurer.inventory.add("Shield")
    adventurer.inventory.add("Health Potion")
    
    print("Inventory:")
    Loop, % adventurer.inventory.size()
        print("  - " . adventurer.inventory[A_Index])
    end
```

### Example 3: Multiple Standalone Structs

```htvm
struct Weapon
    name: "Sword"
    damage: 25
    durability: 100
subout

struct Character
    health: 100
    mana: 50
    strength: 15
subout

main
    instance Character as player
    instance Weapon as sword
    
    player.health := 75
    sword.damage := 30
    
    print("Player Health: " . STR(player.health))
    print("Weapon Damage: " . STR(sword.damage))
```

### Example 4: Arrays with Multiple Properties

```htvm
struct GameState
    currentLevel: 1
    prop arr str achievements
    prop arr int scores
    prop arr str playerNames
subout

main
    instance GameState as game
    
    game.achievements.add("First Kill")
    game.achievements.add("Level 10")
    game.achievements.add("Boss Defeated")
    
    game.scores.add(1000)
    game.scores.add(2500)
    game.scores.add(5000)
    
    game.playerNames.add("Hero")
    game.playerNames.add("Villain")
    game.playerNames.add("NPC")
    
    print("=== Achievements ===")
    Loop, % game.achievements.size()
        print(game.achievements[A_Index])
    end
    
    print("=== Scores ===")
    Loop, % game.scores.size()
        print("Score: " . STR(game.scores[A_Index]))
    end
```

---

## Common Patterns

### Pattern 1: Default Values with Instances

```htvm
struct Player
    health: 100
    mana: 50
subout

main
    instance Player as hero
    instance Player as goblin
    ; Both start with default values
    print("Hero: " . STR(hero.health))  ; 100
    print("Goblin: " . STR(goblin.health)) ; 100
    ; Then customize independently
    hero.health := 150
    goblin.health := 50
```

### Pattern 2: Mixed Property Types

```htvm
struct Settings
    volume: 75              ; int
    theme: "dark"           ; str
    brightness: 0.85        ; float
    prop bool soundEnabled  ; bool
    prop arr str languages  ; array
subout
```

### Pattern 3: Array Properties with Multiple Instances

```htvm
struct Player
    name: "Hero"
    prop arr str inventory
    prop arr int stats
subout

main
    instance Player as hero
    instance Player as companion
    
    hero.inventory.add("Sword")
    hero.inventory.add("Shield")
    
    companion.inventory.add("Dagger")
    companion.stats.add(100)
    companion.stats.add(50)
```

### Pattern 4: Multiple Instances of the Same Struct

```htvm
struct Enemy
    health: 50
    damage: 10
subout

main
    instance Enemy as goblin1
    instance Enemy as goblin2
    instance Enemy as goblin3
    
    goblin1.health := 40
    goblin2.health := 55
    goblin3.health := 50
    
    print("Goblin 1 Health: " . STR(goblin1.health))
    print("Goblin 2 Health: " . STR(goblin2.health))
    print("Goblin 3 Health: " . STR(goblin3.health))
```

---

### Instance Independence

Each instance is a **completely independent copy** of the struct. Modifying one instance does NOT affect others.

```htvm
struct Item
    name: "Sword"
    quantity: 1
subout

main
    instance Item as item1
    instance Item as item2
    
    item1.quantity := 5
    print(item2.quantity)  ; Still 1, not affected
```

### No Constructor Arguments

You cannot pass initial values when creating an instance. All instances start with the struct's default values, which you can then modify.

```htvm
; This does NOT work:
; instance Player as hero with health = 200

; Instead, do this:
instance Player as hero
hero.health := 200
```

### Type Inference Limitations

Remember: **Only `int`, `str`, and `float` are inferred.** Everything else requires `prop`.

```htvm
struct Example
    count: 42              ; OK — inferred as int
    text: "hello"          ; OK — inferred as str
    ratio: 3.14            ; OK — inferred as float
    prop bool flag         ; Required — bool is not inferred
    prop arr str list      ; Required — arrays are not inferred
subout
```

---

## Summary

### The Golden Rule

**If you use `instance`, you CANNOT use `crew` or `alliance` anywhere in your project. Choose one approach.**

### Basic Rules

- **Structs** define data templates
- **Instances** create independent copies of standalone structs only
- **Type inference** keeps code clean (int, str, float only)
- **`prop`** keyword required for booleans, arrays, and explicit typing
- **`crew`/`alliance`** organize structs hierarchically (never with instances)
- **Formatter** is optional and just beautifies code
- **Scope** Only the global scope. If you define a struct inside a function or in main, it will not work and will cause issues.
- **Instances are completely independent**

### Critical Syntax Rules

1. **End keyword is NOT allowed** when using new inference syntax with `subout`
2. **Never mix crew/alliance with instances** — pick one approach for your entire project
3. **Type inference** only works for `int`, `str`, `float` — everything else needs `prop`

### Quick Decision Guide

**Use instances if:**
- You need multiple independent copies of data
- You only use standalone structs
- You have NO crews/alliances in your project

**Use crews/alliances if:**
- You need to organize structs hierarchically
- You don't need multiple independent copies
- You'll never use the `instance` keyword

That's OSP! Simple, powerful, and ready for production.