### Variables

[Go back](#htvm-documentation)

Learn how to declare and use variables in HTVM for storing and manipulating data. HTVM makes working with variables straightforward by providing flexible types and easy handling of data.


### **Variables in HTVM**  

A variable is a way to store and reference data in your code. In HTVM, you can use different variable types depending on your needs. Here are all the variable types supported by HTVM:  

| Type         | Description |
|-------------|------------|
| `int`       | Regular integer (size depends on the target language) |
| `int8`      | 8-bit signed integer |
| `int16`     | 16-bit signed integer |
| `int32`     | 32-bit signed integer |
| `int64`     | 64-bit signed integer |
| `uint8`     | 8-bit unsigned integer |
| `uint16`    | 16-bit unsigned integer |
| `uint32`    | 32-bit unsigned integer |
| `uint64`    | 64-bit unsigned integer |
| `float`     | Floating-point number (usually 32-bit) |
| `double`    | Double-precision floating-point number |
| `char`      | Single character |
| `string`    | Text string |
| `bool`      | Boolean (`true` or `false`) |

> **Note:** We won't mention arrays here because they have a separate section under.

---

### **HTVM Variable Example**  

Here’s a simple example of declaring and printing variables in HTVM:  

```htvm
%%%htvmSnippet15%%%

```

This will correctly convert to the target language with the appropriate syntax.

---

### **Static vs. Dynamic Typing in HTVM**  

HTVM itself is **neither statically typed nor dynamically typed**. It simply converts code to the target language, which may be either.  

| **Language**  | **Typing** |
|--------------|------------|
| JavaScript   | Dynamic    |
| Python       | Dynamic    |
| Lua          | Dynamic    |
| Ruby         | Dynamic    |
| Groovy       | Dynamic    |
| TypeScript   | Static     |
| C++          | Static     |
| Go (Golang)  | Static     |
| C#           | Static     |
| Java         | Static     |
| Kotlin       | Static     |
| Nim          | Static     |
| Swift        | Static     |
| Dart         | Static     |
| AutoHotKey   | Dynamic    |

- **For static languages**, you **must** use types; otherwise, the conversion will result in invalid code.
- **For dynamic languages**, you **can** use types, but HTVM will **strip them away** automatically.
- **HTVM does not provide type safety** – it will not warn you about type mismatches. You'll find out only when running the target language.

---

#### **`let` and `var` Keywords**

The `let` and `var` keywords in HTVM are mainly useful when converting to languages that support these keywords, like **JavaScript** and **TypeScript**. These keywords are used to define mutable variables, but outside of those specific languages, you can ignore them, as HTVM will convert them appropriately based on the target language.

---

### **The `const` Keyword**  

HTVM supports the `const` keyword, but it **does not enforce it** in any way. It simply converts it to the target language if the language supports `const`.  

| **Language**  | **Supports `const`?** |
|--------------|--------------------|
| JavaScript   | ✅ Yes |
| TypeScript   | ✅ Yes |
| C++          | ✅ Yes |
| Go (Golang)  | ✅ Yes |
| C#           | ✅ Yes |
| Java         | ✅ Yes |
| Kotlin       | ✅ Yes |
| Swift        | ✅ Yes |
| Dart         | ✅ Yes |
| Python       | ❌ No (ignored) |
| Lua          | ❌ No (ignored) |
| Ruby         | ❌ No (ignored) |
| Groovy       | ❌ No (ignored) |
| Nim          | ✅ Yes |
| AutoHotKey   | ❌ No (ignored) |

HTVM **does not check** whether you're violating `const`. If a language doesn’t support `const`, HTVM **removes it** without warning.

Example:  

```htvm
%%%htvmSnippet16%%%

```

- If converting to **C++**, this becomes `const int x = 10;`
- If converting to **Python**, this becomes `x = 10` (no `const`).
- If converting to **Java**, this becomes `final int x = 10;`
- ... etc.

---

### **Programming Blocks & Variable Scope**  

HTVM allows **programming blocks**, where you write code directly in a target language. These blocks **do not convert** – they remain as-is.

#### **Variable Accessibility in Programming Blocks**
- **HTVM variables can be accessed inside programming blocks.**
- **Modifications inside a block persist after the block.**
- **Programming blocks are not scoped – they are part of the converted language.**
- **However, different programming languages do not share scope.**  

Example (Converting to Python):  

```htvm
%%%htvmSnippet17%%%

```

This converts to:  

```python
myNumber = 5
myNumber += 10  # Python block stays intact
print(myNumber)  # 15
```

---

### **Multiple Programming Blocks & Limitations**  

#### **Single Language Conversion**
If you are converting to just **one language**, everything works as expected. Variables declared in HTVM can be used inside the programming block and modified.

#### **Multiple Language Conversion**
If you are converting to **multiple languages**, each programming block is isolated per language.  
- **You cannot access variables across different language blocks.**  
- You must **manually maintain the same logic** in each block.  

Example (Invalid cross-language access):  

```htvm
%%%htvmSnippet18%%%

```

To fix this, you need to **manually synchronize values** in each programming block.

---

### **Unsigned Integers & Java**  

- **Java does not support unsigned integers** (`uint8`, `uint16`, etc.).
- If you try to use them, **HTVM will not warn you**, but Java might throw errors.
- **Avoid using unsigned integers when converting to Java.**  

Example of bad practice:  

```htvm
%%%htvmSnippet19%%%

```

- **Works in C++** (`uint32_t myUnsigned = 500;`)
- **Might fail in Java since unsigned ints are converted to signed ones**

---

### **Summary**

- HTVM has multiple **variable types**, including integers, floats, chars, strings, and booleans.
- HTVM **converts to both static and dynamic languages** but does not enforce type safety.
- The `const` keyword is supported but **ignored** in languages that don’t use it.
- **Programming blocks do not convert** – they stay in the target language.
- **Variables persist inside programming blocks** but do not transfer between different language blocks.
- **Java does not support unsigned integers**, so try to avoid them when converting to Java.

---