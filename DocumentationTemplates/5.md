### Functions

[Go back](#htvm-documentation)

Explore how to define and use functions for modular and reusable code. Functions in HTVM can be written easily, and the language supports efficient handling of function calls, parameters, and returns.

### **HTVM Functions**  

Functions %%%funcSentence%%%

#### **Defining a Function**

```htvm
%%%htvmSnippet32%%%

```

```htvm
%%%htvmSnippet33%%%

```

```htvm
%%%htvmSnippet34%%%

``` 

Optional parameters example:

```htvm
%%%htvmSnippet35%%%

```

If you are converting to a dynamically typed language, the types will be stripped away automatically. However, for statically typed languages, you must include them.  

#### The `main` Function

In HTVM, the `main` function is required if you are using functions. It is defined as a simple label at the beginning of the program. If you do not include the `main` function, HTVM will insert it automatically at the top of the code. However, if you define any functions and do not include the `main` label, the program will not work as expected.

The `main` label is where the execution starts in languages that use a main function (like C++). In languages that do not require a `main` function (like Python), HTVM handles it automatically.

Here’s how it looks:

```htvm
%%%htvmSnippet36%%%

```

- The `greet` function is defined before `main`.
- The `main` function calls `greet()` to execute the code.

If you do not define the `main` label, HTVM will automatically add it at the top of the code, but **you must include it if you are using functions** to ensure everything works correctly.

### **HTVM: Flexible Function Call Syntax**

#### **Overview**  
HTVM introduces a unique and flexible function call syntax that allows developers to call functions in multiple ways while maintaining simplicity and readability. This enhancement does not change the fundamental nature of functions in HTVM—they remain regular functions rather than methods. However, HTVM allows them to be called using dot notation for convenience. No programming language supports this level of freedom—this is a new invention: a flexible and freeing way to call HTVM functions.

#### **Features**

- **Traditional Function Calls**  
  Functions can be called using the standard syntax:  
  ```htvm
  StrLower(var1)
  Trim(var1)
  ```

- **Dot Notation for Function Calls**  
  HTVM allows functions to be called using dot notation for enhanced readability and convenience:  
  ```htvm
  var1.StrLower()
  var1.Trim()
  ```

- **Optional Parentheses**  
  When a function does not require additional parameters, parentheses can be omitted:  
  ```htvm
  var1.StrLower
  var1.Trim
  ```

- **Chained Function Calls**  
  Functions can be chained together using dot notation:  
  ```htvm
  var1.StrLower().Trim()
  ```

  Since parentheses are optional, the same operation can be written as:  
  ```htvm
  var1.StrLower.Trim
  ```

  It is also possible to mix both styles:  
  ```htvm
  var1.StrLower().Trim
  ```

- **Seamless Transpilation**  
  HTVM automatically converts these function calls into standard function calls during conversion. This ensures that the underlying implementation remains consistent while providing developers with flexibility in how they write their code.

#### **Examples**

### **Standard Function Calls**  
```htvm
StrLower(var1)
Trim(var1)
```

### **Dot Notation Function Calls**  
```htvm
var1.StrLower()
var1.Trim()
```

### **Dot Notation Without Parentheses**  
```htvm
var1.StrLower
var1.Trim
```

### **Chained Function Calls**  
```htvm
var1.StrLower().Trim()
```

### **Mixed Parentheses Usage**  
```htvm
var1.StrLower().Trim
```

### **Full Example with OSP**

```htvm
%%%htvmSnippet37%%%

```

---

#### This only works with HTVM built-in functions and user-defined functions.  
When using the `varName.funcName` format, HTVM will only convert it to a regular function call (`funcName(varName)`) **if** the function is either a built-in function in HTVM or explicitly defined by the user.

HTVM **does not care** whether the function is built-in in the target language (e.g. Python). If the function is not recognized by HTVM, it will not be converted — even if it's valid in the output language.

For example:
```py
strVar.upper()
```
- If `upper` is not a built-in HTVM function or user-defined in your code, HTVM will **not** convert this into `upper(strVar)` for Python.  
- It will stay as `strVar.upper()` or may cause unexpected output depending on the target.

---

#### **Conclusion**  
This feature enhances HTVM's usability by providing developers with multiple ways to call functions. While function calls remain standard behind the scenes, the optional dot notation and support for omitting parentheses make the syntax more intuitive, readable, and faster to write — especially in casual or repetitive scenarios.

---